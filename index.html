<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Haikyu Fly High - Team Builder by Devoy Aces</title>
<style>
    #menuBtn {
    width: 60px;
    height: 60px;
    font-size: 2.5em;
    padding: 0;
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #28a745;
    color: white;
    border: none;
    cursor: pointer;
    z-index: 1000;
    position: fixed;
    top: 15px;
    left: 15px;
}

#menuBtn:hover {
    background-color: #218838;
}
    #rotateBtn,
    #saveTeamBtn,
    #clearTeamBtn {
        font-size: 2em;
        padding: 20px 38px;
        min-width: 180px;
        border-radius: 8px;
    }
    body {
        background-color: #222;
        color: #fff;
        font-family: Arial, sans-serif;
        text-align: center;
    }

    h1 {
        margin-top: 20px;
    }

    .team-grid {
        display: flex;
        flex-direction: column;
        gap: 20px;
        align-items: center;
        margin-top: 30px;
    }

    .row {
        display: flex;
        gap: 20px;
    }

    .top-row {
        transform: translateX(6px);
    }

    .player-slot {
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    .hex {
        position: relative;
        width: 150px;
        height: 210px;
        background-color: #444;
        border-radius: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background 0.3s;
        overflow: hidden;
    }

    .hex:hover {
        background-color: #555;
    }

    .hex img {
        width: 100%;
        height: 100%;
object-fit: Save;
    }

    .player-info {
        margin-top: 5px;
        font-size: 14px;
        color: #fff;
        text-align: center;
        max-width: 150px;
        word-wrap: break-word;
    }

    .bench-slot {
        width: 50px;
        height: 67px;
        background-color: #444;
        border-radius: 5px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        overflow: hidden;
    }

    .bench-slot img {
        width: 100%;
        height: 100%;
         object-fit: Save;
    }

    .add-slot-btn {
        background-color: #28a745;
        border: none;
        color: white;
        padding: 5px 10px;
        margin-left: 10px;
        cursor: pointer;
        border-radius: 5px;
    }

    .add-slot-btn:hover {
        background-color: #218838;
    }
.bench-quick{
  display:flex; gap:6px; margin:0 10px;
}
.bench-quick-btn{
  background:#222; color:#fff; border:1px solid #555;
  border-radius:6px; padding:4px 6px; font-size:12px; cursor:pointer;
}
.bench-quick-btn:hover{ background:#333; }
    #saveTeamBtn {
        background-color: #28a745;
        border: none;
        color: white;
        padding: 6px 10px;
        margin-right: 10px;
        cursor: pointer;
        border-radius: 5px;
        font-size: 16px;
        vertical-align: middle;
    }

    #saveTeamBtn:hover {
        background-color: #218838;
    } 



    #synergy-panel {
        margin-top: 50px;
        background-color: #333;
        padding: 15px;
        border-radius: 10px;
        max-width: 600px;
        margin-left: auto;
        margin-right: auto;
        text-align: left;
    }

    .scroll-menu {
        display: none;
        margin-top: 10px;
        max-height: 200px;
        overflow-y: auto;
        background-color: #333;
        padding: 10px;
        border-radius: 8px;
        flex-wrap: wrap;
    }

    .scroll-menu img {
        width: 80px;
        height: auto;
        cursor: grab;
        margin: 5px;
        border: 2px solid transparent;
    }

    .scroll-menu img:hover {
        border: 2px solid yellow;
    }

    /* Painel lateral */
    .sidebar {
        position: fixed;
        top: 0;
        left: 0;
        width: 300px;
        height: 100%;
        background-color: #333;
        overflow-x: hidden;
        transition: transform 0.3s ease, opacity 0.3s ease;
        transform: translateX(-100%);
        padding: 20px;
        box-shadow: 2px 0 5px rgba(0,0,0,0.5);
        z-index: 999;
        opacity: 0;
        pointer-events: none;
        display: flex;
        flex-direction: column;
    }

    .sidebar.open {
        transform: translateX(0);
        opacity: 1;
        pointer-events: auto;
    }

    .sidebar h2 {
        color: #fff;
        margin-bottom: 20px;
    }

    .sidebar button.close-btn {
        background: none;
        border: none;
        color: #fff;
        font-size: 20px;
        cursor: pointer;
        position: absolute;
        top: 15px;
        right: 15px;
    }

    #menuBtn {
        position: fixed;
        top: 15px;
        left: 15px;
        background-color: #28a745;
        color: white;
        border: none;
        padding: 10px 15px;
        font-size: 18px;
        cursor: pointer;
        border-radius: 5px;
        z-index: 1000;
    }

    #menuBtn:hover {
        background-color: #218838;
    }
    /* Aumenta o botão no mobile / telas touch */
@media (max-width: 768px), (pointer: coarse) {
  #menuBtn {
    /* alvo de toque grande (recomendado 48–64px) */
    width: 64px;
    height: 64px;

    /* centraliza o ícone ☰ dentro do quadrado */
    display: inline-flex;
    align-items: center;
    justify-content: center;

    /* o ícone fica maior */
    font-size: 32px;

    /* remove o padding para não “esticar” além do width/height */
    padding: 0;

    /* arredondamento um pouco maior (opcional) */
    border-radius: 12px;
  }
}

    /* Lista de characters no menu */
    .char-list {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
    }

    .char-card {
        width: 80px;
        text-align: center;
        cursor: pointer;
    }

    .char-card img {
        width: 100%;
        border-radius: 5px;
    }

    /* Conteúdo do menu com rolagem */
    #sidebar {
    scroll-behavior: smooth;    
    position: fixed;
    right: 0;
    top: 0;
    width: 300px; /* ajuste conforme seu layout */
    height: 100vh; /* ocupa a tela inteira */
    background-color: #222;
    color: white;
    overflow-y: auto; /* ativa rolagem vertical */
    padding: 10px;
    box-sizing: border-box;


    /* Oculta a barra no Chrome, Edge, Safari */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE e Edge antigos */
}
    #sidebar::-webkit-scrollbar {
    display: none; /* Chrome, Safari, Edge */
}

    .filtros {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-bottom: 10px;
    }

    .filtros label {
        font-size: 14px;
        font-weight: bold;
        margin-bottom: 3px;
        display:block;
        text-align:left;
    }

    .filtros select {
        width: 100%;
        padding: 5px;
        font-size: 14px;
        border-radius: 5px;
        border: none;
    }

    #limparFiltros {
        background-color: #ff4d4d;
        color: white;
        border: none;
        padding: 6px;
        font-size: 14px;
        border-radius: 5px;
        cursor: pointer;
        width:100%;
    }

    #limparFiltros:hover {
        background-color: #e60000;
    }

    .saved-list button {
        margin-left: 8px;
        padding: 4px 8px;
        font-size: 13px;
        border-radius: 4px;
        cursor: pointer;
        border: none;
    }
    .saved-list .load-btn { background:#28a745; color:#fff; }
    .saved-list .del-btn { background:#ff4d4d; color:#fff; }

    .bond-btn {
    background-color: #444;
    color: white;
    border: 1px solid #666;
    border-radius: 6px;
    padding: 4px 8px;
    font-size: 14px;
    cursor: pointer;
    transition: background-color 0.2s, transform 0.2s;
}

.bond-btn:hover {
    background-color: #666;
    transform: scale(1.05);
}

.bond-btn:active {
    background-color: #888;
    transform: scale(0.98);
}
    .skill-btn {
    background-color: #555;
    color: white;
    border: 1px solid #777;
    border-radius: 6px;
    padding: 4px 8px;
    font-size: 14px;
    cursor: pointer;
    transition: background-color 0.2s, transform 0.2s;
}

.skill-btn:hover {
    background-color: #777;
    transform: scale(1.05);
}

.skill-btn:active {
    background-color: #999;
    transform: scale(0.98);
}
    .char-info {
    text-align: center;
    margin-top: 4px;
}

.char-name {
    font-weight: bold;
    font-size: 14px;
    color: #fff;
    margin: 0;
}

.char-Stats {
    font-size: 12px;
    color: #ccc;
    margin: 0;
}

.char-Stats span {
    font-weight: bold;
    color: #ffcc00; /* cor destaque do valor */
}
    #scrollMenu {
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE e Edge antigos */
}

#scrollMenu::-webkit-scrollbar {
    display: none; /* Chrome, Safari, Edge */
}
    #scrollMenu {
    overflow-y: auto; /* já está, mas reforçando */
}
   /* header de filtros dentro do scrollMenu (bench) */
#scrollMenu .bench-quick-inside{
  display:flex; gap:6px; padding:6px 6px 8px; flex-wrap:wrap;
}
#scrollMenu .bench-quick-inside button{
  background:#222; color:#fff; border:1px solid #555;
  border-radius:6px; padding:4px 6px; font-size:12px; cursor:pointer;
}
#scrollMenu .bench-quick-inside button.active{ outline:2px solid #999; }
    
#sidebar-content ul {
    list-style: none;       /* remove bullets */
    padding-left: 0;        /* remove recuo padrão */
    margin-left: 0;         /* evita deslocamento */
    text-align: center;     /* centraliza texto */
}

#sidebar-content li {
    margin-bottom: 4px;     /* espaço entre linhas */
}
    .filtros {
    background-color: #333;
    padding: 12px;
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.filtros label {
    font-size: 13px;
    font-weight: bold;
    margin-bottom: 4px;
}

.filtros select {
    width: 100%;
    padding: 6px;
    border: 1px solid #555;
    border-radius: 6px;
    background-color: #222;
    color: white;
}

#limparFiltros {
    background-color: #ff4d4d;
    border: none;
    padding: 8px;
    border-radius: 6px;
    font-weight: bold;
    cursor: pointer;
}

#limparFiltros:hover {
    background-color: #e60000;
}
    /* Remove bolinhas e aplica espaçamento no Side Menu */
#sidebar-content ul,
#sidebar-content li {
    list-style: none !important;  /* força remover bullets */
    padding-left: 0 !important;
    margin-left: 0 !important;
}

#sidebar-content ul {
    display: flex;
    flex-direction: column;
    gap: 10px; /* mesmo espaçamento da aba Info */
}
    .sidebar > ul {
    list-style: none;      /* remove bullets */
    padding: 0;            /* elimina recuo padrão */
    margin: 0 0 16px 0;    /* margem inferior opcional */
    display: flex;         /* empilha verticalmente */
    flex-direction: column;
    gap: 10px;             /* espaçamento entre os itens */
}

.sidebar > ul > li {
    margin: 0;             /* garante que não tenha margens extras */
}
    .person-symbols {
    display: flex;
    justify-content: center;
    gap: 6px;
    margin-top: 6px;
}

.symbol-icon {
    width: 40px;
    height: 40px;
    object-fit: contain;
}
    .card-sub{
  font-size: 12px;
  opacity: 0.85;
  margin-top: 2px;
}

/* === LISTA NO Side Menu === */
#charList{
  display: grid;
  grid-template-columns: repeat(2, minmax(50px, 1fr)); /* 2 colunas no menu */
  gap: 10px;
  padding: 0;
  margin: 0;
  list-style: none;
}
/* nova classe para esconder */
#charList.is-hidden { display: none !important; }

/* escalar a imagem ao tamanho da coluna */
#charList .person-card img{
  width: 100%;
  height: auto;          /* mantém proporção */
  display: block;
  border-radius: 8px;
}

/* texto */
#charList .card-name{ margin-top:6px; font-weight:600; text-align:center; }
#charList .card-sub{  font-size:12px; opacity:.85; margin-top:2px; text-align:center; }

/* quando houver mais espaço, aumente o nº de colunas */
@media (min-width: 420px){
  #charList{ grid-template-columns: repeat(3, minmax(50px, 1fr)); }
}
@media (min-width: 560px){
  #charList{ grid-template-columns: repeat(4, minmax(50px, 1fr)); }
}
    #bench-row-wrapper{
  display: flex;
  flex-direction: column;   /* empilha título, slots e toolbar */
  gap: 8px;
}
#bench-row{ order: 1; }
#bench-toolbar{
  order: 2;
  display: flex;
  gap: 10px;
  justify-content: flex-end; /* ou center/space-between */
  margin-top: 45px;
}
/* === ITEMS (Memory + Potential Sets) === */
.item-badge {
  position:absolute; bottom:4px; right:6px;
  background:#111; border:1px solid #666; color:#fff;
  font-size:11px; padding:2px 6px; border-radius:6px; opacity:.9;
  max-width: 90%; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;
}
.item-modal-backdrop{
  position:fixed; inset:0; background:rgba(0,0,0,.6);
  display:flex; align-items:center; justify-content:center; z-index:5000;
}
.item-modal{
  background:#2b2b2b; color:#fff; width:min(640px,92vw);
  border-radius:12px; padding:14px; box-shadow:0 12px 32px rgba(0,0,0,.5);
}
.item-row{ display:grid; grid-template-columns: 140px 1fr; gap:10px; align-items:center; margin:10px 0; }
.item-modal select{
  width:100%; background:#1f1f1f; color:#fff; border:1px solid #555; border-radius:8px; padding:8px;
}
.item-actions{ display:flex; gap:8px; justify-content:flex-end; margin-top:12px; }
.item-btn{
  background:#444; border:1px solid #666; color:#fff;
  padding:8px 10px; border-radius:8px; cursor:pointer;
}
.item-btn:hover{ background:#555; }
.item-stats{
  background:#1e1e1e; border:1px solid #444; border-radius:10px; padding:8px; font-size:13px;
}
.item-stats code{ font-family: ui-monospace, Menlo, Consolas, monospace; }
.item-desc{ opacity:.85; font-size:12px; margin-top:6px; line-height:1.35; }
.hex, .bench-slot { position: relative; } /* ancora do badge/engrenagem */
.item-gear{
  position:absolute; top:4px; right:4px; z-index:5;
  width:22px; height:22px; display:flex; align-items:center; justify-content:center;
  border-radius:999px; background:rgba(20,20,20,.85); border:1px solid #666;
  font-size:14px; cursor:pointer; color:#fff;
}
.item-gear:hover{ background:rgba(40,40,40,.95); }
.item-badge img { width:14px; height:14px; vertical-align:-2px; margin-right:4px; border-radius:3px; }
.item-choice img {
  width:28px; height:28px; border-radius:6px; object-fit:cover;
}
.item-choice.empty { opacity:.6; }
/* Linha no formato: [label] [IMG] [select]  */
.item-row-inline{
  display: grid;
  grid-template-columns: 140px 52px 1fr; /* label | img | select */
  gap: 10px;
  align-items: center;
  margin: 10px 0;
}

/* thumb quadrada */
.item-thumb{
  width: 48px; height: 48px;
  border-radius: 8px;
  background: #2a2a2a;
  object-fit: cover;
  box-shadow: inset 0 0 0 1px #444;
}

/* select estilo “pill” (opcional) */
.item-select{
  width: 100%;
  background:#1f1f1f; color:#fff;
  border:1px solid #555; border-radius:999px;
  padding: 8px 12px;
}

/* descrição fica alinhada sob IMG+select (colunas 2..3) */
.item-subdesc{
  grid-column: 2 / span 2;
  font-size: 12px; opacity: .85; margin-top: 6px;
}
/* --- mais espaço no modal de Items --- */
.item-row-inline{
  display: grid;
  grid-template-columns: 170px 56px 1fr; /* label | IMG | select  (era 140px 52px 1fr) */
  column-gap: 16px;                      /* era 10px */
  row-gap: 8px;
  align-items: start;                    /* evita que label fique baixo */
  margin: 14px 0;                        /* era 10px */
}

/* o texto do rótulo alinhado ao topo da linha (Memory / Potential...) */
.item-row-inline > div:first-child{
  align-self: start;
  padding-top: 4px;
}

/* a miniatura um pouco maior */
.item-thumb{
  width: 150px; height: 150px;             /* se quiser mais: 56x56 */
  border-radius: 8px;
  background: #2a2a2a;
  object-fit: cover;
  box-shadow: inset 0 0 0 1px #444;
}

/* select mais “fofo” e com respiro */
.item-select{
  width: 100%;
  background:#1f1f1f; color:#fff;
  border:1px solid #555; border-radius:999px;
  padding: 10px 14px;                    /* era 8px 12px */
}

/* descrição com mais espaço e alinhada sob IMG+select */
.item-subdesc{
  grid-column: 2 / span 2;               /* ocupa coluna da IMG + select */
  margin-top: 8px;                        /* era 6px */
  font-size: 12px; opacity: .85;
}

/* dá um espaço extra entre os blocos */
.item-modal .item-row-inline + .item-row-inline{
  margin-top: 120px;
}
/* === Grid de 2 colunas no modal === */
.item-modal .items-grid{
  display:grid;
  grid-template-columns: 1fr 1fr;           /* coluna esquerda | direita */
  column-gap: 28px;                          /* espaço entre colunas */
  row-gap: 18px;
  align-items:start;
  margin-top: 6px;
}

/* coluna direita ganha um divisor sutil à esquerda */
.item-modal .items-col + .items-col{ position:relative; }
.item-modal .items-col + .items-col::before{
  content:"";
  position:absolute; left:-14px; top:0; bottom:0; width:1px;
  background: rgba(255,255,255,.08);
}

/* linhas internas no formato: label | IMG | select */
.item-row-inline{
  display:grid;
  grid-template-columns: 150px 56px 1fr;     /* label | img | select */
  column-gap: 16px; row-gap: 8px;
  align-items:center;
  margin: 6px 0;
}
.item-row-inline > div:first-child{          /* o rótulo (Memory / Potential...) */
  align-self:start; padding-top: 6px;
}
.item-thumb{
  width: 75px; height: 75px; border-radius: 10px;
  background:#2a2a2a; object-fit:cover;
  box-shadow: inset 0 0 0 1px #444;
}
.item-select{
  width:100%; background:#1f1f1f; color:#fff;
  border:1px solid #555; border-radius:999px;
  padding:10px 14px;
}
.item-subdesc{
  grid-column: 2 / span 2;                   /* fica alinhado sob IMG+select */
  font-size:12px; opacity:.85; margin-top:8px;
}

/* linha “Stats preview” continua em 2 colunas padrão (label | conteúdo) */
.item-row{
  display:grid; grid-template-columns: 150px 1fr;
  column-gap: 16px; align-items:start; margin: 6px 0;
}
/* --- Badge só com ícones --- */
/* === Badge com ícones que se ajustam ao tamanho === */
.item-badge{
  --icon: 37px;                 /* ajuste aqui o tamanho do ícone (18–28px) */
  display:flex; gap:6px; align-items:center;
  position:absolute; bottom:4px; right:6px;
  background:rgba(0,0,0,.60);
  border:1px solid rgba(255,255,255,.25);
  border-radius:8px; padding:3px 6px; z-index:4;
}

/* cada “slot” de ícone */
.item-badge .ico{
  position:relative;
  width:var(--icon); height:var(--icon);
  border-radius:4px; overflow:hidden;
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.35);
  background:#222;
}

/* a imagem cobre 100% do slot, sem distorcer */
.item-badge .ico img{
  position:absolute; inset:0;
  width:100% !important;
  height:100% !important;
  object-fit:cover;
  display:block;
}

/* etiqueta “M/4/2” (opcional) escala com o tamanho do ícone */
.item-badge .tag{
  position:absolute; right:-2px; bottom:-2px;
  padding:0 2px;
  font-size:calc(var(--icon) * 0.42);
  line-height:1.05;
  background:rgba(0,0,0,.85); color:#fff;
  border:1px solid rgba(255,255,255,.35); border-radius:3px;
}
/* --- Layout 3 colunas: label | IMG | select --- */
.items-3col{ display:grid; row-gap:18px; }

.row-3col{
  display:grid;
  grid-template-columns: 120px 120px 1fr; /* label | img | select */
  column-gap:18px; align-items:center;
}

.row-3col .label{ align-self:center; padding-top:4px; }

.big-thumb{
  width:120px; height:80px;           /* ajuste como preferir */
  border-radius:10px;
  background:#2a2a2a;
  box-shadow:inset 0 0 0 1px #444;
  object-fit:cover;
}

.select-wide{
  width:100%; background:#1f1f1f; color:#fff;
  border:1px solid #555; border-radius:10px;
  padding:10px 12px;
}

.subdesc{ font-size:12px; opacity:.85; margin-top:8px; }

/* Stats em lista vertical */
.stats-list{ list-style:none; margin:0; padding:0; }
.stats-list li{
  margin:6px 0;
  font-family:ui-monospace, Menlo, Consolas, monospace;
  background:#1e1e1e; border:1px solid #444; border-radius:10px;
  padding:6px 10px;
}
.stats-list li b{ margin-right:6px; }
.hex.drop-ok, .bench-slot.drop-ok { outline: 2px dashed #9cf; }
.hex.drop-bad, .bench-slot.drop-bad { outline: 2px dashed #f66; }
/* título + badge lado a lado */
.synergy-header{ display:flex; align-items:baseline; gap:12px; margin-bottom:8px; }
.team-type-badge{ font-size:.95rem; font-weight:600; opacity:.9; }
.multi-teams{ display:flex; align-items:center; gap:10px; margin:10px 0 16px; }
.team-tabs{ display:flex; gap:8px; flex-wrap:wrap; }
.team-tab{
  padding:6px 12px; border-radius:9999px; border:1px solid #444;
  background:#2a2a2a; color:#ddd; cursor:pointer; font-weight:600;
}
.team-tab.active{ background:#3a3a3a; border-color:#666; }
.add-team{
  padding:6px 10px; border-radius:8px; border:1px solid #444;
  background:#2f6; color:#000; font-weight:700; cursor:pointer;
}
.team-tab.editing{ pointer-events:auto; }
.team-tab-edit{
  width:120px; max-width:160px;
  background:transparent; color:inherit;
  border:1px dashed #777; border-radius:9999px;
  padding:4px 8px; outline:none; font:inherit; font-weight:600;
}
.multi-teams, #teamBar {
  display: flex;
  justify-content: center;   /* <— centraliza horizontalmente */
  align-items: center;
  gap: 10px;
  margin: 10px 0 16px;
}
    /* impede scroll no fundo quando o modal está aberto */
body.modal-open {
  overflow: hidden;
}

/* backdrop já é fixed e centraliza; só adiciono padding e contenção de overscroll */
.item-modal-backdrop{
  position:fixed; inset:0;
  background:rgba(0,0,0,.6);           /* alpha válido (antes estava 6) */
  display:flex; align-items:center; justify-content:center;
  padding:16px;                         /* respiro nas bordas em zoom alto */
  overscroll-behavior: contain;         /* evita “vazar” scroll para o body */
  z-index:5000;
}

/* painel do modal com limite de altura e rolagem própria */
.item-modal{
  background:#2b2b2b; color:#fff;
  width:min(640px,92vw);
  border-radius:12px; padding:14px;
  box-shadow:0 12px 32px rgba(0,0,0,.5);

  max-height: calc(100dvh - 32px);      /* cabe na tela */
  overflow: auto;                        /* rola por dentro */
}
/* fallback para navegadores sem dvh */
@supports not (height: 100dvh){
  .item-modal{ max-height: calc(100vh - 32px); }
}

/* barra de botões sempre visível no rodapé do modal */
.item-actions{
  position: sticky;
  bottom: 0;
  background: rgba(43,43,43,.95);
  border-top: 1px solid #444;
  margin-top:12px;
  padding:8px 0;
  display:flex; gap:8px; justify-content:flex-end;
}
.recommend-panel{
  display:flex; flex-direction:column; gap:8px; 
  align-items:center; margin:10px 0 16px;
}
.recommend-panel .row{ display:flex; flex-wrap:wrap; gap:12px; align-items:center; justify-content:center; }
.recommend-panel label{ color:#ddd; font-weight:600; display:flex; gap:6px; align-items:center; }
.recommend-panel input[type="range"]{ width:120px; }
.recommend-panel button{
  padding:6px 12px; border-radius:10px; border:1px solid #444;
  background:#40f06a; color:#000; font-weight:800; cursor:pointer;
}
.recommend-bar{ display:flex; justify-content:center; margin:6px 0 10px; }

.recommend-panel{
  display:none;                     /* oculto por padrão */
  flex-direction:column; gap:8px;
  align-items:center; margin:6px 0 16px;
  padding:10px; border:1px solid #444; border-radius:10px; background:#2a2a2a;
}
.recommend-panel.open{ display:flex; }  /* abre quando adicionamos .open */

.recommend-panel .row{ display:flex; flex-wrap:wrap; gap:12px; align-items:center; justify-content:center; }
.recommend-panel label{ color:#ddd; font-weight:600; display:flex; gap:6px; align-items:center; }
.recommend-panel input[type="range"]{ width:120px; }

.recommend-bar button,
.recommend-panel button{
  padding:6px 12px; border-radius:10px; border:1px solid #444;
  background:#40f06a; color:#000; font-weight:800; cursor:pointer;
}
.type-prefs{ border:1px solid #444; border-radius:8px; padding:6px 10px; }
.type-prefs legend{ padding:0 6px; font-size:.9rem; color:#bbb; }
.type-prefs label{ font-weight:500; }
.banner-img{
  width: 40px; height: 40px; object-fit: contain;
  background:#0003; border-radius:8px; border:1px solid #3a3a3a; display:block;
}
/* collapse da coluna esquerda */
body.planner-collapsed .panel.sources { display:none !important; }
body.planner-collapsed .planner-wrap { grid-template-columns: 1fr !important; }

/* botão compacto */
.btn.mini{ padding:4px 8px; font-size:.85rem; border-radius:7px; }
/* reserva largura para a coluna Sistema */
#tblFree td.col-sistema, #tblFree th.col-sistema { width: 260px; }
#tblCash td.col-sistema, #tblCash th.col-sistema { width: 260px; }

/* inputs de texto com largura mínima e sem cortar texto */
.grid-table input[type="text"]{
  min-width: 240px;      /* garante leitura */
  white-space: nowrap;   /* não quebra no meio */
  text-overflow: clip;   /* sem "..." cortando */
  overflow: visible;
}
/* container por mês */
.month-group{ margin:14px 0 18px; }
.month-title{ font-weight:800; margin:0 0 8px; opacity:.9; }


/* cartão */
.banner-card{
  background:#1e1e1e; border:1px solid #3a3a3a; border-radius:12px; padding:10px;
}
.banner-card h5{ margin:0 0 6px; font-size:.95rem; opacity:.9; }
.banner-card img{ width:160px; height:210px; object-fit:cover; display:block; border-radius:10px; border:1px solid #3a3a3a; }
.banner-fields label{ display:block; font-size:.95rem; margin-top:6px; }
.banner-fields input{ width:100%; background:#1d1d1d; color:#fff; border:1px solid #555; border-radius:8px; padding:6px 8px; }

.rebanner-col{ grid-column: 1 / -1; display:flex; justify-content:center; }
/* Reabrir fontes quando colapsado */
#reopenSources {
  position: fixed; left: 14px; bottom: 18px; z-index: 10000;
  background:#ffd54f; color:#222; border:0; font-weight:800;
  padding:8px 12px; border-radius:10px; cursor:pointer;
  box-shadow:0 3px 0 rgba(0,0,0,.25); display:none;
}
body.planner-collapsed #reopenSources { display:block; }

/* Coluna central de rebanners pode ter 1..N cartões empilhados */
.rebanner-col { grid-column: 1 / -1; display:flex; flex-direction:column; gap:18px; align-items:center; }

/* Linhas informativas (Tickets/Memórias/Cashback) no cartão */
.banner-lines { margin-top:10px; font-weight:700; line-height:1.6; }
.banner-lines span { display:block; }

.banner-card img{ display:block; margin:0 auto; }
body.planner-collapsed .panel.sources{ display:none !important; }
body.planner-collapsed .planner-wrap{ grid-template-columns: 1fr  }

.rebanners-row{ display:flex; gap:18px; justify-content:center; }
/* Alinha o botão à direita no cabeçalho do painel */
#synergy-panel .synergy-header{ justify-content: space-between; }

/* Lista dentro do modal (apresentação dos bonds) */
.stats-bond-list{ background:#2a2a2a; border:1px solid #444; border-radius:10px; padding:10px; }
.stats-bond-item{ margin:10px 0; }
.stats-bond-item h4{ margin:0 0 6px; font-size:1rem; }
.stats-bond-item ul{ margin:0; padding-left:16px; }
.stats-bond-item li{ margin:4px 0; font-family: ui-monospace, Menlo, Consolas, monospace; }
/* --- Stats bonds (modal) --- */
.stats-bond-item ul li{display:flex;align-items:center;gap:8px;margin:6px 0;}
.stats-char-thumb{width:28px;height:28px;border-radius:50%;object-fit:cover;border:1px solid #444}

/* ações no rodapé do modal */
.item-actions{display:flex;gap:8px;justify-content:flex-end;align-items:center}

/* picker de “personagens da conta” */
.owned-picker{display:grid;grid-template-columns:repeat(auto-fill,minmax(150px,1fr));gap:8px;
  max-height:50vh;overflow:auto;margin-top:8px}
.owned-card{display:flex;gap:8px;align-items:center;padding:6px;border:1px solid #555;border-radius:10px}
.owned-card input{margin-left:auto}

/* pills de Stat Bonds no painel lateral */
.pill{display:inline-block;padding:4px 10px;border-radius:14px;border:1px solid #666;
  cursor:pointer;margin:3px 4px;font-size:.95em;background:#222}
.pill:hover{background:#2a2a2a}
.subdesc{opacity:.9;margin-top:8px}
/* Cabeçalho de cada bond + botão See details */
.stats-bond-head{display:flex;justify-content:space-between;align-items:center;gap:8px}
.see-details-btn{font-size:.85em;padding:3px 8px;border:1px solid #666;border-radius:8px;background:#222;cursor:pointer}
.see-details-btn:hover{background:#2a2a2a}

/* Lista de personagens "faltando" (fora do time) */
.missing-char{color:#ff5c5c;font-style:italic}
/* Deixa o planner idêntico aos outros botões do menu */
#sidebar #openPlannerBtn,
#openPlannerBtn.menu-link.bond-btn{
  background-color:#444;
  color:#fff;
  border:1px solid #666;
  border-radius:6px;
  padding:4px 8px;
  font-size:14px;
  cursor:pointer;
  transition:background-color .2s, transform .2s;
  box-shadow:none;
  font-weight:normal;
}
#sidebar #openPlannerBtn:hover{ background-color:#666; transform:scale(1.05); }
#sidebar #openPlannerBtn:active{ background-color:#888; transform:scale(.98); }
/* === Planner em tela cheia === */
#pagePlanner{
  position: fixed;      /* vira um overlay */
  inset: 0;             /* top/right/bottom/left = 0 */
  width: 100vw;
  height: 100vh;
  margin: 0;
  padding: 16px clamp(12px,2vw,24px) 24px;
  background: #121212;  /* use a cor do seu tema, se tiver variável */
  z-index: 999;         /* acima do restante da UI */
  overflow: auto;       /* rolagem interna */
}

/* evita “caixa” estreita por max-width herdado */
#pagePlanner .container,
#pagePlanner .planner-box,
#pagePlanner .planner-wrap,
#pagePlanner .planner-grid{
  max-width: none !important;
  width: 100% !important;
}

/* mantém cabeçalho/toolbar visível enquanto rola o planner */
#pagePlanner .planner-header{
  position: sticky;
  top: 0;
  z-index: 1;
  background: inherit;
  padding-bottom: 8px;
}

/* quando o planner está aberto, trava o scroll do body atrás */
body.planner-open{ overflow: hidden; }
/* ===== Planner: layout em duas colunas ===== */
#pagePlanner .planner-two-col{
  display: grid;
  grid-template-columns: minmax(640px, 1fr) minmax(360px, 30vw);
  gap: 16px;
  align-items: start;
}

/* permite o conteúdo da coluna esquerda encolher corretamente */
#pagePlanner .planner-main{ min-width: 0; }

/* Simulação fixa ao rolar (dentro do overlay fullscreen) */
#pagePlanner .planner-sim{
  position: sticky;
  top: 12px;                 /* ajuste se tiver header fixo maior */
  max-height: calc(100vh - 24px);
  overflow: auto;
  /* aparência opcional */
  background: #1a1a1a;
  border: 1px solid #333;
  border-radius: 12px;
  padding: 12px;
}

/* cards/linhas de mês ocupam toda a largura disponível */
#plannerMonths > *{ width: 100%; }

/* responsivo: empilha em telas menores */
@media (max-width: 1100px){
  #pagePlanner .planner-two-col{
    grid-template-columns: 1fr;
  }
  #pagePlanner .planner-sim{
    position: static;
    max-height: none;
  }
}
.banner-card{
  width: 320px;          /* mesma idea do .rebanner-card */
  margin: 0 auto;        /* centraliza dentro da coluna */
  flex: 0 0 320px;       /* evita “esticar” */
}
@media (max-width: 1200px){
  .banner-card{ width: 280px; } /* opcional, igual aos rebanners menores */
}
/* ===== Modal genérica ===== */
.modal-overlay{
  position: fixed; inset: 0; display: none;
  align-items: center; justify-content: center;
  z-index: 2000;  /* acima do planner */
}
.modal-overlay.open{ display: flex; }
.modal-backdrop{
  position: absolute; inset: 0; background: rgba(0,0,0,.55);
}
.modal-dialog{
  position: relative;
  width: clamp(780px, 80vw, 1100px);
  max-height: 90vh;
  background: #1b1b1b;
  border: 1px solid #333; border-radius: 14px;
  box-shadow: 0 20px 60px rgba(0,0,0,.6);
  overflow: hidden; display: flex; flex-direction: column;
}
.modal-header{
  display: flex; justify-content: space-between; align-items: center;
  padding: 10px 14px; background: #222; border-bottom: 1px solid #333;
  position: sticky; top: 0; z-index: 1;
}
.modal-body{
  padding: 12px; overflow: auto;
  max-height: calc(90vh - 56px);
}

/* trava scroll atrás da modal */
body.modal-open{ overflow: hidden; }

/* quando o painel está dentro da modal, deixe ele ocupar 100% */
.modal-body .panel.sources{ margin: 0; width: 100%; box-sizing: border-box; }
/* Alternador de servidor (JP / CN) */
.server-switch{
  display:flex; gap:8px; justify-content:center; margin:6px 0 12px;
}
.server-btn{
  background:#2a2a2a; color:#ddd; border:1px solid #444;
  padding:6px 12px; border-radius:10px; cursor:pointer; font-weight:700;
}
.server-btn:hover{ background:#333; border-color:#666; color:#fff; }
.server-btn.active{ background:#3a3a3a; border-color:#777; color:#fff; }
/* Grade fluida: cabe 1 ou 2 cards por linha conforme espaço disponible */
.month-row{
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(var(--card-w), 1fr));
  gap: 16px 24px;               /* gap menor ajuda a fechar com a Simulação */
  align-items: start;
}
.rebanner-card{ width: var(--card-w); }
/* Reduz larguras só nos campos do painel de Simulação */
#simPane #simInputs label { display: flex; align-items: center; gap: 10px; }

/* Garante que estes inputs não ocupem 100% da coluna */
#simPane #simInputs input { width: auto; }

/* Larguras finais: número e data */
#simPane #simInputs .planner-input[type="number"] { width: 140px; }   /* Saldo inicial */
#simPane #simInputs .planner-input[type="date"]   { width: 170px; }   /* Data de início */

</style>
</head>
<body>

<button id="menuBtn">☰</button>
<div class="sidebar" id="sidebar">
    <button class="close-btn" id="closeSidebar">×</button>
    <h2>Side Menu</h2>
    <ul>
        <div id="view-stats" style="display:flex;gap:16px;justify-content:center;align-items:center;margin-top:6px;opacity:.95">
  <span>Daily Views: <strong id="visits-today">—</strong></span>
  <span>Total: <strong id="visits-total">—</strong></span>
</div>
        <!-- substituí EStatísticas por Save/Load -->
        <li><button class="menu-link bond-btn" data-section="save">💾 Save & Load Teams</button></li>
        <li><button class="menu-link bond-btn" data-section="characters">🔍 Characters</button></li>
        <li><button class="menu-link bond-btn" data-section="schools">🏫 Schools</button></li>
        <li><button class="menu-link bond-btn" data-section="help">ℹ️ Info</button></li>
        <li><button id="openPlannerBtn" class="menu-link bond-btn">💎 Planejador de Recursos</button></li>
      </ul>
    <div id="sidebar-content">
        <p>Select an option above.</p>
    </div>
</div>

<h1>Haikyu Fly High - Team Builder by Devoy Aces</h1>

<div id="multiTeams" class="multi-teams">
  <div id="teamTabs" class="team-tabs"></div>
  <button id="addTeamBtn" class="add-team" type="button">+ Team</button>
</div>

<div class="team-grid">
    <div class="row top-row">
        <div class="player-slot"><div class="hex" data-role="S"></div><div class="player-info">S</div></div>
        <div class="player-slot"><div class="hex" data-role="MB"></div><div class="player-info">MB</div></div>
        <div class="player-slot"><div class="hex" data-role="WS"></div><div class="player-info">WS</div></div>
    </div>
    <div class="row">
        <div class="player-slot"><div class="hex" data-role="L"></div><div class="player-info">L</div></div>
        <div class="player-slot"><div class="hex" data-role="WS"></div><div class="player-info">WS</div></div>
        <div class="player-slot"><div class="hex" data-role="MB"></div><div class="player-info">MB</div></div>
        <div class="player-slot"><div class="hex" data-role="OP"></div><div class="player-info">OP</div></div>
    </div>

    <!-- linha onde fica o botão SALVAR e os bench slots -->
    <div class="row" id="bench-row-wrapper" style="align-items:center;">

        <div class="row" id="bench-row" style="gap:10px;">
            <div class="player-slot bench"><div class="bench-slot" data-role="bench"></div><div class="player-info">Bench</div></div>
            <div class="player-slot bench"><div class="bench-slot" data-role="bench"></div><div class="player-info">Bench</div></div>
            <div class="player-slot bench"><div class="bench-slot" data-role="bench"></div><div class="player-info">Bench</div></div>
            <button class="add-slot-btn" onclick="addBenchSlot()">+</button>
        </div>
         <div id="bench-toolbar" style="display:flex; align-items:center; gap:10px; margin-top:8px;">
    <button id="rotateBtn" title="Rotate clockwise" style="background-color:#222222;color:white;padding:6px 10px; border:none; border-radius:5px; font-size:16px; cursor:pointer;margin-right:8px;">↻</button>
    <button id="saveTeamBtn" title="Save Team" style="background-color:#222222;margin-right:8px;">⬇️</button>
    <button id="clearTeamBtn" title="Clear Team" style="background-color:#222222; color:white; padding:6px 10px; border:none; border-radius:5px; font-size:16px; cursor:pointer;margin-right:55px;">🗑️</button>
    <button id="recommendBtn" title="Recommend based on highest synergies possible"style="background-color:#222222; color:white; padding:6px 10px; border:none; border-radius:5px; font-size:16px; cursor:pointer;margin-right:55px;">⭐</button>
</div>
    </div>
</div>

<!-- Painel de sliders (inicialmente oculto) -->
<div id="recoPanel" class="recommend-panel">
  <div class="row">
    <label>Sinergias
      <input id="wSynergy" type="range" min="0" max="5" step="0.5" value="3">
      <span id="wSynergyVal">3</span>
    </label>
    <label>Âncora
      <input id="wAnchor" type="range" min="0" max="5" step="0.5" value="1">
      <span id="wAnchorVal">1</span>
    </label>
    <label>Tipo do time
      <input id="wTeamType" type="range" min="0" max="5" step="0.5" value="1.5">
      <span id="wTeamTypeVal">1.5</span>
    </label>
    <label>Stats
      <input id="wStats" type="range" min="0" max="5" step="0.5" value="1">
      <span id="wStatsVal">1</span>
    </label>
  </div>
  <div class="row">
  <label><input id="allowCrossRole" type="checkbox" checked> Permitir cross-role (exceto L)</label>

  <fieldset class="type-prefs">
    <legend>Tipo do time</legend>
    <label><input type="checkbox" id="prefQuick"> Quick</label>
    <label><input type="checkbox" id="prefPower"> Power</label>
    <label><input type="checkbox" id="prefBlock"> Block</label>
    <label><input type="checkbox" id="prefReceive"> Reception</label>
  </fieldset>

  <button id="runRecommendBtn" type="button">Aplicar</button>
  <button id="closeRecoBtn" type="button">Fechar</button>
</div>
</div>

<div class="scroll-menu" id="scrollMenu"></div>

<div id="synergy-panel">
  <div class="synergy-header" style="justify-content:space-between;">
    <h2>Synergies</h2>
    <button id="statsBondBtn" class="btn mini" type="button" title="Mostrar vínculos de stats">
      Stats bonds
    </button>
  </div>
  <ul id="synergy-list">
    <li>Only Deployment Synergies are displayed.Synergies will only work when players are in court inside the game.</li>
  </ul>
</div>
<!-- QR LivePix fixo na esquerda -->
<a href="https://livepix.gg/gondif" target="_blank" rel="noopener" id="livepixQr">
  <img src="https://api.qrserver.com/v1/create-qr-code/?data=https://livepix.gg/gondif&size=120x120" 
       alt="LivePix QR - gondif" />
</a>

<style>
  #livepixQr {
    position: fixed;
    left: 16px;      /* distância da borda esquerda */
    bottom: 16px;    /* fica no canto inferior, sempre visível */
    z-index: 9999;   /* garante que fica por cima de outros elementos */
  }
  #livepixQr img {
    width: 100px;    /* tamanho do QR (ajuste como quiser) */
    height: auto;
    border-radius: 8px; /* opcional: cantos arredondados */
    box-shadow: 0 0 8px rgba(0,0,0,0.5); /* opcional: sombra */
  }
</style>
<script>
/* ====== DADOS (mantidos) ====== */
const characters = [
{ nome: "Kageyama UR", data: "01/12/26", funcao: "S", img: "img/kageyamaUR.png", School: "Karasuno", vinculo: ["Dupla Excêntrica", "Gênios Karasuno"], Stats:{Serve:1782,Spike:1948,Set:1911,Receive:1625,Block:1709,Save:1539}, habilidades:[
  {nome:"Levantador Gênio", descricao:"Kageyama Tobio realiza um levantamento com poder de [Passe] × 120/135/150%. Ao levantar, o [Ataque Rápido] do companheiro que vai atacar é aumentado em [Passe] × 15%. Esse efeito dura até a bola passar para o outro lado da rede."},
  {nome:"Saque Assassino", descricao:"Kageyama Tobio realiza um Saque em Suspensão forte com uma potência de 130/145/160% de seu [Saque]. Se essa jogada for um saque perfeito, a [Técnica de Ataque] de seus colegas de time é aumentada em 10%. Esse efeito dura até a bola cruzar a rede 6 vezes."},
  {nome:"Rei Silencioso", descricao:"Aumenta a [Técnica de Ataque] de Kageyama Tobio em 8/10/12%. Quando ele está na quadra e o Saque, o Ataque Rápido ou a Cortada do oponente for uma boa jogada, Kageyama ganha 1 acúmulo do efeito de [Empenho Competitivo] até 5 acúmulos. Quando ele está na quadra e um aliado saca, faz um Ataque Rápido ou faz uma Cortada, 1 acúmulo do efeito de [Empenho Competitivo] é consumido, e a [Percepção] do jogador executando o Saque, Ataque Rápido ou Cortada é aumentado em 20/25/30%. Esse efeito dura até a bola passar pro outro lado da rede duas vezes. No começo de um rally, Kageyama ganhará um acúmulo do efeito de [Empenho Competitivo]"},
  {nome:"Dominar o Jogo", descricao:"Kageyama Tobio executa um Ataque Rápido com poder equivalente a 240/255/270/285/300% do levantamento. O Ataque Rápido não pode ser bloqueado. O tempo de recarga da habilidade de bloqueio da linha de frente do oponente aumenta em 4× o número de cruzamentos de rede ocorridos."}
], symbols: [ "img/quicksymbol.png", "img/servesymbol.png", "img/settersymbol.png" ] },

{ nome: "Kageyama SSR", funcao: "S", img: "img/kageyamaSR.png", School: "Karasuno", vinculo: [], Stats:{Serve:1314,Spike:1246,Set:1378,Receive:1115,Block:1246,Save:1047}, habilidades:[
  {nome:"SAQUE COMPLICADO", descricao:"TOBIO KAGEYAMA (Treino) realiza um Saque em Suspensão com 120% do atributo Saque como poder."},
  {nome:"OBSERVADOR AFIADO", descricao:"TOBIO KAGEYAMA (Treino) realiza um Levantamento com 115% do atributo Levantamento como poder; para essa jogada, a Força dos atacantes do seu lado aumenta em 10%"},
  {nome:"ASCENSÃO DO CAMPEÃO", descricao:"Enquanto TOBIO KAGEYAMA (Treino) estiver presente, aumenta a Percepção dos jogadores do seu lado em 10% e aumenta a potência da Cortada em 6% dos atributos Ataque Potente/Ataque Rápido do jogador"},
  {nome:"LARGADA SURPRESA", descricao:"TOBIO KAGEYAMA (Treino) realiza uma Largada do Levantador impossível de bloquear com 225% do atributo Passe como poder"}
], symbols: [ "img/quicksymbol.png", "img/servesymbol.png", "img/settersymbol.png" ] },

{ nome: "Hinata SP", data: "01/27/26", funcao: "MB", img: "img/hinataSP.png", School: "Karasuno", vinculo: ["Dupla Excêntrica", "Observação de flores de cerejeira" , "Sol vs Lua"], Stats:{Serve:1673,Spike:1950,Set:1656,Receive:1913,Block:1774,Save:1656}, habilidades:[
  {nome:"Manipular o Momento", descricao:"Quando Hinata Shoyo (Hanami) está em quadra, a [Técnica de Defesa] de todos os jogadores da linha de frente aumenta em 10/13/16%. Quando o resultado da jogada de Hinata Shoyo for Perfeita, sua [Técnica de Ataque] aumenta em 3/3.5/4% com no máximo 4 acúmulos."},
  {nome:"Um Apoio", descricao:"Hinata Shoyo (Hanami) recebe uma bola com 140/160/180% de [Recepção] como poder e os atributos base do seu time aumentam em 12%. Esse efeito dura por 6 cruzamentos de rede."},
  {nome:"Contra-ataque", descricao:"Quando Hinata Shoyo (Hanami) está na linha de trás, a [Técnica de Defesa] dos aliados na linha de trás aumenta em 10/13/16%. Quando ele está em quadra e a recepção do time não for RUIM, seu [Ataque Rápido] aumenta em 12/16/20% pelos próximos dois cruzamentos de rede. Se a recepção do companheiro for Perfeita, o Ataque Rápido de Hinata Shoyo (Hanami) após essa jogada aumenta em 100%."},
  {nome:"Salto Alto", descricao:"Hinata Shoyo (Hanami) realiza um Ataque Rápido com 260/275/290% de [Ataque Rápido] como poder. Se for Perfeita, a potência aumenta em mais 40/45/50% de [Ataque Rápido]."}
], symbols: [ "img/quicksymbol.png", "img/receivesymbol.png" ] },

{ nome: "Hinata SSR", funcao: "MB", img: "img/hinataSR.png", School: "Karasuno", vinculo: ["Dupla Excêntrica"], Stats:{Serve:1173,Spike:1383,Set:1118,Receive:1195,Block:1250,Save:1253}, habilidades:[
  {nome: "O GRANDE CHAMARIZ", descricao:"Enquanto SHOYO HINATA estiver presente, aumenta os atributos Ataque Potente/Ataque Rápido dos jogadores do seu lado em 7%"},
  {nome: "DUO DE ATAQUE RÁPIDO", descricao:"Quando SHOYO HINATA realiza uma Cortada Rápida e o jogador que está passando é do tipo Ataque Rápido, aumenta a potência dessa cortada em 15% do atributo Ataque Rápido do jogador"},
  {nome: "UNO COM A BOLA", descricao:"Aumenta a Percepção de SHOYO HINATA em 6%; quando HINATA realiza uma jogada Superior, aumenta a Percepção em mais 4%, até 1 acúmulos"},
  {nome: "JOVEM ALADO", descricao:"SHOYO HINATA realiza uma Cortada Rápida com 235% do atributo Ataque Rápido como poder; quando essa cortada conquista um resultado Superior, aumenta seu poder em 20% do atributo Ataque Rápido"}
], symbols: [ "img/quicksymbol.png" ] },

{ nome: "Nishinoya SP", data: "03/13/26", funcao: "L", img: "img/nishinoyaSP.png", School: "Karasuno", vinculo: ["Gênios Karasuno", "Depois da Escola"], Stats:{Serve:1615,Spike:1615,Set:1851,Receive:1969,Block:1577,Save:1854}, habilidades:[
  {nome:"Aceleração de Classe Mundial", descricao:"O [Reflexo] de Nishinoya Yu (Depois da Escola) aumenta em 10/13/16%. Quando um membro do time adversário faz uma jogada Perfeita, o [Reflexo] de Nishinoya Yu (Depois da Escola) aumenta em 1.5%, até 10 acúmulos. Dura até a bola cruzar a rede 6 vezes."},
  {nome:"Passe A", descricao:"O [Reflexo] de Nishinoya Yu (Depois da Escola) aumenta em 10/13/16%. Quando um membro do time adversário faz uma jogada Perfeita, o [Reflexo] de Nishinoya Yu (Depois da Escola) aumenta em 1.5%, até 10 acúmulos. Dura até a bola cruzar a rede 6 vezes."},
  {nome:"Salvar o Time na Crise", descricao:"O [Empenho] de Nishinoya Yu (Depois da Escola) aumenta em 20/25/30%. Quando um aliado faz uma jogada Perfeita, o tempo de recarga da Recepção com o Pé é reduzido em um cruzamento de rede."},
  {nome:"Recepção com o Pé", descricao:"Nishinoya Yu (Depois da Escola) executa uma recepção com 260/275/290% de [Recepção] como poder. A [Recepção] dele aumenta em 20%. Dura por dois cruzamentos de rede."}
], symbols: [ "img/receivesymbol.png", "img/settersymbol.png" ] },

{ nome: "Nishinoya SSR", funcao: "L", img: "img/nishinoyaSR.png", School: "Karasuno", vinculo: ["Deus Guardião e Ponta" , "Esquadrão de Kiyoko"], Stats:{ Serve:1131, Spike:1131, Set:1254, Receive:1389, Block:1098, Save:1327 }, habilidades:[
  {nome: "DEUS GUARDIÃO", descricao:"Quando o resultado do teste de resistência de YU NISHINOYA não for RUIM, aumenta o poder da próxima habilidade de Cortada Potente usada pelo seu jogador do tipo Potência em 15% de seu atributo Ataque Potente."},
  {nome: "LÍBERO EXCEPCIONAL", descricao:"YU NISHINOYA realiza uma Defesa com 120% do atributo Defesa como poder"},
  {nome: "REFORÇO DE MORAL", descricao:"Quando YU NISHINOYA entra na quadra, aumenta o Moral do seu lado em 18"},
  {nome: "ROLLING THUNDER", descricao:"YU NISHINOYA consome 20 de Vigor adicional para realizar uma recepção com 220% da potência do atributo Recepção; se o resultado da Recepção não for RUIM, reduz a recarga da próxima habilidade de Cortada Potente do seu lado em 6 cruzamentos de rede"}
], symbols: [ "img/receivesymbol.png" ] },

{ nome: "Tanaka SSR", funcao: "WS", img: "img/tanakaSR.png", School: "Karasuno", vinculo: ["Esquadrão de Kiyoko"], Stats:{ Serve:1190, Spike:1385, Set:1120, Receive:1316, Block:1248, Save:1129 }, habilidades:[
  {nome: "ENTRADA DO ACE", descricao:"Aumenta a potência da 1° Cortada Potente de RYUNOSUKE TANAKA em cada partida em 25% do atributo Ataque Potente"},
  {nome: "ESPÍRITO OBSTINADO", descricao:"RYUNOSUKE TANAKA realiza uma Recepção com 115% do atributo Recepção como poder; para essa Recepção, o Reflexo de TANAKA aumenta em 10%"},
  {nome: "PAIXÃO ARDENTE", descricao:"Aumenta a potência da Cortada Potente de RYUNOSUKE TANAKA em 10% do atributo Ataque Potente; sua Cortada Potente reduz o bloqueio do adversário e o Vigor dos jogadores receptores em 5"},
  {nome: "SUPERCORTADA INTERNA", descricao:"RYUNOSUKE TANAKA consome 5 de Vigor extra para realizar uma Cortada Curta na Diagonal com 250% do atributo Ataque Potente como poder. Se essa for a 1° cortada de TANAKA no set, aumenta a potência da cortada em mais 30% do atributo Ataque Potente de TANAKA"}
], symbols: [ "img/powersymbol.png" ] },

{ nome: "Tsuki SP", funcao: "MB", img: "img/tsukiSP.png", School: "Karasuno", vinculo: ["Sol vs Lua","Festival Fogos de Artificio","Aliados no Campo de Treinamento"], Stats:{Serve:1685,Spike:1968,Set:1669,Receive:1759,Block:1789,Save:1774}, habilidades:[
  {nome:"Grande Cérebro", descricao:"Quando um membro do time adversário estiver sob um efeito desfavorável, a [Percepção] e o [Reflexo] de Tsukishima Kei (Festival de Fogos de Artifício) aumentam em 15/20/25%, e a [Técnica de Ataque] e a [Técnica de Defesa] dos aliados aumentam em 10%. Dura por 1 rali. Quando um aliado ativa uma habilidade de bloqueio, o [Ataque Rápido] de Tsukishima Kei (Festival de Fogos de Artifício) aumenta em 3% (até 10 acúmulos). Quando um aliado ativa uma habilidade de Ataque Rápido, o [Bloqueio] de Tsukishima Kei (Festival de Fogos de Artifício) aumenta em 3% (até 10 acúmulos)."},
  {nome:"Bloqueio é um Sistema", descricao:"Tsukishima Kei (Festival de Fogos de Artifício) bloqueia com poder de [Bloqueio] × 300/325/350%. Aumenta o [Reflexo] dos defensores traseiros aliados em 10% e o [Empenho] em 20%. Dura até a bola cruzar a rede duas vezes."},
  {nome:"Observar Calmamente a Situação", descricao:"No início da partida, se a [Técnica de Ataque] de Tsukishima Kei (Festival de Fogos de Artifício) for ≥ a [Técnica de Defesa], ele recebe o efeito [Ataque I/II/III]; caso contrário, recebe [Defesa I/II/III]. Com [Ataque I/II/III], o tempo de recarga de 'Bloqueio é um Sistema' é reduzido em 4× o número de cruzamentos de rede, mas a potência dessa habilidade é reduzida em [Bloqueio] × 100/80/60%. [Ataque Rápido] é reduzido em 20/30/40."},
  {nome:"Ataques que Aproveitam sua Altura", descricao:"Tsukishima Kei (Festival de Fogos de Artifício) realiza um Ataque Rápido com potência de [Ataque Rápido] × 260%/280%/300%/320%/340%. Se algum oponente tiver efeito desfavorável, a potência desse ataque rápido aumenta em [Ataque Rápido] × 60%."}
], symbols: [ "img/quicksymbol.png", "img/blocksymbol.png" ] },

{ nome: "Tsuki SSR", funcao: "MB", img: "img/tsukiSR.png", School: "Karasuno", vinculo: [], Stats: { Serve:1210, Spike:1314, Set:1153, Receive:1173, Block:1389, Save:1102 }, habilidades:[
  {nome: "COMPOSTURA DO KARASUNO", descricao:"Enquanto KEI TSUKISHIMA estiver presente, aumenta a Força dos jogadores do tipo Ataque Rápido do seu lado em 10%"},
  {nome: "ATAQUE RÁPIDO TÁTICO", descricao:"KEI TSUKISHIMA realiza uma Cortada Rápida com 115% do atributo Ataque Rápido. Quando um jogador do seu lado usar uma habilidade de Cortada, aumenta a Percepção desse jogador em 5%"},
  {nome: "NASCER DA LUA", descricao:"Enquanto KEI TSUKISHIMA estiver presente, aumenta a potência de Bloqueio dos jogadores da linha de ataque do seu lado em 8% do atributo Bloqueio deles"},
  {nome: "RÉPLICA DO KEI", descricao:"KEI TSUKISHIMA realiza um Bloqueio com 195% do atributo Bloqueio como poder; aplica a Penalidade “Provocar” ao atacante adversário (reduz os atributos Ataque Potente/Ataque Rápido em 10%)"}
], symbols: [ "img/quicksymbol.png", "img/blocksymbol.png" ] },

{ nome: "Daichi SSR", funcao: "OP", img: "img/daichiSR.png", School: "Karasuno", vinculo: [], Stats: { Serve:1182, Spike:1250, Set:1123, Receive:1385, Block:1248, Save:1191 }, habilidades:[
  {nome: "RECEPÇÃO SEGURA", descricao:"Quando DAICHI SAWAMURA realiza uma Recepção, restaura 3 de Vigor do jogador com o menor Vigor do seu lado"},
  {nome: "CORTADA MARRETA", descricao:"DAICHI SAWAMURA realiza uma Cortada Potente com 120% do seu atributo Ataque Potente"},
  {nome: "ALICERCE DO TIME", descricao:"Enquanto DAICHI SAWAMURA estiver presente, a potência de Recepção dos jogadores da linha de defesa do seu lado aumenta em 10% do atributo Recepção deles"},
  {nome: "DEFESA CONFIÁVEL", descricao:"DAICHI SAWAMURA realiza uma Recepção com 220% do seu atributo Recepção. Se a próxima Cortada do seu lado for uma Cortada Potente, aumenta a potência dessa cortada em 15% do atributo Ataque Potente do atacante"}
], symbols: [ "img/receivesymbol.png" ] },

{ nome: "Azumane SSR", funcao: "WS", img: "img/azumaneSR.png", School: "Karasuno", vinculo: ["Deus Guardião e Ponta"], Stats: { Serve:1322, Spike:1387, Set:1118, Receive:1254, Block:1190, Save:1122 }, habilidades:[
  {nome: "DEFESA PROFICIENTE", descricao:"ASAHI AZUMANE realiza uma Recepção com 120% do atributo Recepção como poder"},
  {nome: "SAQUE RÁPIDO", descricao:"ASAHI AZUMANE realiza um Saque em Suspensão com 120% do atributo Saque como poder"},
  {nome: "AURA DO ACE", descricao:"Quando o Vigor de ASAHI AZUMANE estiver acima de 70, a potência de sua Cortada Potente aumenta em 15% do atributo Ataque Potente"},
  {nome: "CORTADA CARREGADA", descricao:"ASAHI AZUMANE consome 30 de Vigor adicional para realizar uma Cortada Potente com 235% do atributo Ataque Potente como poder, recebendo 1 acúmulos de “Carga de Poder”; ao usar a habilidade [CORTADA CARREGADA], cada acúmulo de “Carga de Poder” aumenta a potência da Cortada Potente em 50% do atributo Ataque Potente"}
], symbols: [ "img/powersymbol.png", "img/servesymbol.png" ] },

{ nome: "Sugawara SP", data: "04/12/26", funcao: "S", img: "img/sugawaraSP.png", School: "Karasuno", vinculo: ["Depois da Escola"], Stats:{Serve:1849,Spike:1758,Set:1950,Receive:1667,Block:1774,Save:1605}, habilidades:[
  {nome:"Apoiar o Ataque", descricao:"Quando Sugawara Koshi (Depois da Escola) está em quadra e um aliado da linha de frente ativa uma habilidade de bloqueio, o [Bloqueio] do bloqueador aumenta em 5/6.25/7.5% × a soma do [Bloqueio] do outro aliado da linha de frente (máximo 1000/1250/1500). Dura até a bola cruzar a rede duas vezes. Quando ele está em quadra e um aliado da linha de trás recebe, a [Recepção] do recebedor aumenta em 5/6.25/7.5% × a soma da [Recepção] do outro aliado da linha de trás (máx. 1000/1250/1500). Dura até a bola cruzar a rede duas vezes."},
  {nome:"Saque habilidoso que explora fraquezas", descricao:"Sugawara Koushi (Depois da Escola) executa um Saque com poder [Serve] × 140/160/180%. Aumenta a Moral do Time em 10. Aumenta os atributos base dos aliados em 12/14/16% por 1 rali."},
  {nome:"Preparação Cuidadosa", descricao:"Sugawara Koushi (Depois da Escola) aumenta o Vigor em 13/16/20%. Na primeira participação dele, os aliados consomem 50% do Vigor atual deles e, a cada 6 Vigores consumidos, os atributos base dos aliados aumentam em 1%/1.3%/1.6%. Após a primeira participação, os aliados recuperam 15 de Vigor ao fim de cada rali, por 4 ralis."},
  {nome:"Jogada Sinalizada", descricao:"Sugawara Koushi (Depois da Escola) consome 15 de Vigor extra e realiza um levantamento com 60% ([Passe] × 2) / 80% ([Passe] × 2) / 300% / 20% ([Passe] × 3) / 40% ([Passe] × 3) de poder. O primeiro companheiro a atacar (Ataque Potente/Ataque Rápido) após essa jogada aumenta a [Técnica de Ataque] em 2.0% até a bola cruzar a rede duas vezes."}
], symbols: [ "img/blocksymbol.png", "img/servesymbol.png", "img/settersymbol.png" ] },

{ nome: "Kenma SP", data: "02/26/26", funcao: "S", img: "img/kenmaSP.png", School: "Nekoma", vinculo: ["Observação de flores de cerejeira","Cérebro e Comandante SP"], Stats:{Serve:1580,Spike:1700,Set:1990,Receive:1710,Block:1600,Save:1590}, habilidades:[
  {nome:"Liderança", descricao:"Quando Kozume Kenma (Hanami) está em quadra, o [Reflexo] dos aliados aumenta em 10/13/16%. Ao estar em quadra e um aliado receber ou salvar, ele ganha 1 acúmulo de [Defesa que Elimina Aberturas] e o [Reflexo] dos aliados aumenta em 1.5%, até 10 acúmulos. Se o resultado da recepção/defesa do aliado não for RUIM, ganha mais 1 acúmulo."},
  {nome:"Levantamento Sem Movimento Desperdiçado", descricao:"Kozume Kenma (Hanami) realiza um levantamento com 140/160/180% de [Passe] como poder. Se o atacante (Ataque Potente/Ataque Rápido) após essa jogada estiver na linha de trás, o poder do ataque aumenta em 20%."},
  {nome:"Procurar Falhas", descricao:"Quando Kozume Kenma (Hanami) realiza um Passe ou uma Largada, sua [Percepção] aumenta em 40/60/80% de [Reflexo] como poder. Se ele estiver em quadra e o bloqueio do aliado não for RUIM, o poder da Cortada atual do oponente (Ataque Potente/Ataque Rápido) aumenta em 10/13/16% do [Ataque Potente/Ataque Rápido] correspondente (efeito de enfraquecimento para o oponente)."},
  {nome:"Jogada que Confunde o Adversário", descricao:"Kozume Kenma (Hanami) realiza uma Largada com 255/270/285/300/315% de [Passe] como poder. Não pode ser bloqueado. Após essa jogada, quando um oponente realizar a primeira Cortada (Ataque Potente/Ataque Rápido), a [Potência] desse jogador é reduzido em 40% por 2 cruzamentos de rede."}
], symbols: [ "img/receivesymbol.png", "img/settersymbol.png" ] },

{ nome: "Kenma SSR", funcao: "S", img: "img/kenmaSR.png", School: "Nekoma", vinculo: ["Cérebro e Comandante"], Stats:{Serve:1182,Spike:1387,Set:1387,Receive:1122,Block:1303,Save:1060}, habilidades:[
  {nome:"VISÃO DIVINA", descricao:"Enquanto KENMA KOZUME estiver presente, aumenta a potência de Recepção dos jogadores do seu lado em 8% do atributo Recepção deles; quando o resultado do passe de Kozume ou da Recepção do seu lado for PERFEITO, recebe 1 acúmulo do Potencializador [Vôlei de Praia]. Cada acúmulo aumenta o atributo Recepção dos jogadores do seu lado em 3%, até 6 acúmulos"},
  {nome:"LEVANTAMENTO FIRME", descricao:"KENMA KOZUME realiza um Passe com 120% do atributo Passe como poder"},
  {nome:"TIME CORAÇÃO", descricao:"Enquanto KENMA KOZUME estiver presente, aumenta a potência de Recepção dos jogadores do seu lado em 6% do atributo Recepção deles; quando o Potencializador [Vôlei de Praia] exceder 5 acúmulos, aumenta a potência de Recepção dos jogadores do seu lado em 150% do atributo Recepção e Defesa em 150%. Quando o jogador do seu lado falhar em uma Recepção/Defesa, consome 6 acúmulos do [Vôlei de Praia] para mudar o resultado para PERFEITO"},
  {nome:"LARGADA ENGANOSA", descricao:"KENMA KOZUME realiza uma Largada do Levantador impossível de bloquear com 220% do atributo Passe como poder"}
], symbols: [ "img/receivesymbol.png", "img/settersymbol.png" ] },

{ nome: "Yaku SSR", funcao: "L", img: "img/yakuSR.png", School: "Nekoma", vinculo: ["Orientação Educacional"], Stats:{Serve:1131,Spike:1131,Set:1253,Receive:1391,Block:1098,Save:1323}, habilidades:[
  {nome:"MESTRE DA DEFESA", descricao:"Enquanto MORISUKE YAKU estiver presente, quando seu lado realizar uma Recepção que não seja RUIM, aumenta os atributos de Recepção e Defesa de YAKU em 3%, acumulando até 5 vezes"},
  {nome:"ESCUDO CONFIÁVEL", descricao:"Enquanto MORISUKE YAKU estiver presente, aumenta a potência de Cortada Rápida dos jogadores do tipo Ataque Rápido do seu lado em 8% do atributo Ataque Rápido deles"},
  {nome:"LÍBERO DEFINITIVO", descricao:"Aumenta o atributo Recepção de MORISUKE YAKU em 11%; quando o resultado da Recepção de YAKU for NORMAL, muda para PERFEITO"},
  {nome:"RECEPÇÃO CONFIÁVEL", descricao:"MORISUKE YAKU realiza uma Recepção com 240% do atributo Recepção como poder"}
], symbols: [ "img/receivesymbol.png" ] },

{ nome: "Kuroo SSR", funcao: "MB", img: "img/kuroSR.png", School: "Nekoma", vinculo: [], Stats:{Serve:1221,Spike:1318,Set:1149,Receive:1186,Block:1389,Save:1123}, habilidades:[
  {nome:"AURA DO ESPECIALISTA", descricao:"Enquanto TETSURO KUROO (Treino) estiver presente, aumenta a Força dos jogadores do tipo Ataque Rápido do seu lado em 16%"},
  {nome:"ATAQUE FERRENHO", descricao:"TETSURO KUROO (Treino) realiza uma Cortada Rápida com 125% do atributo Ataque Rápido como poder, recebe 1 acúmulo de “Carga de Poder”; ao usar a habilidade [Ataque Ferrenho], cada acúmulo de [Carga de Poder] aumenta a potência da cortada em 15% do atributo Ataque Rápido, até 2 acúmulos"},
  {nome:"TORRE DE CONTROLE DO BLOQUEIO", descricao:"Enquanto TETSURO KUROO (Treino) estiver presente, aumenta o atributo Bloqueio dos jogadores do seu lado em 8%"},
  {nome:"BLOQUEIO TOTAL", descricao:"TETSURO KUROO (Treino) realiza um Bloqueio com 170% do atributo Bloqueio como poder; quando outros jogadores da linha de ataque do tipo Bloqueio estão presentes, aumenta a potência desse bloqueio em 15% do atributo Bloqueio"}
], symbols: [ "img/blocksymbol.png", "img/quicksymbol.png" ] },

{ nome: "Kuroo UR", funcao: "MB", img: "img/kuroUR.png", School: "Nekoma", vinculo: ["Cérebro e Comandante"], Stats:{Serve:1558,Spike:1673,Set:1551,Receive:1581,Block:1740,Save:1533}, habilidades:[
  {nome:"CAPITÃO SUPREMO", descricao:"Aumenta o atributo Ataque Rápido de TETSURO KUROO em 10%; enquanto KUROO estiver presente, cada vez que a bola cruzar a rede, aumenta seus atributos de Bloqueio e Ataque Rápido em 5%, até 5 acúmulos"},
  {nome:"ATAQUE RÁPIDO A", descricao:"TETSURO KUROO realiza uma Cortada Rápida com 125% do atributo  Ataque Rápido como poder; recebe 1 acúmulo de “Carga de Poder”, cada acúmulo de “Carga de Poder” aumenta a potência da Cortada [Ataque Rápido A] em 5% do atributo Ataque Rápido, até 3 acúmulos"},
  {nome:"CONDUTOR", descricao:"Aumenta o atributo Bloqueio de TETSURO KUROO em 14%; quando o resultado de um Bloqueio de KUROO for PERFEITO, aplica a penalidade “Enfurecer” ao atacante adversário (reduz os atributos Ataque Potente/Rápido em 10%)"},
  {nome:"BLOQUEIO REATIVO", descricao:"TETSURO KUROO realiza um Bloqueio com 235% do atributo Bloqueio como poder; quando o jogador adversário que está cortando for afetado por uma penalidade, aumenta o poder desse bloqueio em mais 20% do atributo Bloqueio"}
], symbols: [ "img/quicksymbol.png", "img/blocksymbol.png" ] },

{ nome: "Lev SSR", funcao: "MB", img: "img/levSR.png", School: "Nekoma", vinculo: ["Orientação Educacional"], Stats:{Serve:1206,Spike:1318,Set:1138,Receive:1166,Block:1378,Save:1100}, habilidades:[
  {nome:"MUDANÇA TÁTICA", descricao:"Enquanto LEV HAIBA estiver presente, e quando o seu lado conseguir uma recepção PERFEITA, aumenta a potência da próxima Cortada Rápida dele em 15% do atributo Ataque Rápido"},
  {nome:"BLOQUEIO DE MOMENTUM", descricao:"LEV HAIBA realiza um Bloqueio com 105% do atributo Bloqueio como poder"},
  {nome:"ATLETISMO NATURAL", descricao:"Quando LEV HAIBA realiza uma Cortada Rápida e o jogador adversário que está bloqueando tem uma penalidade, reduz a potência de bloqueio dele em 10% do atributo Bloqueio do jogador que está bloqueando"},
  {nome:"CORTADA TALENTOSA", descricao:"LEV HAIBA realiza uma Cortada Rápida com 245% do atributo Ataque Rápido como poder"}
], symbols: [ "img/quicksymbol.png", "img/blocksymbol.png" ] },

{ nome: "Aone SP", data: "06/18/26", funcao: "MB", img: "img/aoneSP.png", School: "Dateko", vinculo: ["Natação","Parede de Ferro"], Stats:{Serve:1848,Spike:1788,Set:1754,Receive:1667,Block:1904,Save:1605}, habilidades:[
  {nome:"Parede Poderosa", descricao:"O [Reflexo] de Aone Takanobu (Garotos da Praia) aumenta em 10/13/16%. Se o Vigor dele for menor que 80, seus [Bloqueio] e [Saque] aumentam em 10%. Ao bloquear, se o resultado for bloqueio duplo ou triplo, para cada membro bloqueador com habilidade de bloqueio, o poder do bloqueio aumenta em 20% do [Bloqueio] de Aone Takanobu (Garotos da Praia)."},
  {nome:"Saque em Suspensão que Motiva o Time", descricao:"Aone Takanobu (Garotos da Praia) realiza um Saque em Suspensão com 140/160/180% de [Saque] como poder. O tempo de recarga da habilidade do levantador oponente aumenta em 4× o número de cruzamentos de rede. Ao sair da quadra, se Aone ativou o [Saque em Suspensão que Motiva o Time] durante a partida, a [Técnica de Ataque] e a [Técnica de Defesa] dos seus jogadores aumentam em 5%. Se os acúmulos de [Bloqueio Rígido] forem 3 ou mais, aumentam em mais 5%. Dura até a próxima partida de Aone. (Cada acúmulo de [Bloqueio Rígido] concede +10% de [Reflexo], máx. 20)."},
  {nome:"Paredes Fortes e Altas", descricao:"Quando Aone Takanobu (Garotos da Praia) está em quadra, cada vez que um oponente faz um ataque (Ataque Potente/Rápido), o atacante ganha 1 acúmulo de [Trancado]. No início da partida, todos os oponentes ganham 1 acúmulo de [Trancado]. Se o Aone Takanobu (Garotos da Praia) estiver na quadra e um oponente tiver 2 acúmulos de [Trancado], esse oponente irá consumir todos os acúmulos de [Trancado] dele, e o Aone Takanobu (Garotos da Praia) ganha [Bloqueio Rígido]. Com mais de 2 acúmulos de [Bloqueio Rígido], o [Bloqueio] dele aumenta em 10% de [Bloqueio] como poder. Com mais de 4 acúmulos de [Bloqueio Rígido], o tempo de recarga de [Bloqueio Afiado e Conduzido] cai para 8 cruzamentos de rede (12 → 8). Com mais de 6 acúmulos de [Bloqueio Rígido], o [Empenho] dele aumenta em 10%. Com mais de 8 acúmulos de [Bloqueio Rígido], o tempo de recarga de [Bloqueio Afiado e Conduzido] cai para 4 cruzamentos de rede (8 → 4)."},
  {nome:"Bloqueio Afiado e Conduzido", descricao:"Aone Takanobu (Garotos da Praia) bloqueia com 260/275/290/305/320% do [Bloqueio]. Aumenta a Moral do Time em 15."}
], symbols: [ "img/blocksymbol.png", "img/servesymbol.png" ] },

{ nome: "Aone SSR", funcao: "MB", img: "img/aoneSR.png", School: "Dateko", vinculo: ["O Silencioso e o Sarcástico"], Stats:{Serve:1219,Spike:1316,Set:1146,Receive:1173,Block:1389,Save:1102}, habilidades:[
  {nome:"ACE DE BARREIRA", descricao:"Quando o resultado de um Bloqueio de TAKANOBU AONE for PERFEITO, marca o atacante adversário, reduzindo a potência da próxima cortada dele em 10% dos atributos Ataque Potente/Ataque Rápido e aumentando o consumo de Vigor dele em 30%"},
  {nome:"ATAQUE FORTE", descricao:"TAKANOBU AONE realiza uma Cortada Rápida com 120% do atributo Ataque Rápido como poder"},
  {nome:"COBERTURA DE BLOQUEIO TOTAL", descricao:"Quando TAKANOBU AONE bloqueia, para cada jogador do tipo Bloqueio do seu lado (1), aumenta a potência do Bloqueio em 1% do atributo Bloqueio; quando toda a linha de ataque (3 jogador(es)) for do tipo Bloqueio, aumenta a potência do Bloqueio em mais 4% do atributo Bloqueio"},
  {nome:"PILAR DE FERRO", descricao:"TAKANOBU AONE realiza um Bloqueio com 195% do atributo Bloqueio como poder; ao bloquear a Cortada Potente de um adversário, aumenta a potência desse bloqueio em mais 9% do atributo Bloqueio"}
], symbols: [ "img/quicksymbol.png", "img/blocksymbol.png" ] },

{ nome: "Futakuchi SSR", funcao: "WS", img: "img/futakuchiSR.png", School: "Dateko", vinculo: ["O Silencioso e o Sarcástico" , "O Novo Capitão e o Novato Altão","Parede de Ferro"], Stats:{Serve:1217,Spike:1316,Set:1147,Receive:1184,Block:1385,Save:1122}, habilidades:[
  {nome:"AUTORIDADE DO CAPITÃO", descricao:"Enquanto KENJI FUTAKUCHI estiver presente, aumenta a potência do Bloqueio do seu lado em 8% do atributo Bloqueio de cada jogador"},
  {nome:"INÍCIO DE ATAQUE", descricao:"KENJI FUTAKUCHI realiza um Saque em Suspensão com 120% do atributo Saque como poder"},
  {nome:"DEFESA CRESCENTE", descricao:"Enquanto KENJI FUTAKUCHI estiver presente, para cada jogador do tipo Bloqueio do seu lado (1), aumenta a potência do Bloqueio em 0.5% do atributo Bloqueio"},
  {nome:"MURALHA DE FERRO INDESTRUTÍVEL", descricao:"KENJI FUTAKUCHI realiza um Bloqueio com 195% do atributo Bloqueio como poder; quando o jogador adversário que está cortando for afetado por uma penalidade, aumenta o poder desse bloqueio em mais 10% do atributo Bloqueio"}
], symbols: [ "img/blocksymbol.png", "img/servesymbol.png" ] },

{ nome: "Sasaya SSR", funcao: "OP", img: "img/sasayaSR.png", School: "Dateko", vinculo: [], Stats:{Serve:1184,Spike:1378,Set:1120,Receive:1314,Block:1255,Save:1127}, habilidades:[
  {nome:"RESPOSTA CALMA", descricao:"Aumenta a Percepção de TAKEHITO SASAYA em 5%; enquanto SASAYA estiver presente, aumenta o Reflexo dos jogadores do seu lado em 5%"},
  {nome:"DEFESA IMPENETRÁVEL", descricao:"TAKEHITO SASAYA realiza um Bloqueio com 105% do atributo Bloqueio como poder"},
  {nome:"MURALHA DE FERRO FORTIFICADA", descricao:"Enquanto TAKEHITO SASAYA estiver presente, quando seu lado estiver perdendo, aumenta a potência da habilidade de Bloqueio do seu lado em mais 3% do atributo Bloqueio de cada jogador que estiver bloqueando e aumenta o Reflexo desses jogadores em 5%"},
  {nome:"JOGADA AGRESSIVA", descricao:"TAKEHITO SASAYA realiza uma Cortada Potente com 240% do atributo Ataque Potente como poder"}
], symbols: [ "img/powersymbol.png" ] },

{ nome: "Koganegawa SSR", funcao: "S", img: "img/koganegawaSR.png", School: "Dateko", vinculo: ["O Novo Capitão e o Novato Altão"], Stats:{Serve:1166,Spike:1302,Set:1365,Receive:1100,Block:1306,Save:1031}, habilidades:[
  {nome: "LEVANTADOR NOVATO", descricao: "KANJI KOGANEGAWA realiza um Passe com 120% do atributo Passe como poder"},
  {nome: "FAÍSCA DE BLOQUEIO", descricao: "KANJI KOGANEGAWA realiza um Bloqueio com 105% do atributo Bloqueio como poder; enquanto KANJI KOGANEGAWA estiver presente, ao bloquear a Cortada Potente de um adversário, aumenta a potência de Bloqueio do seu lado em 3% do atributo Bloqueio de cada jogador que estiver bloqueando"},
  {nome: "MURALHA DE FERRO III", descricao: "Enquanto KANJI KOGANEGAWA estiver presente, aumenta a potência da habilidade de Bloqueio dos outros jogadores do seu lado em 2% do atributo Bloqueio de cada jogador que estiver bloqueando"},
  {nome: "LARGADA RELÂMPAGO", descricao: "KANJI KOGANEGAWA realiza uma Largada do Levantador impossível de bloquear com 210% do atributo Passe como poder"}
], symbols: [ "img/blocksymbol.png", "img/settersymbol.png" ] }, 

{ nome: "Oikawa UR", data: "09/14/25", funcao: "S", img: "img/oikawaUR.png", School: "Aoba Johsai", vinculo: ["Harmonia Perfeita"], Stats:{Serve:1705,Spike:1533,Set:1627,Receive:1378,Block:1530,Save:1290}, habilidades:[
  {nome:"LEVANTAMENTO DO GRANDE REI", descricao:"TORU OIKAWA realiza um Passe com 120% do atributo Passe como poder; quando os jogadores do seu lado conseguem uma Cortada Superior, eles recebem 1 acúmulo de “Tempo do Ataque”. Cada acúmulo aumenta a Percepção dos jogadores do seu lado em 1%, até 10 acúmulos"},
  {nome:"LARGADA DO GRANDE REI", descricao:"TORU OIKAWA realiza uma Largada do Levantador impossível de bloquear com 115% do atributo Passe como poder; enquanto OIKAWA estiver presente, aumenta a Força dos jogadores do tipo Potente do seu lado em 20%"},
  {nome:"LÍDER DA QUADRA", descricao:"Enquanto TORU OIKAWA estiver presente, aumenta a Percepção dos jogadores do seu lado em 10%; quando o jogador do seu lado usar uma habilidade de Cortada Potente, consome 6 acúmulos do Potencializador [Tempo do Ataque] para garantir um resultado Superior para essa cortada"},
  {nome:"SAQUE EM SUSPENSÃO DO GRANDE REI", descricao:"TORU OIKAWA realiza um Saque em Suspensão Potente com 260% do atributo Saque como poder; para esse Saque, a Percepção de OIKAWA aumenta em 20% e a Força aumenta em 20%"}
], symbols: [ "img/powersymbol.png", "img/servesymbol.png", "img/settersymbol.png" ] },

{ nome: "Oikawa SSR", funcao: "S", img: "img/oikawaSR.png", School: "Aoba Johsai", vinculo: [], Stats:{Serve:1391,Spike:1327,Set:1327,Receive:1125,Block:1248,Save:1054}, habilidades:[
  {nome:"VISÃO DA QUADRA", descricao:"Aumenta o atributo Passe de TORU OIKAWA (Treino) em 10%; quando o jogador do seu lado usa uma habilidade de Cortada, recebe 1 acúmulo do Potencializador [Tempo do Ataque], cada acúmulo do Potencializador [Tempo do Ataque] aumenta a Percepção dos jogadores do seu lado em 1%, até 10 acúmulos"},
  {nome:"MUDANÇA DE JOGO", descricao:"Enquanto TORU OIKAWA (Treino) estiver presente, no início de cada turno, quando seu lado estiver perdendo, aumenta todos os atributos básicos dos jogadores do seu lado em 6%, com duração de 8 cruzamentos de rede"},
  {nome:"TORRE DE COMANDO", descricao:"Enquanto TORU OIKAWA (Treino) estiver presente, aumenta a Percepção dos jogadores do seu lado em 6%; cada acúmulo do Potencializador [Tempo do Ataque] proporciona um aumento adicional de 1% na Percepção dos jogadores do seu lado"},
  {nome:"SAQUE DUPLO SENTIDO", descricao:"TORU OIKAWA (Treino) realiza um Saque em Suspensão Potente com 240% do atributo Saque como poder; para esse Saque, a Percepção de OIKAWA (Treino) aumenta em 15%, esse Saque tem uma chance fixa de 5% de falhar"}
], symbols: [ "img/powersymbol.png", "img/servesymbol.png", "img/settersymbol.png" ] },

{ nome: "Iwaizumi SSR", funcao: "WS", img: "img/iwazumiSR.png", School: "Aoba Johsai", vinculo: ["Harmonia Perfeita", "A Matilha"], Stats:{Serve:1190,Spike:1385,Set:1118,Receive:1314,Block:1248,Save:1129}, habilidades:[
  {nome:"FORÇA DO ACE", descricao:"Aumenta a Percepção de HAJIME IWAIZUMI em 5% e a Força em 10%"},
  {nome:"DEFESA FOCADA", descricao:"HAJIME IWAIZUMI realiza uma Recepção com 120% do atributo Recepção como poder"},
  {nome:"APOIO DO VICE-CAPITÃO", descricao:"Enquanto HAJIME IWAIZUMI estiver presente, aumenta a Força dos jogadores do seu lado em 6%"},
  {nome:"MANO A MANO", descricao:"HAJIME IWAIZUMI realiza uma Cortada Potente com 240% do atributo Ataque Potente como poder; quando essa cortada conquistar um resultado Superior, aumenta sua potência em 15% do atributo Ataque Potente"}
], symbols: [ "img/powersymbol.png" ] },

{ nome: "Kentaro MAD DOG SSR", funcao: "OP", img: "img/kentaroSR.png", School: "Aoba Johsai", vinculo: ["A Matilha"], Stats:{Serve:1320,Spike:1383,Set:1106,Receive:1235,Block:1179,Save:1109}, habilidades:[
  {nome:"ATAQUE FEROZ", descricao:"Aumenta a Percepção de KENTARO KYOTANI em 8% e o atributo Ataque Potente em 5%"},
  {nome:"SAQUE CACHORRO LOUCO", descricao:"KENTARO KYOTANI realiza um Saque com 130% do atributo Saque como poder; para esse Saque, a Percepção aumenta em 15%, com uma chance fixa de 10% de falhar"},
  {nome:"EXPLOSÃO DE FORÇA", descricao:"Aumenta a Força de KENTARO KYOTANI em 18%"},
  {nome:"PRESA DO CACHORRO LOUCO", descricao:"KENTARO KYOTANI realiza uma Cortada Potente com 210% do atributo Ataque Potente como poder, reduzindo o bloqueio do adversário e o Vigor dos jogadores receptores em 10"}
], symbols: [ "img/powersymbol.png", "img/servesymbol.png" ] },

{ nome: "Ushijima UR", funcao: "OP", img: "img/ushijimaUR.png", School: "Shiratorizawa", vinculo: ["Bests para a vida", "Campeão Absoluto e Levantador Sólido"], Stats:{Serve:1499,Spike:1574,Set:1261,Receive:1417,Block:1345,Save:1261}, habilidades:[
  {nome:"NO RITMO", descricao:"Aumenta a Percepção de WAKATOSHI USHIJIMA em 8%; enquanto USHIJIMA estiver presente, no encerramento de cada turno, aumenta a Percepção dele em 3%"},
  {nome:"SAQUE DOMINADOR", descricao:"WAKATOSHI USHIJIMA realiza um Saque em Suspensão com 125% do atributo Saque como poder; quando esse saque se torna Superior, os jogadores receptores não podem usar habilidades; ao marcar um Ace, reduz a recarga do SAQUE DOMINADOR em 4 cruzamentos de rede"},
  {nome:"ESTILO ACE", descricao:"Quando os jogadores do seu lado realizam jogadas Superiores, aumenta os Atributos Básicos de WAKATOSHI USHIJIMA em 1.5%, acumulando até 8 vezes; quando USHIJIMA marca, remove todos os efeitos de penalidade dele"},
  {nome:"ACE INCONTESTÁVEL", descricao:"WAKATOSHI USHIJIMA realiza uma Cortada Potente com 250% do atributo Ataque Potente como poder; quando USHIJIMA realiza um desempenho Superior, reduz a recarga de [ACE INCONTESTÁVEL] em 1 cruzamento de rede"}
], symbols: [ "img/powersymbol.png", "img/servesymbol.png" ] },

{ nome: "Tendo SSR", funcao: "MB", img: "img/tendoSR.png", School: "Shiratorizawa", vinculo: ["Bests para a vida"], Stats:{Serve:1214,Spike:1314,Set:1140,Receive:1177,Block:1387,Save:1100}, habilidades:[
  {nome:"MAVERICK", descricao:"Aumenta o Reflexo de SATORI TENDO em 12%"},
  {nome:"ATAQUE RÁPIDO SURPRESA", descricao:"SATORI TENDO realiza uma Cortada Rápida com 120% do atributo Ataque Rápido como poder"},
  {nome:"BLOQUEIO DE JOGO MENTAL", descricao:"Quando SATORI TENDO realiza um Bloqueio Superior, a recarga do INSTINTO SELVAGEM é reduzida em 1 cruzamento de rede"},
  {nome:"INSTINTO SELVAGEM", descricao:"SATORI TENDO realiza um Bloqueio com 220% do atributo Bloqueio como poder; ao bloquear a Cortada Superior de um adversário, aumenta o Reflexo de TENDO em 15% para esse bloqueio"}
], symbols: [ "img/blocksymbol.png" ] },

{ nome: "Goshiki SSR", funcao: "WS", img: "img/goshikiSR.png", School: "Shiratorizawa", vinculo: ["WS de Shiratorizawa"], Stats:{Serve:1188,Spike:1383,Set:1115,Receive:1314,Block:1240,Save:1122}, habilidades:[
  {nome:"ATENDENDO ÀS EXPECTATIVAS", descricao:"Quando TSUTOMU GOSHIKI marca, aumenta o Moral do seu lado em 8"},
  {nome:"RECEPÇÃO SIMPLES", descricao:"TSUTOMU GOSHIKI realiza uma Recepção com 120% do atributo Recepção como poder"},
  {nome:"FUTURO ACE", descricao:"No encerramento de cada turno, TSUTOMU GOSHIKI recebe 1 acúmulo do potencializador [Afiado]; cada acúmulo de [Afiado] aumenta o atributo Ataque Potente em 2.5%, até 5 acúmulos"},
  {nome:"FAZEDOR DE MILAGRES", descricao:"TSUTOMU GOSHIKI realiza uma Cortada Potente com 225% do atributo Ataque Potente como poder; para essa Cortada Potente, a Percepção de GOSHIKI aumenta em 10%"}
], symbols: [ "img/powersymbol.png", "img/servesymbol.png" ] },

{ nome: "Shirabu SSR", funcao: "S", img: "img/shirabuSR.png", School: "Shiratorizawa", vinculo: ["Campeão Absoluto e Levantador Sólido"], Stats:{Serve:1303,Spike:1382,Set:1242,Receive:1118,Block:1239,Save:1041}, habilidades:[
  {nome:"INABALÁVEL", descricao:"Aumenta o atributo Passe de KENJIRO SHIRABU em 10%; quando SHIRABU passa para um atacante com a característica Ataque Potente, aumenta a potência dessa Cortada Potente em 8% do atributo Ataque Potente do atacante"},
  {nome:"LARGADA CALCULADA", descricao:"KENJIRO SHIRABU realiza uma Largada do Levantador impossível de bloquear com 120% do atributo Passe como poder"},
  {nome:"HABILIDADES DE AJUSTE", descricao:"Aumenta a Percepção de KENJIRO SHIRABU em 9%"},
  {nome:"ATIVANDO O ACE", descricao:"KENJIRO SHIRABU realiza um Passe com 210% do atributo Passe como poder; para esse Passe, a Percepção de SHIRABU aumenta em 10%"}
], symbols: [ "img/powersymbol.png", "img/settersymbol.png" ] },

{ nome: "Semi SSR", funcao: "S", img: "img/semiSR.png", School: "Shiratorizawa", vinculo: [], Stats:{Serve:1476,Spike:1329,Set:1406,Receive:1184,Block:1329,Save:1111}, habilidades:[
  {nome:"POSSE DE BOLA", descricao:"Quando EITA SEMI saca, reduz a potência de recepção dos jogadores da linha de defesa do adversário em 13% do atributo Recepção deles, durando 4 cruzamentos de rede"},
  {nome:"LEVANTAMENTO ENGANOSO", descricao:"EITA SEMI realiza um Passe com 120% do atributo Passe como poder"},
  {nome:"DESEMPENHO PREMIUM", descricao:"Ao sacar, aumenta a Percepção de EITA SEMI em 5% e a Força em 10%"},
  {nome:"SAQUE INSPIRADOR", descricao:"EITA SEMI realiza um Saque em Suspensão com 220% do atributo Saque como poder; ao marcar um Ace, aumenta a Percepção em 3% e o Reflexo em 6% para os jogadores do seu lado"}
], symbols: [ "img/powersymbol.png", "img/servesymbol.png", "img/settersymbol.png" ] },

{ nome: "Ohira SSR", funcao: "WS", img: "img/ohiraSR.png", School: "Shiratorizawa", vinculo: ["WS de Shiratorizawa"], Stats:{Serve:1272,Spike:1477,Set:1188,Receive:1399,Block:1332,Save:1197}, habilidades:[
  {nome:"DEFESA POTENTE", descricao:"Quando REON OHIRA recebe a Cortada Rápida Superior de um adversário, aumenta a potência de recepção em 40% do atributo Recepção de OHIRA"},
  {nome:"DEFESA DE PONTO DE VIRADA", descricao:"REON OHIRA realiza uma Recepção com 120% do atributo Recepção como poder"},
  {nome:"BENKEI BENEVOLENTE", descricao:"Aumenta a Percepção de REON OHIRA em 5% e o Reflexo em 10%"},
  {nome:"CORTADA DEVASTADORA", descricao:"REON OHIRA realiza uma Cortada Potente com 240% do atributo Ataque Potente como poder"}
], symbols: [ "img/receivesymbol.png" ] },

/* ==missing Stats== */{ nome: "Yamagata SSR", funcao: "L", img: "img/yamagataSR.png", School: "Shiratorizawa", vinculo: [], Stats:{Serve:1,Spike:1,Set:1,Receive:1,Block:1,Save:1}, habilidades:[
  {nome:"DESEMPENHO ESTÁVEL", descricao:"Aumenta o Reflexo de HAYATO YAMAGATA em 13%"},
  {nome:"DEFESA AMPLA", descricao:"HAYATO YAMAGATA realiza uma Defesa com 120% do atributo Defesa como poder"},
  {nome:"REFLEXOS RÁPIDOS", descricao:"Quando o adversário consegue um bloqueio PERFEITO, aumenta a potência de Defesa de HAYATO YAMAGATA em 40% de seu atributo Defesa"},
  {nome:"RECEPÇÃO SÓLIDA", descricao:"HAYATO YAMAGATA realiza uma Recepção com 235% do atributo Recepção como poder"}
], symbols: [ "img/receivesymbol.png" ] },

{ nome: "Bokuto UR", data: "08/30/25", funcao: "WS", img: "img/bokutoUR.png", School: "Fukurodani", vinculo: ["Ás Milagroso e Levantador Carinhoso"], Stats:{Serve:1495,Spike:1572,Set:1262,Receive:1417,Block:1347,Save:1268}, habilidades:[
  {nome:"MOTOR DO HYPE", descricao:"Quando KOTARO BOKUTO entra na quadra, aumenta o Moral do seu time em 20. Enquanto ele estiver na quadra, cada toque dos seus jogadores aumenta o Moral em 4. O efeito Reforço de Moral do Time se torna: todos os jogadores têm os Atributos Básicos aumentados em 32% com duração de 4 toques do seu time"},
  {nome:"GRANDE SACADOR", descricao:"KOTARO BOKUTO realiza um Saque em Suspensão com 125% do atributo Saque dele como poder"},
  {nome:"MUDANÇA DE HUMOR", descricao:"No estado [Empolgado], o Ataque Potente de KOTARO BOKUTO aumenta em 12% e a Força em 18%. Em [Desanimado], ele não pode usar habilidades de Cortada. BOKUTO entra em [Empolgado] quando seu time entra em [Reforço de Moral do Time], e entra em [Desanimado] quando isso termina. Ao fim de cada turno, ele sai de [Desanimado]"},
  {nome:"ACE FORMADO PELO TIME", descricao:"KOTARO BOKUTO realiza uma Cortada Potente com 260% de seu atributo Ataque Potente. Se essa Cortada for Superior, sua Força aumenta em 12% e o Moral do seu time aumenta em 16"}
], symbols: [ "img/powersymbol.png", "img/servesymbol.png" ] },

{ nome: "Bokuto SP", data: "05/12/26", funcao: "WS", img: "img/bokutoSP.png", School: "Fukurodani", vinculo: ["Natação", "Ace Milagroso e Levantador Carinhoso"], Stats:{Serve:1673, Spike:1950, Set:1574, Receive:1856, Block:1760, Save:1572}, habilidades:[
  {nome:"Animar", descricao:"O [Ataque Potente] de Kotaro Bokuto (Garotos da Praia) aumenta em 13/16/19%. Quando ele está em quadra, os efeitos de aumento de Moral para aliados, exceto 'Encorajar', são reduzidos em 100%; a cada 10 de Moral reduzida, o jogador ganha 1 acúmulo de 'Unidos'. Por acúmulo, os atributos básicos dos aliados aumentam em 0.16%, até 199 acúmulos."},
  {nome:"Participação Defensiva", descricao:"Kotaro Bokuto (Garotos da Praia) recebe com [Recepção] × 140/160/180% de poder. Ganha 3 acúmulos de [Unidos]."},
  {nome:"Sempre Animado!", descricao:"Se estiver com [Melhor Condição], quando Kotaro Bokuto (Garotos da Praia) ativa o Superior, seu [Ataque Potente] aumenta em 1% por acúmulo de [Unidos] (máx. +70%) até a bola cruzar a rede duas vezes. Além disso, por acúmulo de [Unidos], o poder do seu Ataque Potente aumenta em [Ataque Potente] × 1.5% (máx. +120%) até a bola cruzar a rede duas vezes. Após o Superior, ele ganha [Altos e Baixos]."},
  {nome:"Cortada Milagrosa", descricao:"Kotaro Bokuto (Garotos da Praia) realiza uma Cortada com 260/280/300/320/340% do [Ataque Potente]. Para cada acúmulo de [Unidos], a [Técnica de Ataque] dele aumenta em 0.75%, até 30%, até a bola cruzar a rede duas vezes."}
], symbols: [ "img/powersymbol.png", "img/receivesymbol.png" ] },

{ nome: "Akaashi SP", data: "06/11/26", funcao: "S", img: "img/akaashiSP.png", School: "Fukurodani", vinculo: ["Natação", "Ace Milagroso e Levantador Carinhoso"], Stats:{Serve:1848, Spike:1754, Set:1949, Receive:1581, Block:1758, Save:1489}, habilidades:[
  {nome: "Organizador de time", descricao:"O [Saque] do Akaashi Kyoji (Garotos da Praia) aumenta em 13/15/18%. Quando a moral do time de um aliado sobe, o Akaashi Kyoji (Garotos da Praia) ganha 1 acúmulo do efeito [Mente Tranquila] a cada 10 pontos de moral. Cada acúmulo de [Mente Tranquila] aumenta o [Levantamento] dele em 1,5%, até 10 acúmulos. Enquanto o Despertar da Moral do Time não estiver ativo, todos os acúmulos de [Mente Tranquila] são consumidos quando o Akaashi Kyoji (Beach Boy) toca na bola. Cada vez que um acúmulo de [Mente Tranquila] é consumido, o [Empenho] do Akaashi Kyoji (Garotos da Praia) aumenta em 3%, chegando a no máximo 30%. Esse efeito dura por 2 passagens pela rede."}, {nome: "Aproveitamento Maximo", descricao:"Keiji Akaashi (Garotos da Praia) executa um Levantamento com poder de 140/155/170% do seu [Levantamento]. Depois dessa jogada, na próxima vez que ele ativar o Superior, o [Levantamento] dele aumenta em 15%. Esse efeito dura por 2 passagens pela rede."}, {nome: "Atacar", descricao:"Enquanto um aliado estiver com o Despertar da Moral do Time ativo, quando o Keiji Akaashi (Garotos da Praia) tocar na bola, 5 acúmulos de [Mente Tranquila] são consumidos e o [Empenho] dele aumenta em 70%. Esse efeito dura por 2 passagens pela rede.Se o levantamento do Keiji Akaashi (Garotos da Praia) for um Acerto Crítico, a [Percepção] do primeiro jogador a cortar (Ataque Potente/Ataque Rápido) depois dessa jogada aumenta em 50% da [Percepção] do Keiji Akaashi (Garotos da Praia), até no máximo 60%.Se essa cortada for um Ataque Potente, a [Percepção] de quem realizou a cortada recebe mais 50% da [Percepção] do Keiji Akaashi (Garotos da Praia), até no máximo 60%. Quando [Mostre 100% do Seu Treino] for ativado, para cada acúmulo de [Mente Tranquila] que ele tiver, o [Ataque Potente] de quem fizer a cortada aumenta em 3/3,5/4%, até no máximo 24/28/32%."}, {nome: "Jogada Decisiva", descricao:"Akaashi Kyoji (Garotos da Praia) executa uma Largada do Levantador com poder de 260/280/300/320/340% do seu [Levantamento]. A Largada do Levantador não pode ser bloqueada. Se essa largada for um Acerto Crítico, o tempo de recarga de [Mostre 100% do Seu Treino] é reduzido em 4 passagens pela rede.Ganha 1 acúmulo de [Mente Tranquila]."}
], symbols: [ "img/powersymbol.png", "img/settersymbol.png" ] },

{ nome: "Akaashi SSR", funcao: "S", img: "img/akaashiSR.png", School: "Fukurodani", vinculo: ["Ás Milagroso e Levantador Carinhoso"], Stats:{Serve:1396,Spike:1331,Set:1476,Receive:1191,Block:1334,Save:1123}, habilidades:[
  {nome:"CLAREZA EM MOVIMENTO", descricao:"Enquanto KEIJI AKAASHI estiver em quadra, quando um colega de time realiza um Bloqueio ou Recepção PERFEITOS, remove todas as penalidades desse jogador, aumenta a Percepção do AKAASHI em 8% e aumenta o Moral do seu time em 3"},
  {nome:"CONTRAPONTO TÁTICO", descricao:"KEIJI AKAASHI realiza uma Largada do Levantador impossível de bloquear com 120% do seu atributo Levantamento. Se esse ataque marcar, seu próximo Saque ganha 10% de potência adicional com base no atributo Saque do sacador"},
  {nome:"FLUXO ALTRUÍSTA", descricao:"Aumenta o atributo Levantamento de KEIJI AKAASHI em 8%. Enquanto seu time estiver em [Reforço de Moral do Time], para cada 4 de Moral obtido, aumenta a Percepção de AKAASHI em 1.2%. Quando AKAASHI realiza um Levantamento Superior, a próxima Cortada do seu time terá a garantia de ser Superior"},
  {nome:"CONJUNTO CONSISTENTE", descricao:"KEIJI AKAASHI realiza um Levantamento com 240% do seu atributo Levantamento"}
], symbols: [ "img/powersymbol.png", "img/settersymbol.png" ] },

{ nome: "Konoha SSR", funcao: "OP", img: "img/konohaSR.png", School: "Fukurodani", vinculo: [], Stats:{Serve:1256,Spike:1462,Set:1196,Receive:1274,Block:1333,Save:1335}, habilidades:[
  {nome:"Recepção Excelente", descricao:"A [Recepção] de Akinori Konoha aumenta em 8/10/12%. Enquanto o Despertar de Moral estiver ativo, suas [Recepção] e [Defesa] aumentam em 10%."},
  {nome:"Uma Combinação Primorosa", descricao:"Akinori Konoha realiza uma Defesa com 120/135/150% de [Defesa] como poder."},
  {nome:"Bloqueio do Polivalente", descricao:"Quando Akinori Konoha está na linha de frente, o [Bloqueio] e o [Ataque Potente/Ataque Rápido] de todos os aliados na linha de frente aumentam em 8/10/12%. Se ele estiver na linha de trás, a [Recepção] e a [Defesa] de todos os aliados na linha de trás aumentam em 8/10/12%."},
  {nome:"Sr. Habilidoso (mas Pobre)", descricao:"Akinori Konoha recebe com 225/240/255/270/285% de [Recepção] como poder. Se o resultado não for RUIM, a Moral do Time aumenta em 20."}
], symbols: [ "img/receivesymbol.png" ] },

/* ==missing Stats== */{ nome: "Haruki SSR", funcao: "L", img: "img/harukiSR.png", School: "Fukurodani", vinculo: [], Stats:{Serve:1,Spike:1,Set:1,Receive:1,Block:1,Save:1}, habilidades:[
  {nome:"Mestre da Defesa", descricao:"A [Recepção] de Haruki Komi aumenta em 8/10/12%. Se o resultado da sua recepção não for RUIM, a Moral do Time adversário diminui em 12."},
  {nome:"Lubrificante da Equipe (0_0)", descricao:"Haruki Komi realiza uma Defesa que usa 110/125/140% de [Defesa] como poder. Se o resultado não for RUIM, os atributos principais dos aliados aumentam em 5/6.5/8% por 1 rali."},
  {nome:"Recepção Comprovada", descricao:"Quando Haruki Komi recebe e o oponente dispara um ataque poderoso, a potência dessa recepção aumenta em 30/40/50% de [Recepção] como poder."},
  {nome:"Centro da Defesa", descricao:"Haruki Komi executa uma recepção com 235/250/265/280/295% de [Recepção] como poder."}
], symbols: [ "img/receivesymbol.png" ] },

/* ==missing Stats== */{ nome: "Tatsuo SSR", funcao: "MB", img: "img/tatsuoSR.png", School: "Fukurodani", vinculo: [], Stats:{Serve:1,Spike:1,Set:1,Receive:1,Block:1,Save:1}, habilidades:[
  {nome:"Bloqueio Intimidante", descricao:"O [Bloqueio] de Tatsuki Washio aumenta em 8/10/12%. Ao bloquear, o poder da primeira recepção do companheiro após essa jogada aumenta em 20% de [Recepção]. Se o bloqueio dele não for RUIM, o próximo bloqueio dele aumenta em 20% de [Bloqueio]."},
  {nome:"Ataque de Alta Pontuação", descricao:"Tatsuki Washio executa um Ataque Rápido com 120/135/150% de [Ataque Rápido] como poder."},
  {nome:"Trabalhador de Talento Oculto", descricao:"Quando um oponente faz uma boa jogada, o [Bloqueio] e o [Ataque Rápido] de Tatsuki Washio aumentam em 2/2.5/3%, até 5 acúmulos."},
  {nome:"Bloqueio que Aproveita o Corpo Alto", descricao:"Tatsuki Washio bloqueia com 220/235/250/265/280% de [Bloqueio] como poder."}
], symbols: [ "img/quicksymbol.png", "img/blocksymbol.png" ] },

{ nome: "Terushima SSR", funcao: "WS", img: "img/terushimaSR.png", School: "Jozenji", vinculo: [], Stats:{Serve:1401,Spike:1470,Set:1196,Receive:1335,Block:1263,Save:1196}, habilidades:[
  {nome:"Espírito Livre", descricao:"Aumenta o [Ataque Potente] de Terushima Yuji em 8/10/12%. Quando ele está em quadra e o resultado da recepção, Defesa ou Passe de um aliado não for RUIM, Terushima Yuji ganha 1 acúmulo de [Brincar Mais, Brincar Mais]. Cada acúmulo aumenta o [Ataque Potente/Ataque Rápido] em 2.5%, até 4 acúmulos."},
  {nome:"Saque Divertido", descricao:"Terushima Yuji executa um Saque em Suspensão com 120/135/150% de [Saque] como poder."},
  {nome:"Asoviva", descricao:"Para cada membro recebedor na sua equipe, a [Recepção] de Terushima Yuji aumenta em 4/5/6%. Se ele errar uma recepção, nenhum ponto é perdido. O tempo de recarga desse efeito dura até a bola cruzar a rede 10 vezes."},
  {nome:"Cortada Empolgante", descricao:"Terushima Yuji executa uma Cortada Potente com 235/250/265/280/295% de [Ataque Potente]. Se marcar ponto, a [Recepção] dos aliados aumenta em 10% por 3 cruzamentos de rede."}
], symbols: [ "img/powersymbol.png", "img/servesymbol.png" ] },

{ nome: "Atsumu UR", data: "10/14/25", funcao: "S", img: "img/atsumuUR.png", School: "Inarizaki", vinculo: ["A força dos Gêmeos", "Cabeça dos Gêmeos"], Stats:{Serve:1705,Spike:1539,Set:1629,Receive:1376,Block:1530,Save:1290}, habilidades:[
  {nome:"Jogada Imprevisível", descricao:"Quando Miya Atsumu realiza um saque, se o alvo for um ponto fraco da defesa adversária, o poder do saque aumenta em 30/40/50% de [Saque]. Se não for em ponto fraco, a [Recepção] dos seus jogadores da linha de trás aumenta em 10/12/14% por 1 rali."},
  {nome:"Levantamento Delicado", descricao:"Miya Atsumu executa um Passe com 125/140/155% de [Passe] como poder. Esse Passe remove todas as penalidades do jogador que vai atacar (Potente/Rápido)."},
  {nome:"Levantamento Devoto e Sincero", descricao:"Aumenta o [Passe] de Miya Atsumu em 8/11/14%. Quando um jogador seu realiza uma ação e o resultado não é PERFEITO, Atsumu ganha 2 acúmulos de [Timing Perfeito]. Cada acúmulo aumenta o [Passe] em 2% (máx. 10). Ao levantar, ele consome 1 acúmulo, aumentando a [Técnica de Ataque] e o [Ataque Rápido] do atacante em 2.5. Dura por 10 cruzamentos."},
  {nome:"Saque das Duas Espadas", descricao:"Miya Atsumu alterna entre Saque em Suspensão e Saque Flutuante com Salto. Flutuante com Salto: 230/245/275/290% de [Saque] como poder; impede o uso de Superiores de [Ataque Potente/Ataque Rápido] por 2 cruzamentos. Saque em Suspensão: 260/275/290/305/320% de [Saque] como poder; a cada 3 de Moral do Time, a [Percepção] de Atsumu aumenta em 1% por 2 cruzamentos."}
], symbols: [ "img/quicksymbol.png", "img/servesymbol.png", "img/settersymbol.png" ] },

{ nome: "Osamu UR", data: "10/29/25", funcao: "OP", img: "img/osamuUR.png", School: "Inarizaki", vinculo: ["A força dos Gêmeos", "Cabeça dos Gêmeos"], Stats:{Serve:1621, Spike:1685, Set:1426, Receive:1459, Block:1428, Save:1373}, habilidades:[
  {nome:"Ataque Flexível", descricao:"Aumenta o [Ataque Rápido] de Miya Osamu em 10/12/14%. Início da partida: a [Percepção] de Osamu cai para 0% e, para cada 1% reduzido, a [Técnica de Ataque] aumenta em 1%. (Priorize empilhar [Percepção] para esta habilidade)."},
  {nome:"Saque em Suspensão Frio", descricao:"Miya Osamu executa um Saque em Suspensão com 120/135/150% de [Saque]. Se o recebedor adversário tiver [Supressão], a [Técnica de Ataque] de Osamu aumenta em 10% por 8 cruzamentos."},
  {nome:"Multitalentoso", descricao:"Aumenta a [Técnica de Ataque] de Miya Osamu em 10/13/16%. Quando ele ataca ou saca, aplica 1 acúmulo de [Supressão] nos jogadores da linha de trás adversária (cada acúmulo reduz a [Recepção] em 10%). Dura por 10 cruzamentos."},
  {nome:"Contra-ataque Flexível", descricao:"Miya Osamu realiza um Ataque Rápido com 260/275/290/305/320% de [Ataque Rápido]. O [Ataque Rápido] dele aumenta em 40% de [Técnica de Ataque] por 2 cruzamentos. (Sinergiza com a [Técnica de Ataque] ganha em Ataque Flexível). SR2: se o recebedor inimigo tiver [Supressão], a potência aumenta em mais 60% de [Ataque Rápido]. SR4: após o Ataque Rápido, as próximas duas vezes que um aliado ativar um Superior, a [Técnica de Ataque/Defesa] desse jogador aumentará em 20%."}
], symbols: [ "img/quicksymbol.png", "img/servesymbol.png" ] },

{ nome: "Kita SSR", funcao: "WS", img: "img/kitaSR.png", School: "Inarizaki", vinculo: ["Cabeça dos Gêmeos"], Stats:{Serve:1238, Spike:1219, Set:1333, Receive:1476, Block:1198, Save:1409}, habilidades:[
  {nome:"Repetição, Continuidade e Cautela", descricao:"Aumenta os atributos Básicos de Kita Shinsuke em 6/8/10%. Se o resultado da [Recepção] de Kita for RUIM, a [Técnica de Defesa] aumenta em 80% de [Reflexo] como poder."},
  {nome:"Jogada Calma", descricao:"Kita Shinsuke executa uma [Defesa] com 120/135/150% de [Defesa] como poder."},
  {nome:"Vou Fazer do Jeito Certo", descricao:"A [Recepção] de Kita Shinsuke aumenta em 8/10/12%. Ele realiza uma [Recepção]; se o resultado não for PERFEITO, ganha 1 acúmulo de [Ação Confiável] (+3% [Recepção], até 3). Com 3 acúmulos, consome 3 para aumentar a [Técnica de Ataque] dos jogadores da linha de frente em 10% por 8 cruzamentos."},
  {nome:"Jogada Sólida", descricao:"Kita Shinsuke realiza uma [Recepção] com 235/250/265/280/295% de [Recepção] como poder."}
], symbols: [ "img/receivesymbol.png" ] },

{ nome: "Rintaro SSR", funcao: "MB", img: "img/rintaroSR.png", School: "Inarizaki", vinculo: [], Stats:{Serve:1266, Spike:1476, Set:1186, Receive:1258, Block:1324, Save:1318}, habilidades:[
  {nome:"Fechar o Ângulo", descricao:"Aumenta o [Bloqueio] de Rintaro Suna em 10/12/14%. Se ele estiver em quadra e o atacante adversário estiver sob [Confusão], o poder de bloqueio do time aumenta em 15/20/25% do [Bloqueio] do bloqueador."},
  {nome:"Bloqueio Hábil", descricao:"Rintaro Suna bloqueia com 20/35/50% do poder do ataque."},
  {nome:"Jogada que Pega o Oponente Desprevenido", descricao:"Aumenta o [Ataque Rápido] de Rintaro Suna em 10/12/14%. Ao realizar Ataque Rápido, aplica 1 acúmulo de [Confusão] na linha de frente adversária. Cada acúmulo reduz o [Bloqueio] em 10%, por até 8 cruzamentos de rede."},
  {nome:"Cortadas com Amplo Ponto de Impacto", descricao:"Rintaro Suna realiza um Ataque Rápido com 240/255/270/285/300% de [Ataque Rápido] como poder."}
], symbols: [ "img/quicksymbol.png", "img/blocksymbol.png" ] },

/* ==missing Stats== */{ nome: "Oshiro SSR", funcao: "WS", img: "img/oshiroSR.png", School: "Inarizaki", vinculo: [], Stats:{Serve:1,Spike:1,Set:1,Receive:1,Block:1,Save:1}, habilidades:[
  {nome:"Controle de Ritmo", descricao:"Sempre que Oshiro Alan consumir 10 de Vigor, ganha 1 acúmulo de [Respiração Rápida]. Cada acúmulo aumenta a [Técnica de Ataque] em 3/3.5/4%. Ao final do rali, todos os acúmulos são consumidos; para cada um, Oshiro recupera 4 de Vigor."},
  {nome:"Saque Altamente Técnico", descricao:"Ojiro Alan executa um Saque em Suspensão com 110/125/140% de [Saque] como poder. O recebedor adversário terá a [Recepção] reduzida em 10% por 6 cruzamentos."},
  {nome:"Investida Agressiva", descricao:"Aumenta o [Ataque Potente] de Oshiro Alan em 6/8/10% e o [Saque] em 6/8/10%. Ao realizar um Ataque Potente, consome 60% do Vigor atual e aumenta o poder do ataque em 30/40/50% de [Ataque Potente]."},
  {nome:"Cortada Trovejante", descricao:"Ojiro Alan executa um Ataque Potente com 240/255/270/285/300% de [Ataque Potente] como poder."}
], symbols: [ "img/powersymbol.png", "img/servesymbol.png" ] },

/* ==missing Stats== */{ nome: "Akagi SSR", funcao: "L", img: "img/akagiSR.png", School: "Inarizaki", vinculo: [], Stats:{Serve:1,Spike:1,Set:1,Receive:1,Block:1,Save:1}, habilidades:[
  {nome:"Defesa que Aumenta a Seriedade", descricao:"Aumenta a [Recepção] e a [Defesa] de Akagi Michinari em 8/10/12%. Aumenta a Moral do Time em 10 quando Akagi recebe ou defende."},
  {nome:"Um Líbero Confiável", descricao:"Akagi Michinari executa uma Defesa com poder igual a 120/135/150% de [Defesa]. Aumenta a [Técnica de Defesa] dos aliados em 4/6/8% até a bola cruzar a rede 6 vezes."},
  {nome:"Perseguir a Bola com a Mão", descricao:"A [Recepção] de Akagi Michinari aumenta em 10/12/14%. Quando ele está em quadra, um oponente que faz uma cortada poderosa recebe 1 acúmulo de [Aproximação] (reduz [Ataque Potente] em 8/10/12% por acúmulo até a bola cruzar a rede 3 vezes). Se o oponente já tiver [Aproximação], a [Técnica de Defesa] dos aliados aumenta em 4/6/8% por 3 cruzamentos."},
  {nome:"Recepção Corajosa", descricao:"Akagi Michinari recebe com 240/255/270/285/300% de [Recepção] como poder."}
], symbols: [ "img/receivesymbol.png" ] },

/* ==missing Stats== */{ nome: "Yui SSR", funcao: "WS", img: "img/yuiSR.png", School: "Inarizaki", vinculo: [], Stats:{Serve:1,Spike:1,Set:1,Receive:1,Block:1,Save:1}, habilidades:[
  {nome:"Ataque e Defesa Estáveis", descricao:"Aumenta o [Ataque Potente] de Ginjima Yui em 6/8/10% e a [Recepção] em 6/8/10%. Quando ele recebe, se o oponente realizar um Ataque Potente, a potẽncia dessa recepção aumenta em [Recepção] × 15/25/35%."},
  {nome:"Recepção Poderosa", descricao:"Ginjima Yui recebe com [Recepção] × 120/135/150% de poder."},
  {nome:"Um Ataque Entusiasmado", descricao:"Sempre que houver um recebedor na equipe, a [Técnica de Ataque] de Ginjima Yui aumenta em 2/2.5/3%. Se a recepção do companheiro não for RUIM, o [Ataque Potente] de Ginjima Yui aumenta em 15% por até quatro cruzamentos de rede."},
  {nome:"Um Golpe Poderoso", descricao:"Ginjima Yui executa um ataque poderoso com [Ataque Potente] × 225/240/255/270/285% de poder. Se estiver na linha de trás, a potência aumenta em [Ataque Potente] × 30%."}
], symbols: [ "img/powersymbol.png", "img/receivesymbol.png" ] },

{ nome: "Hoshiumi UR", data: "12/13/25", funcao: "WS", img: "img/hoshiumiUR.png", School: "Kamomedai", vinculo: ["Amigos de longa data"], Stats:{Serve:1621,Spike:1704,Set:1341,Receive:1541,Block:1581,Save:1305}, habilidades:[
  {nome:"Quebrar a Cadeia", descricao:"Quando Hoshiumi Korai está em quadra e um aliado bloqueia, a cada 50 de [Bloqueio] dos bloqueadores, a potência da Cortada do adversário (Potente/Rápida) é reduzida pelos jogadores atacantes do time [Ataque Potente/Ataque Rápido] × 0.3/0.4/0.5% (máx. 30%). Para cada 1% reduzido na cortada do oponente, a potência da próxima habilidade de Hoshiumi aumenta em 1%."},
  {nome:"Ótimo Desempenho em Todas as Áreas", descricao:"Hoshiumi Korai pode ativar múltiplas habilidades de jogadas (compartilham tempo de recarga).\nSaque-Cortada: Realiza um Saque-Cortada com a potência de [Saque] × 140/160/180% de poder.\nRecepção: Recebe com a potência de [Recepção] × 140/160/180% de poder.\nBloqueio: Bloqueia com a potência de [Bloqueio] × 140/160/180% de poder."},
  {nome:"Nº 1 em Pontuar", descricao:"Aumenta o [Ataque Potente] de Hoshiumi Korai em 16/20/24%. Ao ativar ganha 1 acúmulo de [All-Rounder]. Quando a habilidade de Hoshiumi está ativada, o efeito [All-Rounder] é consumido, e diferentes efeitos são ativados dependendo da jogada.\nPancada Poderosa: Aumenta a[Atenção] em 14/17/20% até a bola cruzar a rede duas vezes.\nSaque: reduz a [Recepção] dos jogadores da linha de trás do oponente em 14/17/20% até a bola cruzar a rede duas vezes."},
  {nome:"Lança Brilhante", descricao:"Executa um ataque poderoso com [Ataque Potente] × 265/280/295/310/325% de poder. Se estiver na linha de frente, a potência desse ataque aumenta em [Ataque Potente] × 40/45/50/55/60%."}
], symbols: [ "img/powersymbol.png", "img/servesymbol.png", "img/blocksymbol.png", "img/receivesymbol.png" ] },

{ nome: "Hirugami UR", data: "12/28/25", funcao: "MB", img: "img/hirugamiUR.png", School: "Kamomedai", vinculo: ["Amigos de longa data"], Stats:{Serve:1660,Spike:1630,Set:1629,Receive:1540,Block:1742,Save:1493}, habilidades:[
  {nome:"O Núcleo do Sistema Kamomedai", descricao:"Quando Hirugami Sachiro saca, sua [Atenção] aumenta em 12/16/20%. Estando em quadra, aliados ganham 1 acúmulo de [Sistema] ao bloquear (cada acúmulo aumenta os atributos básicos dos aliados em 8%, até 5 acúmulos; dura até o aliado pontuar). Cada acúmulo também aumenta os atributos básicos de Hirugami em 10% adicionais."},
  {nome:"Saque Psicologicamente Pressionante", descricao:"Executa um Saque Flutuante com Salto com 140/160/180% de [Saque] como poder. Se for uma boa jogada, encerra o Despertar de Moral do oponente, impedindo-o de ganhar Moral por 1 rali."},
  {nome:"A Defesa é o Melhor Ataque", descricao:"Quando Hirugami está em quadra, ganha 1 acúmulo de [Bloqueio Forte] cada vez que a bola cruza a rede. Quando um aliado bloqueia, o efeito depende do número de acúmulos de [Bloqueio Forte].\n2 acúmulos: poder de Bloqueio aumenta em 15/20/25% do [Bloqueio] dos bloqueadores por dois cruzamentos de rede.\n3 acúmulos: poder de Recepção aumenta em 15/20/25% da [Recepção] dos recebedores."},
  {nome:"O Deus Imóvel do Dia", descricao:"Bloqueia com [Bloqueio] × 260/275/290/305/320% de poder. Se o oponente disparar um ataque poderoso, o bloqueio aumenta em [Bloqueio] × 40/45/50/55/60%."}
], symbols: [ "img/servesymbol.png", "img/blocksymbol.png" ] },

{ nome: "Sakusa UR", data: "08/10/26", funcao: "WS", img: "img/sakusaUR.png", School: "Itachiyama", vinculo: ["Top Spiker e Top Libero"], Stats:{Serve:1774,Spike:2012,Set:1667,Receive:1928,Block:1699,Save:1656}, habilidades:[
  {nome:"Ataque Persistente", descricao:"O [Ataque Potente] de Kiyoomi Sakusa aumenta em 10/12.5/15% e sua [Recepção] em 20/22/25%. Quando ele recebe um ataque, o [Ataque Potente] aumenta em 6% (até 3 acúmulos), durando até o seu próximo Ataque Potente. Quando ele acerta uma Jogada Potente, a [Recepção] aumenta em 15% até a sua próxima recepção."},
  {nome:"Tomar Todas as Precauções", descricao:"Realiza uma Recepção ×1 com 50/70/90% de poder. Se ao receber exceder [Recepção] × 170%, o [Reflexo] aumenta em 10% e o tempo de recarga é reduzido em 2× os cruzamentos. Se ao receber exceder a [Recepção] × 200%, a [Técnica de Defesa] aumenta em 15% até o fim da partida."},
  {nome:"Ponta Superior", descricao:"Estando em quadra, quando aliados fazem boa jogada (receber, defender, bloquear), ganha 1 acúmulo de [Perfeccionismo]. Cada acúmulo aumenta a [Recepção] e o [Ataque Potente] em 6%, até 20 acúmulos. Ao atacar, a [Percepção] aumenta em 10% por acúmulo, até a bola cruzar a rede duas vezes."},
  {nome:"Cortadas que Mudam a Trajetória pela Rotação", descricao:"Executa um [Ataque Potente] com × 260/280/300/320/340% de poder. Se estiver na linha de trás, a potência aumenta em [Ataque Potente] × 40%. Em caso de boa jogada, a próxima recepção do oponente é reduzida em [Recepção] × 15%."}
], symbols: [ "img/receivesymbol.png", "img/powersymbol.png" ] },

{ nome: "Komori UR", data: "09/09/26", funcao: "L", img: "img/komoriUR.png", School: "Itachiyama", vinculo: ["Top Spiker e Top Libero"], Stats:{Serve:1580,Spike:1579,Set:1904,Receive:2012,Block:1580,Save:1866}, habilidades:[
  {nome:"Peça-chave da Equipe", descricao:"Estando em quadra, a [Técnica de Defesa] de todos os jogadores aliados da linha de trás aumenta em 10/13/16%. No início do rali, ganha 6 acúmulos de [Conectar ao Próximo]; cada acúmulo aumenta o [Passe] em 3% e o [Reflexo] em 5%, até 10."},
  {nome:"Levantamento Habilidoso", descricao:"Realiza Passe com [Passe] × 140/160/180% de poder, aumentando a Moral do time em 10. A primeira Cortada (Potente/Rápida) de um aliado após isso aumenta a [Atenção] do atacante em 15% até a bola cruzar a rede duas vezes."},
  {nome:"Criar o Fluxo do Jogo", descricao:"A [Recepção] aumenta em 12/16/20%. Quando um aliado ativa uma recepção não-especial ou Komori ativa uma recepção especial, consome 2 acúmulos de [Conectar ao Próximo] para aumentar a recepção em [Recepção] × 30% e a primeira Cortada de um aliado depois disso aumenta o poder dessa cortada (Potente/Rápida) em 20%."},
  {nome:"Recepção que Cria Impulso", descricao:"Recebe com [Recepção] × 260/275/290/305/320% de poder. A primeira Cortada de um aliado após isso (Potente/Rápida) aumenta a [Técnica de Ataque] do atacante em 20% até a bola cruzar a rede duas vezes."}
], symbols: [ "img/receivesymbol.png", "img/settersymbol.png" ] },

/* ==missing Stats== */{ nome: "Kuroo SP", funcao: "MB", img: "img/kuroSP.png", School: "Nekoma", vinculo: ["Festival Fogos de Artificio","Cérebro e Comandante SP"], Stats:{Serve:1,Spike:1,Set:1,Receive:1,Block:1,Save:1}, habilidades:[
  {nome:"A Torre de Comando Imbatível", descricao:"Quando Kuroo Tetsuro (Hanabi) está em quadra, o [Empenho] dos aliados na mesma linha de Kuroo Tetsuro (Hanabi) aumenta em 20/25/30%. Depois que ele toca na bola, o poder da próxima jogada do mesmo tipo que a jogada de Kuroo Tetsuro (Hanabi) é aumentado em 40% × o parâmetro correspondente do membro que fará a jogada. Se a jogada de Kuroo Tetsuro (Hanabi) for crítica, um membro aleatório do time adversário recebe a desvantagem [Raiva] ([Ataque Potente/Ataque Rápido] será reduzido em 10%)."},
  {nome:"Recepção Habilidosa", descricao:"Kuroo Tetsuro (Hanabi) realiza uma recepção com poder igual a [Recepção] × 140/160/180%. Se essa jogada for crítica, o poder dessa recepção aumenta em [Recepção] × 20%."},
  {nome:"Um Jogador Completo, Sem Falhas", descricao:"Quando Kuroo Tetsuro (Hanabi) está na linha de frente/trás e toca na bola, seu [Reflexo] aumenta em 50% × o [Reflexo] de cada outro aliado na linha de frente/trás (máximo 100%), e seu [Empenho] aumenta em 50% × o [Empenho] de cada outro aliado na linha de frente/trás (máximo 100%). Além disso, quando Kuroo Tetsuro (Hanabi) está na linha de frente, a [Técnica de Ataque] dos aliados aumenta em 14/17/20%, e seu poder de bloqueio aumenta em [Bloqueio] × 45%. Além disso, quando Kuroo Tetsuro está na linha de trás, a [Técnica de Defesa] dos aliados aumenta em 14/17/20%, e seu poder de recepção aumenta em [Recepção] × 45%."},
  {nome:"Bloqueio Desagradável", descricao:"Kuroo Tetsuro (Hanabi) realiza um bloqueio com poder de [Bloqueio] × 280/300/320/340/360%. Se esse bloqueio não devolver a bola para a quadra adversária, a primeira recepção de um aliado após essa jogada não resultará em ponto. Se esse bloqueio devolver a bola para a quadra adversária, os atributos principais de todos os aliados aumentam em 15%. Esse efeito dura até a bola atravessar a rede 8 vezes."}
], symbols: [ "img/receivesymbol.png", "img/blocksymbol.png" ] },

{ nome: "Kunimi SP", funcao: "OP", img: "img/kunimiSP.png", School: "Aoba Johsai", vinculo: ["Festival de Esporte"], Stats:{Serve:1674,Spike:1950,Set:1573,Receive:1857,Block:1762,Save:1570}, habilidades:[
  {nome:"Conservar Energia", descricao:"Kunimi Akira (Festival de Esporte) ganha +10%/13%/16% de [Ataque Potente]. Se o Vigor de Kunimi for abaixo de 80, seu [Ataque Potente] ganha um adicional de 12%. Enquanto Kunimi estiver na quadra, no final de cada rali, se seu limite de Vigor exceder 80, seu limite de Vigor é reduzido em 10 e recupera 120 de Vigor. Enquanto Kunimi estiver na quadra, cada vez que o Vigor de um aliado diminuir por 10, Kunimi ganha 1 acúmulo de [Reserva de Vigor]. Para cada acúmulo de [Reserva de Vigor], sua [Percepção] cresce em 7%, até 30 acúmulos. Até 10 acúmulos por rali."},
  {nome:"Defesa Precisa", descricao:"Kunimi Akira (Festival de Esporte) realiza uma recepção com potência de [Recepção] x 140%/160%/180%, e os atributos principais dos aliados aumentam em 10%. Esse efeito dura até a bola cruzar a rede duas vezes."},
  {nome:"Dar Tudo de Si", descricao:"Cada vez que Kunimi Akira (Festival de Esporte) recupera Vigor, seu [Ataque Potente] cresce em 0.8%/1.1%/1.4% (até +16%/22%/28%). No começo de um rali, se o limite de Vigor de Kunimi for 80 ou menos, ele ganha [Momento de Embreagem]. Enquanto [Momento de Embreagem] estiver ativo, o tempo de recarga dele vira em 6 cruzamentos de rede. Se a [Percepção] de Kunimi exceder 100%, para cada 1% acima, sua [Força] cresce em 0.9% (até 90%). Depois de ganhar [Momento de Embreagem], para as duas primeiras ativações, cada vez que é usado, o seu tempo de recarga é zerado."},
  {nome:"Espírito de Luta Ardente", descricao:"Kunimi Akira (Festival de Esporte) consome +8 de Vigor e realiza um [Ataque Potente] com potência de [Ataque Potente] x 295%/315%/335%/375%. Se o Vigor do Kunimi exceder 50, a potência do seu ataque cresce em [Ataque Potente] x 50%."}
], symbols: [ "img/receivesymbol.png", "img/powersymbol.png" ] },

{ nome: "Koganegawa SP", funcao: "S", img: "img/koganegawaSP.png", School: "Dateko", vinculo: ["Festival de Esporte","Aliados no Campo de Treinamento","Parede de Ferro"], Stats:{Serve:1766,Spike:1661,Set:1882,Receive:1661,Block:1970,Save:1573}, habilidades:[
  {nome:"Bloqueio de Suporte", descricao:"Levantamento do Koganegawa +10%/13%/16%. Quando ele estiver em quadra e um aliado sacar, a [Percepção] do membro que sacou aumenta em +20% por 1 cruzamento (máx. 1 acúmulo). Também ganha 1 acúmulo de [Criar Muralha de Ferro]. Se uma habilidade de Saque for ativada durante esse saque, ganha 1 acúmulo adicional de [Criar Muralha de Ferro]. Quando Koganegawa estiver em quadra, se os aliados executarem um bloqueio duplo ou triplo, então na próxima vez que Koganegawa realizar um Levantamento, a [Percepção] aumenta em 30% e o [Levantamento] em 10%."},
  {nome:"Setup de Curta Distância", descricao:"Koganegawa realiza um Levantamento com poder [Levantamento] × 140%/160%/180%.Durante a primeira cortada de um aliado (Ataque Potente / Ataque Rápido) após esta habilidade ativar, a [Percepção] do membro que cortou +10% e [Ataque Potente] / [Ataque Rápido] +15% por 2 cruzamentos de rede.Além disso, o [Moral da Equipe] +6."},
  {nome:"Canto da Parede de Ferro", descricao:"Enquanto Koganegawa estiver em quadra, no início de um rali, os aliados com [Reflexo] ≥ 200% recebem +10% de [Técnica de Ataque] e +10% de [Técnica de Defesa].Quando os aliados executarem um bloqueio duplo ou triplo, ou quando a habilidade de [Bloqueio] de um aliado ativar, ganha 1 acúmulo de [Criar Muralha de Ferro] (máx. 12).Com ≥ 3 acúmulos: [Percepção] e [Reflexo] dos aliados +20%, e a [Percepção] e [Reflexo] do Koganegawa +30%.Com ≥ 7 acúmulos: no início de um rali, o [Bloqueio] da fila da frente dos aliados aumenta em [Bloqueio] do Koganegawa × 12% (limite 800/900/1000).Com ≥ 10 acúmulos: aliados com [Percepção] > 100% recebem +15% de [Força], e aliados com [Reflexo] > 100% recebem +25% de [Mental] por 1 set."},
  {nome:"Parede Alta", descricao:"Executa um Bloqueio com poder [Bloqueio] × 260%/275%/290%/305%/320%.Se for um bloqueio duplo ou triplo, o [Reflexo] de Koganegawa +40%.Se Parede Alta não estiver em recarga, quando o Supremo de [Bloqueio] de outro aliado ativar, o poder desse bloqueio aumenta em [Bloqueio] do membro que bloqueou × 100%, então Parede Alta entra em recarga."}
], symbols: [ "img/blocksymbol.png","img/settersymbol.png" ] },

{ nome: "Oikawa SP", funcao: "S", img: "img/oikawaSP.png", School: "Aoba Johsai", vinculo: ["Cultural Festival"], Stats:{Serve:1,Spike:1,Set:1,Receive:1,Block:1,Save:1}, habilidades:[
  {nome:"Performance 100%", descricao:"xxx"},
  {nome:"Saque Sniper", descricao:"xxx"},
  {nome:"Torre de Comando", descricao:"xxx"},
  {nome:"Passe Perfeito", descricao:"xxx"}
], symbols: [ "img/powersymbol.png","img/settersymbol.png"] }
];


const descricoesSinergia = {
  "Karasuno": "Aumenta em 10% os Stats de Ataque Potente e Ataque Rápido de TODOS os jogadores.",
  "Nekoma": "Aumenta em 15% o Stat de Recepção de TODOS os jogadores.",
  "Dateko": "Aumenta em 15% o Stat de Bloqueio de TODOS os jogadores.",
  "Aoba Johsai": "Aumenta em 15% o Stat de Ataque Potente de TODOS os jogadores.",
  "Shiratorizawa": "Aumenta em 10% os Stats de Percepção e Força de TODOS os jogadores.",
  "Fukurodani": "A Moral do Time aumenta em 20.",
  "Inarizaki": "Aumenta em 5% os Stats de Força e Defesa de TODOS os jogadores.",
  "Dupla Excêntrica": "Aumenta o poder de Ataque Rápido e a Percepção de Hinata e Kageyama.",
  "Gênios Karasuno": "Aumenta o Reflexo e a Recepção de Nishinoya SP. Quando Nishinoya usa o especial, Kageyama UR ganha um acúmulo de Competitive Spirit*. Se o especial for PERFECT, o primeiro corte (Power ou Quick) depois disso tem poder aumentado em 20% do Power do atacante.",
  "Observação de flores de cerejeira": "Aumenta o Percepção de Kenma SP. Aumenta o Ataque Rápido de Hinata SP quando a jogada for PERFECT.",
  "Sol vs Lua": "Quando um aliado faz um levantamento (Passe), a [Percepção] dele aumenta em 10%.Dura até a bola atravessar a rede 2 vezes.Se o Ataque Rápido do Shoyo Hinata (Hanami) virar um PERFECT, o tempo de recarga de 〈Pulo Alto〉 é reduzido em 2 contagens de atravessar a rede.Kei Tsuki (Festival de Fogos) recebe [Percepção] igual a 50% da [Percepção] do Hinata (Hanami), até +50%.Esse efeito dura até a bola atravessar a rede 4 vezes.",
  "Depois da Escola": "Aumenta o Reflexo de Nishinoya SP; quando a Stamina dele estiver baixa, aumenta ainda mais.",
  "Deus Guardião e Ponta": "Quando Nishinoya SSR ou Azumane SSR usam habilidade, ambos aumentam Técnica de Ataque e Técnica de Defesa.",
  "Esquadrão de Kiyoko": "Ao pontuar, aumenta a Moral do Time.",
  "Cérebro e Comandante": "Quando Kenma SSR faz o passe, Kuroo UR realiza um Ataque Rápido fortalecido.",
  "Orientação Educacional": "Aumenta a Recepção de Yaku SSR e o Ataque Rápido de Lev SSR.",
  "Natação": "Aumenta a Moral do Time. Com Moral ativa, aumenta o Reflexo dos aliados em bloqueios duplos ou triplos.",
  "O Silencioso e o Sarcástico": "Permite que Aone SSR e Futakuchi SSR usem a habilidade [Bloqueio Duplo]*.",
  "O Novo Capitão e o Novato Altão": "Aumenta o Bloqueio dos jogadores na linha de frente.",
  "Harmonia Perfeita": "Quando Oikawa UR faz o passe, Iwaizumi SSR realiza um corte com Ataque Potente aumentado. Ganha 2 acúmulos de [Ritmo de Ataque]*, cada um aumentando o Percepção da equipe em 1% (máx. 10).",
  "A Matilha": "Aumenta o Ataque Potente de Iwaizumi SSR e Kentaro SSR.",
  "Bests para a vida": "Aumenta o Ataque Potente de Ushijima UR e o Técnica de Defesa de Tendo SSR.",
  "Campeão Absoluto e Levantador Sólido": "Quando Shirabu SSR faz o passe, Ushijima UR realiza um corte com 10% mais poder.",
  "WS de Shiratorizawa": "Aumenta o Ataque Potente de TODOS os jogadores presentes.",
  "Ás Milagroso e Levantador Carinhoso": "Bokuto UR sai da depressão. Quando Akaashi SSR faz o passe e Bokuto UR spika, aumenta o Ataque Potente desse golpe em 20% e eleva a Moral do Time em 15.",
  "Ace Milagroso e Levantador Carinhoso": "Aumenta o Passe de Akaashi SP. Com Moral ativa, aumenta o Ataque Potente de Bokuto SP em 18% e o Passe de Akaashi SP em 5%.",
  "A força dos Gêmeos": "Quando Atsumu UR faz o passe e Osamu UR faz um Ataque Rápido Minus Tempo, aumenta o Ataque Rápido dessa jogada. Aumenta o Técnica de Ataque em 15%. O ataque não pode ser bloqueado.",
  "Cabeça dos Gêmeos": "Aumenta o Técnica de Ataque de Osamu UR. Aumenta os Stats de Kita SSR. No início da partida, Atsumu ganha 3 acúmulos de Perfect Hit* (+2% de Passe cada, máx. 10). Kita SSR ganha bônus similar em Recepção (máx. 3). O primeiro Ataque Rápido dos gêmeos em cada set recebe +[Ataque Rápido] × 12%.",
  "Amigos de longa data": "Aumenta os Stats de Hoshiumi UR. Aumenta o Bloqueio para os jogadores da linha de frente. Hoshiumi UR e Hirugami UR recebem um buff (sem info).",
  "Top Spiker e Top Libero": "Sakusa UR aumenta seu Ataque Potente. Komori UR aumenta seu Recepção. Aumenta a Recepção dos aliados em 20%.",
  "Cérebro e Comandante SP": "Quando Kenma SP e Kuroo SP estão em quadra, podem usar a habilidade de ataque rápido Cérebro e Comandante*",
  "Festival Fogos de Artificio": "Atributos principais dos aliados aumentam em 6%.Ao fim de cada rali, aplica [Raiva] na linha de frente do oponente (os [Cortada Potente]/[Ataque Rápido] deles ficam –10%).Dura até a bola atravessar a rede 8 vezes.Se o alvo já tiver [Raiva], aplica [Distração] em vez disso (os [Cortada Potente]/[Ataque Rápido] ficam –20%).Também dura até a bola atravessar a rede 8 vezes.[Distração] não pode ser removido.",
  "Festival de Esporte":"Quando um aliado tocar na bola, consome 1 de [Stamina] e aumenta os atributos principais desse membro em 3%/3,5%/4%/4,5%/5% por 2 cruzamentos de rede.Se esse toque de bola for um [Bloqueio], o [Bloqueio] desse membro aumenta em +5% adicionais por 2 cruzamentos de rede.",
  "Aliados no Campo de Treinamento":"Aliados em quadra que possuam habilidade de [Bloqueio] recebem +6%/7%/8%/9%/10% [Bloqueio].O tempo de recarga de <Block System> é reduzido em 2 cruzamentos de rede.Quando um aliado ativa uma habilidade de [Saque], aplica [Raiva] na linha de trás do oponente ([Ataque Potente]/[Ataque Rápido] −10%) por 8 cruzamentos de rede.",
  "Parede de Ferro" :"Quando Koganegawa estiver em quadra, se pelo menos 2 membros incluídos neste Vínculo estiverem presentes, a Habilidade de Vínculo é ativada.Quando os aliados executarem um bloqueio duplo/triplo, os aliados da linha de frente recebem [Técnica de Defesa] +3%/4%/5%/6%/7% por 1 cruzamento de rede.Quando um aliado ativa uma habilidade de [Saque], o saque não falhará.Durante ralis em que um aliado ativa uma habilidade de [Saque], se os aliados executarem bloqueio duplo/triplo, ganha 1 acúmulo de [Poderoso Bloqueio] e [Criar Muralha de Ferro] (só ativa se o membro correspondente estiver em quadra)."
};
    
/** Catálogo de MEMÓRIAS (exemplos; ajuste/expanda à vontade) */
const memoryCatalog = [
  {
    id:"mem_op",
    name:"Memória de OP",
    positions:["OP"],
    bonus:{
      Serve:{flat:518}, Spike:{flat:663}, Set:{flat:461},
      Receive:{flat:663}, Block:{flat:605}, Save:{flat:490}
    },
    desc:"Quando um membro com esta memória joga pela primeira vez em cada set, sua [Recepção] aumenta em 24%. Este efeito dura por 3 ralis.",
    img:"img/memories/MemoOP.png"
  },
  {
    id:"mem_l",
    name:"Memória de L",
    positions:["L"],
    bonus:{
      Serve:{flat:490}, Spike:{flat:518}, Set:{flat:605},
      Receive:{flat:663}, Block:{flat:461}, Save:{flat:663}
    },
    desc:"Os Parâmetros Principais do membro que equipa esta memória aumentam em 6.4%. Se o resultado de recepção do respectivo membro não for BAD, o poder do próximo Ataque Potente do aliado será aumentado em 24% × [Ataque Potente] do membro que executará o Ataque Potente.",
    img:"img/memories/MemoL.png"
  },
  {
    id:"mem_ws",
    name:"Memória de WS",
    positions:["WS"],
    bonus:{
      Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461},
      Receive:{flat:663}, Block:{flat:518}, Save:{flat:490}
    },
    desc:"O membro que equipa esta memória tem seu [Ataque Potente] aumentado em 12%. Quando o membro realiza um Ataque Potente, o [Bloqueio] do oponente é reduzido em 6.4% até a bola cruzar a rede uma vez. Se o resultado do bloqueio do oponente nesta jogada for BAD, o membro oponente que bloqueou terá seu [Bloqueio] reduzido em 6.4%. Este efeito dura até a bola cruzar a rede duas vezes.",
    img:"img/memories/MemoWS.png"
  },
  {
    id:"mem_s",
    name:"Memória de S",
    positions:["S"],
    bonus:{
      Serve:{flat:663}, Spike:{flat:518}, Set:{flat:663},
      Receive:{flat:490}, Block:{flat:605}, Save:{flat:461}
    },
    desc:"Enquanto houver um membro com esta memória em quadra, o [Passe] dos aliados aumenta em 8%. Uma vez por set, quando a Stamina de um membro cair abaixo de 30, a Stamina desse membro será restaurada em 24.",
    img:"img/memories/MemoS.png"
  },
  {
    id:"mem_mb",
    name:"Memória de MB",
    positions:["MB"],
    bonus:{
      Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461},
      Receive:{flat:518}, Block:{flat:663}, Save:{flat:490}
    },
    desc:"O [Ataque Rápido] do membro que equipa esta memória é aumentado em 12%. Para cada membro de Bloqueio na linha de frente do oponente, o [Ataque Rápido] desse membro aumenta em mais 6.4%.",
    img:"img/memories/MemoMB.png"
  },
  {
    id:"mem_up_consciencia_wakatoshi_ushijima",
    name:"Ushijima UR",
    positions:["OP"],
    bonus:{
      Serve:{flat:570}, Spike:{flat:729}, Set:{flat:507},
      Receive:{flat:729}, Block:{flat:665}, Save:{flat:539}
    },
    desc:"A [Percepção] do membro que equipa esta memória é aumentada em 20%. Se a [Percepção] do membro exceder 20%, para cada 1% adicional de [Percepção], a [Força] aumenta em 1% (até 100%).",
    img:"img/memories/MemoUshijimaUR.png"
  },
  {
    id:"mem_ofensive_up_osamu_miya",
    name:"Osamu UR",
    positions:["OP"],
    bonus:{
      Serve:{flat:570}, Spike:{flat:729}, Set:{flat:507},
      Receive:{flat:729}, Block:{flat:665}, Save:{flat:539}
    },
    desc:"O [Ataque Rápido] do membro que equipa esta memória é aumentado em 24%. Se a [Técnica de Ataque] do membro exceder 40%, o [Ataque Rápido] aumenta em 48% × [Ataque Rápido].",
    img:"img/memories/MemoOsamuUR.png"
  },
  {
    id:"mem_receba_reforco_hard_hit_daichi_sawamura",
    name:"Daichi SSR",
    positions:["OP"],
    bonus:{
      Serve:{flat:518}, Spike:{flat:663}, Set:{flat:461},
      Receive:{flat:663}, Block:{flat:605}, Save:{flat:490}
    },
    desc:"A [Recepção] do membro que equipa esta memória é aumentada em 20%. Se o membro estiver em quadra, ganhe 1 acúmulo de [Determinação] sempre que um aliado do tipo Força consumir 20 de Stamina. Cada acúmulo aumenta o poder do Ataque Potente em 4% do atributo [Ataque Potente], até 10 acúmulos.",
    img:"img/memories/MemoDaichiSSR.png"
  },
  {
    id:"mem_reacao_para_cima_akinori_konoha",
    name:"Konoha SSR",
    positions:["OP"],
    bonus:{
      Serve:{flat:518}, Spike:{flat:663}, Set:{flat:461},
      Receive:{flat:663}, Block:{flat:605}, Save:{flat:490}
    },
    desc:"Os Parâmetros Principais dos membros que equipam esta memória aumentam em 12%. O [Reflexo] do membro eleva a Moral da Equipe dos aliados em 10%. Enquanto um aliado estiver com [Despertar de Moral da Equipe] ativo, o [Reflexo] desse membro aumenta em 8%.",
    img:"img/memories/MemoKonohaSSR.png"
  },
  {
    id:"mem_ofensive_up_kentaro_kyotani",
    name:"Kentaro MAD DOG SSR",
    positions:["OP"],
    bonus:{
      Serve:{flat:518}, Spike:{flat:663}, Set:{flat:461},
      Receive:{flat:663}, Block:{flat:605}, Save:{flat:490}
    },
    desc:"Se o membro com esta memória estiver em quadra, a [Força] do aliado que estiver atacando aumenta em 12%. Enquanto o membro estiver em quadra e a Stamina do oponente estiver abaixo de 60, o [Bloqueio] do oponente é reduzido em 16%. Este efeito dura até a bola cruzar a rede 3 vezes e pode ser ativado uma vez por set por membro.",
    img:"img/memories/MemoKentaroSSR.png"
  },
  {
    id:"mem_param_main_e_hard_hit_takehito_sasaya",
    name:"Sasaya SSR",
    positions:["OP"],
    bonus:{
      Serve:{flat:518}, Spike:{flat:663}, Set:{flat:461},
      Receive:{flat:663}, Block:{flat:605}, Save:{flat:490}
    },
    desc:"O [Ataque Potente] e o [Bloqueio] dos membros que equipam esta memória aumentam em 12%. Se o placar estiver favorável ao oponente, o poder do seu Spike aumenta em 28% × [Ataque Potente].",
    img:"img/memories/MemoSasayaSSR.png"
  },
  {
    id:"mem_defense_up_yu_nishinoya_depois_da_escola",
    name:"Nishinoya SP",
    positions:["L"],
    bonus:{
      Serve:{flat:619}, Spike:{flat:656}, Set:{flat:765},
      Receive:{flat:838}, Block:{flat:583}, Save:{flat:838}
    },
    desc:"O membro que equipa esta memória tem sua [Recepção] aumentada em 24%. Quando a Habilidade Especial do respectivo membro é ativada, o [Reflexo] aumenta em 1.2% e o [Empenho] aumenta em 2.4% (até 5 acúmulos). Se o membro usar uma Habilidade Especial mais de duas vezes durante um rali, ele recupera 10 de Stamina e, na próxima Habilidade Especial que usar, sua [Técnica de Defesa] aumenta em 16%. Este efeito dura até a bola cruzar a rede duas vezes.",
    img:"img/memories/MemoNishinoyaSP.png"
  },
  {
    id:"mem_defense_offensive_up_motoya_komori",
    name:"Komori UR",
    positions:["L"],
    bonus:{
      Serve:{flat:619}, Spike:{flat:656}, Set:{flat:838},
      Receive:{flat:838}, Block:{flat:583}, Save:{flat:765}
    },
    desc:"O membro que equipa esta memória tem sua [Recepção] aumentada em 24%. Quando o respectivo membro recebe, a [Técnica de Defesa] dos aliados na retaguarda aumenta em 2% (até 3 acúmulos). Se o membro estiver em quadra, quando um aliado ativar uma habilidade de Recepção, quem receber recupera 2 de Stamina e tem seu [Ataque Potente/Ataque Rápido] aumentado em 15%. Este efeito dura até a bola cruzar a rede duas vezes.",
    img:"img/memories/MemoKomoriUR.png"
  },
  {
    id:"mem_defense_up_yu_nishinoya",
    name:"Nishinoya SSR",
    positions:["L"],
    bonus:{
      Serve:{flat:490}, Spike:{flat:518}, Set:{flat:605},
      Receive:{flat:663}, Block:{flat:461}, Save:{flat:663}
    },
    desc:"Se o membro que equipa esta memória estiver em quadra, aumenta a [Defesa] dos jogadores da linha de trás do seu lado em 8%. Se o consumo de Stamina do equipador for 8 ou mais ao ativar a habilidade de recepção, a [Recepção] do equipador aumenta em 20% e ele recupera 2 de Stamina.",
    img:"img/memories/MemoNishinoyaSSR.png"
  },
  {
    id:"mem_receba_morisuke_yaku",
    name:"Yaku SSR",
    positions:["L"],
    bonus:{
      Serve:{flat:490}, Spike:{flat:518}, Set:{flat:605},
      Receive:{flat:663}, Block:{flat:461}, Save:{flat:663}
    },
    desc:"Quando um membro com esta memória recebe, a [Recepção] aumenta em 4% (até 5 acúmulos). Se a recepção do membro for PERFECT, o poder do próximo Ataque Rápido de um aliado aumenta em 32% × [Ataque Rápido] do membro que executará o ataque rápido.",
    img:"img/memories/MemoYakuSSR.png"
  },
  {
    id:"mem_receba_haruki_komi",
    name:"Haruki SSR",
    positions:["L"],
    bonus:{
      Serve:{flat:490}, Spike:{flat:518}, Set:{flat:605},
      Receive:{flat:663}, Block:{flat:461}, Save:{flat:663}
    },
    desc:"A [Recepção] e a [Defesa] dos membros que equipam esta memória aumentam em 16%. Se a recepção ou a defesa do membro não for BAD, a Moral da Equipe aumenta em 10. Além disso, o poder do próximo Ataque Potente de um aliado aumenta em 10% × [Ataque Potente] do membro.",
    img:"img/memories/MemoHarukiSSR.png"
  },
  {
    id:"mem_receba_yamagata_hayato",
    name:"Memo Yamagata SSR",
    positions:["L"],
    bonus:{
      Serve:{flat:490}, Spike:{flat:518}, Set:{flat:605},
      Receive:{flat:663}, Block:{flat:461}, Save:{flat:663}
    },
    desc:"A [Recepção] do membro que equipa esta memória é aumentada em 20%. Quando o membro ativa a Habilidade Especial de Recepção, o [Reflexo] aumenta em 12%.",
    img:"img/memories/MemoYamagataSSR.png"
  },
  {
    id:"mem_defense_up_michinari_akagi",
    name:"Memo Akagi SSR",
    positions:["L"],
    bonus:{
      Serve:{flat:490}, Spike:{flat:518}, Set:{flat:605},
      Receive:{flat:663}, Block:{flat:461}, Save:{flat:663}
    },
    desc:"A [Recepção] do membro que equipa esta memória é aumentada em 20%. Se o resultado de recepção ou defesa do membro não for BAD, a [Técnica de Defesa] do aliado aumenta em 16% (até 3 acúmulos). Este efeito dura por 1 rali.",
    img:"img/memories/MemoAkagiSSR.png"
  },
  {
    id:"mem_power_up_shouyou_hinata_hanami",
    name:"Hinata SP",
    positions:["MB"],
    bonus:{ Serve:{flat:619}, Spike:{flat:838}, Set:{flat:656}, Receive:{flat:838}, Block:{flat:765}, Save:{flat:583} },
    desc:"A [Força] do membro que equipa esta memória aumenta em 24%. Se o Ataque Rápido do membro for PERFECT, aumente a [Força] do membro em 2% (até 5 acúmulos). Se o Ataque Rápido de um aliado for PERFECT e o bloqueador oponente não tocar na bola, a [Reflexo] e o [Empenho] da linha de frente inimiga serão reduzidos em 8% cada. Este efeito dura até a bola cruzar a rede 10 vezes.",
    img:"img/memories/MemoHinataSP.png"
  },
  {
    id:"mem_hast_attack_block_up_Tsuki_firefly_display_de_fogos_de_artificio",
    name:"Tsuki SP",
    positions:["MB"],
    bonus:{ Serve:{flat:619}, Spike:{flat:838}, Set:{flat:656}, Receive:{flat:765}, Block:{flat:838}, Save:{flat:583} },
    desc:"O [Ataque Rápido] do membro que equipa esta memória aumenta em 24%. Se o membro fizer um PERFECT, o [Bloqueio] aumenta em 9% (até 3 acúmulos). Aplica aleatoriamente o efeito negativo [Supressão] a um membro do time adversário em quadra (Parâmetros Principais reduzidos em 5%). Este efeito dura até a bola cruzar a rede 8 vezes.",
    img:"img/memories/MemoTsukiSP.png"
  },
  {
    id:"mem_kurosp",
    name:"Kuroo SP",
    positions:["MB"],
    bonus:{ Serve:{flat:765}, Spike:{flat:656}, Set:{flat:619}, Receive:{flat:838}, Block:{flat:838}, Save:{flat:583} },
    desc:"O [Bloqueio] aumenta em 12%. Quando o membro bloquear ou receber, se houver um inimigo em quadra com efeito negativo, a [Técnica de Defesa] do respectivo membro aumenta em 20%. Este efeito dura até a bola cruzar a rede quatro vezes.",
    img:"img/memories/MemoKuroSP.png"
  },
  {
    id:"mem_tecnica_de_defesa_bloqueio_takashi_aone_banho_de_mar",
    name:"Aone SP",
    positions:["MB"],
    bonus:{ Serve:{flat:838}, Spike:{flat:765}, Set:{flat:656}, Receive:{flat:619}, Block:{flat:838}, Save:{flat:583} },
    desc:"A [Técnica de Defesa] do membro que equipa esta memória aumenta em 12.8%. Quando este membro participa de um bloqueio de 2 ou 3 jogadores, o [Bloqueio] da linha de frente aliada aumenta em 12% até a bola cruzar a rede duas vezes. Quando o membro bloquear, se a jogada resultar em bloqueio de 2/3, o [Bloqueio] do membro aumenta em mais 15% até a bola cruzar a rede duas vezes.",
    img:"img/memories/MemoAoneSP.png"
  },
  {
    id:"mem_hast_attack_blockup_tetsuro_kuroo",
    name:"Kuroo UR",
    positions:["MB"],
    bonus:{ Serve:{flat:665}, Spike:{flat:729}, Set:{flat:507}, Receive:{flat:570}, Block:{flat:729}, Save:{flat:539} },
    desc:"O membro que equipa esta memória tem seu [Bloqueio] aumentado em 24%. Cada vez que o membro receber um aumento de [Ataque Rápido] proveniente de uma habilidade de aliado, ganha 1 acúmulo de [Ajuste]. Cada acúmulo de [Ajuste] aumenta o [Bloqueio] em 2.4% (máx. 10). Quando a Habilidade Especial de Bloqueio do membro for ativada, consuma 10 acúmulos do efeito [Constrição] e reduza a recarga da Habilidade Especial de Bloqueio do membro em 10 cruzadas de rede.",
    img:"img/memories/MemoKuroUR.png"
  },
  {
    id:"mem_block_up_hirugami_yukoro",
    name:"Hirugami UR",
    positions:["MB"],
    bonus:{ Serve:{flat:729}, Spike:{flat:665}, Set:{flat:507}, Receive:{flat:570}, Block:{flat:729}, Save:{flat:539} },
    desc:"O membro que equipa esta memória tem seu [Bloqueio] aumentado em 20%. Quando um aliado pontua, o [Bloqueio] dele aumenta em 4.8% (até 3 acúmulos). Se um aliado possuir o efeito [Bloqueio Forte], ao bloquear sua [Técnica de Defesa] aumenta em 2.4% até a bola cruzar a rede quatro vezes (até 3 acúmulos).",
    img:"img/memories/MemoHirugamiUR.png"
  },
  {
    id:"mem_increase_consciousness_shoyo_hinata",
    name:"Hinata SSR",
    positions:["MB"],
    bonus:{ Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461}, Receive:{flat:518}, Block:{flat:663}, Save:{flat:490} },
    desc:"A [Percepção] dos membros que equipam esta memória aumenta em 16%. Se a [Percepção] do membro for 40% ou maior, a [Percepção] aumenta em mais 16% e sofrer bloqueio é reduzido em 8%.",
    img:"img/memories/MemoHinataSSR.png"
  },
  {
    id:"mem_block_up_Tsuki",
    name:"Tsuki SSR",
    positions:["MB"],
    bonus:{ Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461}, Receive:{flat:518}, Block:{flat:663}, Save:{flat:490} },
    desc:"O [Bloqueio] do membro que equipa esta memória aumenta em 20%. Quando o membro ativa a Habilidade Especial de Bloqueio, se o oponente que realizou o spike (Ataque Potente/Rápido) tiver um efeito negativo, o poder deste bloqueio aumenta em 32% × [Bloqueio] do membro.",
    img:"img/memories/MemoTsukiSSR.png"
  },
  {
    id:"mem_offensive_up_tetsuro_kuroo_pratica",
    name:"Kuroo SSR",
    positions:["MB"],
    bonus:{ Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461}, Receive:{flat:518}, Block:{flat:663}, Save:{flat:490} },
    desc:"A [Percepção] dos membros que equipam esta memória aumenta em 16%. Quando o membro for bloqueado, sua [Técnica de Defesa] aumenta em 24% da sua [Força].",
    img:"img/memories/MemoKuroSSR.png"
  },
  {
    id:"mem_block_up_tatsuo",
    name:"Tatsuo SSR",
    positions:["MB"],
    bonus:{ Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461}, Receive:{flat:518}, Block:{flat:663}, Save:{flat:490} },
    desc:"O [Bloqueio] do membro que equipa esta memória aumenta em 24%. Quando o membro bloquear, se o spike do oponente (potente/rápido) for PERFECT, este bloqueio será garantidamente PERFECT. Se o resultado deste bloqueio não for BAD, o [Bloqueio] do membro aumenta em 5% (até 3 acúmulos).",
    img:"img/memories/MemoTatsuoSSR.png"
  },
  {
    id:"mem_receive_up_ataque_rapido_reforco_haiba_lev",
    name:"Lev SSR",
    positions:["MB"],
    bonus:{ Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461}, Receive:{flat:518}, Block:{flat:663}, Save:{flat:490} },
    desc:"Se o membro que equipa esta memória estiver em quadra, a [Recepção] dos defensores aliados aumenta em 12%. Se o membro estiver em quadra e o resultado da recepção aliada for PERFECT, o poder da próxima Habilidade Especial de Ataque Rápido do membro aumenta em 24% × [Ataque Rápido].",
    img:"img/memories/MemoLevSSR.png"
  },
  {
    id:"mem_defense_up_takanobu_aone",
    name:"Aone SSR",
    positions:["MB"],
    bonus:{ Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461}, Receive:{flat:518}, Block:{flat:663}, Save:{flat:490} },
    desc:"A [Técnica de Defesa] dos membros que equipam esta memória aumenta em 16%. Se o resultado de bloqueio do membro não for BAD, a Stamina do oponente é reduzida em 2 após o spike (potente/rápido). Se o atacante oponente for um membro de Ataque Potente, ele perde mais 1 de Stamina.",
    img:"img/memories/MemoAoneSSR.png"
  },
  {
    id:"mem_block_up_tendo_satoru",
    name:"Tendo SSR",
    positions:["MB"],
    bonus:{ Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461}, Receive:{flat:518}, Block:{flat:663}, Save:{flat:490} },
    desc:"O [Bloqueio] do membro que equipa esta memória aumenta em 28%. Se o bloqueio do membro for PERFECT, a recarga da Habilidade Especial de Bloqueio é reduzida em 3 cruzadas de rede.",
    img:"img/memories/MemoTendoSSR.png"
  },
  {
    id:"mem_fast_attack_up_rintaro_suna",
    name:"Rintaro SSR",
    positions:["MB"],
    bonus:{ Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461}, Receive:{flat:518}, Block:{flat:663}, Save:{flat:490} },
    desc:"O [Ataque Rápido] do membro que equipa esta memória aumenta em 20%. Se o bloqueador oponente tiver um efeito negativo quando o membro atacar rapidamente, o poder deste Ataque Rápido aumenta em 40% × [Ataque Rápido] do membro.",
    img:"img/memories/MemoRintaroSSR.png"
  },
  {
id:"mem_akaashi_sp",
name:"Akaashi SP",
positions:["S"],
bonus:{ Serve:{flat:838}, Spike:{flat:656}, Set:{flat:838}, Receive:{flat:619}, Block:{flat:765}, Save:{flat:583} },
desc:"O [Passe] do equipador aumenta em 24%. Enquanto o [Despertar de Moral da Equipe] de um aliado estiver ativo, a [Percepção] do equipador aumenta em 10%. Aliados com o efeito [Condição Excelente] recebem +15% em seus Parâmetros Principais. Quando um aliado perde o efeito [Condição Excelente], o [Reflexo] de todos os aliados aumenta em 10% até a bola cruzar a rede 8 vezes.",
img:"img/memories/MemoAkaashiSP.png"
},
  {
id:"mem_sugawara_sp",
name:"Sugawara SP",
positions:["S"],
bonus:{ Serve:{flat:838}, Spike:{flat:656}, Set:{flat:838}, Receive:{flat:619}, Block:{flat:765}, Save:{flat:583} },
desc:"Os Parâmetros Principais do equipador aumentam em 16%. Quando o equipador realiza um Passe, para cada 6 de Stamina atual que possuir, o [Ataque Potente/Ataque Rápido] do atacante aumenta em 2% (até 30%). Este efeito dura até a bola cruzar a rede duas vezes. Quando o equipador ativa uma Habilidade e consome Stamina, restaure 10 de Stamina ao aliado com a menor Stamina.",
img:"img/memories/MemoSugawaraSP.png"
},
  {
id:"mem_kenma_sp",
name:"Kenma SP",
positions:["S"],
bonus:{ Serve:{flat:765}, Spike:{flat:656}, Set:{flat:838}, Receive:{flat:838}, Block:{flat:619}, Save:{flat:583} },
desc:"O [Reflexo] aumenta em 16%. Quando um Ataque Potente/Rápido do oponente for PERFECT, um aliado que ativar uma habilidade de Bloqueio ou Recepção ganha 1 acúmulo de [Adesão]; para cada acúmulo, o [Reflexo] aumenta em 4% (máx. 3). Se tal aliado atingir 3 acúmulos, consuma-os para aumentar em 100% o [Reflexo] desse aliado até a bola cruzar a rede uma vez.",
img:"img/memories/MemoKenmaSP.png"
},
  {
id:"mem_oikawa_ur",
name:"Oikawa UR",
positions:["S"],
bonus:{ Serve:{flat:729}, Spike:{flat:570}, Set:{flat:729}, Receive:{flat:539}, Block:{flat:665}, Save:{flat:507} },
desc:"O [Saque] aumenta em 24%. Quando o saque deste membro for [PERFECT], ganhe 2 acúmulos de [Ritmo de Ataque]. Para cada acúmulo, aliados em quadra recebem +1% de [Percepção], até 10 acúmulos. Se o saque resultar em ace, ganhe 4 acúmulos adicionais. Enquanto este membro estiver em quadra, cada vez que o [Ritmo de Ataque] atingir 6 acúmulos, a [Força] e o [Empenho] dos aliados aumentam em 4% (até 3 acúmulos).",
img:"img/memories/MemoOikawaUR.png"
},
  {
id:"mem_kageyama_ur",
name:"Kageyama UR",
positions:["S"],
bonus:{ Serve:{flat:729}, Spike:{flat:570}, Set:{flat:729}, Receive:{flat:539}, Block:{flat:665}, Save:{flat:507} },
desc:"O [Passe] aumenta em 24%. Quando este membro ativar uma habilidade de Ataque de Dois Toques, sua [Força] aumenta em 40% da [Percepção], até +100%. Além disso, quando este membro ativar uma habilidade de Dois Toques, o poder do próximo Spike aliado (Potente/Rápido) aumenta em 28% do [Ataque Potente/Ataque Rápido] do atacante.",
img:"img/memories/MemoKageyamaUR.png"
},
  {
id:"mem_atsumu_ur",
name:"Atsumu UR",
positions:["S"],
bonus:{ Serve:{flat:729}, Spike:{flat:570}, Set:{flat:729}, Receive:{flat:539}, Block:{flat:665}, Save:{flat:507} },
desc:"O [Passe] aumenta em 24%. Enquanto o equipador estiver em quadra, aliados em quadra cuja [Percepção] e [Reflexo] estejam abaixo de 20% recebem +6.4% em [Técnica de Ataque] e [Técnica de Defesa]. Se a jogada de um aliado não for [PERFECT], a [Técnica de Ataque] e a [Técnica de Defesa] do equipador aumentam em 2% por acúmulo (máx. 5), durando por 1 rali.",
img:"img/memories/MemoAtsumuUR.png"
},
  {
id:"mem_kageyama_ssr_serve",
name:"Kageyama SSR",
positions:["S"],
bonus:{ Serve:{flat:663}, Spike:{flat:518}, Set:{flat:663}, Receive:{flat:490}, Block:{flat:605}, Save:{flat:461} },
desc:"O [Saque] aumenta em 20%. Quando este membro ativar um Supremo de Dois Toques, a [Percepção] dos aliados aumenta em 20% e a [Percepção] deste membro aumenta em mais 15%.",
img:"img/memories/MemoKageyamaSSR.png"
},
  {
id:"mem_kenma_ssr",
name:"Kenma SSR",
positions:["S"],
bonus:{ Serve:{flat:663}, Spike:{flat:518}, Set:{flat:663}, Receive:{flat:490}, Block:{flat:605}, Save:{flat:461} },
desc:"O [Passe] aumenta em 8%. Enquanto o equipador estiver em quadra, a [Recepção] dos aliados da linha de trás aumenta em 12%. Enquanto o equipador estiver em quadra, quando as pilhas de [Conexão] de um aliado diminuírem, os aliados ganham 1 acúmulo de [Conexão]; para cada acúmulo, aliados em quadra recebem +1% de [Recepção], até 6 acúmulos.",
img:"img/memories/MemoKenmaSSR.png"
},
  {
id:"mem_akaashi_ssr",
name:"Akaashi SSR",
positions:["S"],
bonus:{ Serve:{flat:663}, Spike:{flat:518}, Set:{flat:663}, Receive:{flat:490}, Block:{flat:605}, Save:{flat:461} },
desc:"O [Passe] aumenta em 12%. Enquanto o [Despertar de Moral da Equipe] de um aliado estiver ativo, quando este membro realizar um Passe, o aliado que for atacar (Potente/Rápido) recupera 4 de Stamina e esse Spike recebe +16% de [Técnica de Ataque]. Quando este membro dissipar um debuff de um aliado, também remove o efeito [Modo de Baixa] desse aliado.",
img:"img/memories/MemoAkaashiSSR.png"
},
  {
id:"mem_oikawa_ssr",
name:"Oikawa SSR",
positions:["S"],
bonus:{ Serve:{flat:663}, Spike:{flat:518}, Set:{flat:663}, Receive:{flat:490}, Block:{flat:605}, Save:{flat:461} },
desc:"O [Passe] aumenta em 20%. Na primeira vez em cada set que o [Ritmo de Ataque] dos aliados atingir 10 ou mais acúmulos, o [Passe] deste membro aumenta em mais 20% (dura 1 set). Para cada acúmulo de [Ritmo de Ataque], aliados em quadra recebem +1% de [Percepção], até 10 acúmulos.",
img:"img/memories/MemoOikawaSSR.png"
},
  {
id:"mem_koganegawa_ssr",
name:"Koganegawa SSR",
positions:["S"],
bonus:{ Serve:{flat:663}, Spike:{flat:518}, Set:{flat:663}, Receive:{flat:490}, Block:{flat:605}, Save:{flat:461} },
desc:"O [Passe] aumenta em 16%. Enquanto o equipador estiver em quadra, se o resultado de Bloqueio de um aliado não for [BAD], o poder do próximo Ataque Potente do oponente diminui em 20% do atributo [Ataque Potente] do atacante. Enquanto o equipador estiver em quadra, se o resultado de Bloqueio de um aliado for [BAD], o poder do próximo Bloqueio aliado aumenta em 32% do [Bloqueio] do bloqueador.",
img:"img/memories/MemoKoganegawaSSR.png"
},
  {
id:"mem_shirabu_ssr",
name:"Shirabu SSR",
positions:["S"],
bonus:{ Serve:{flat:663}, Spike:{flat:518}, Set:{flat:663}, Receive:{flat:490}, Block:{flat:605}, Save:{flat:461} },
desc:"O [Passe] aumenta em 16%. Quando o Passe deste membro for [PERFECT], o aliado que executar um Ataque Potente recebe +32% de [Força] até a bola cruzar a rede uma vez.",
img:"img/memories/MemoShirabuSSR.png"
},
  {
id:"mem_semi_ssr",
name:"Semi SSR",
positions:["S"],
bonus:{ Serve:{flat:663}, Spike:{flat:518}, Set:{flat:663}, Receive:{flat:490}, Block:{flat:605}, Save:{flat:461} },
desc:"Quando este membro sacar, a [Percepção] aumenta em 16%. Ao ativar um Supremo de Saque, o [Saque] aumenta em 6.4%, até 3 acúmulos.",
img:"img/memories/MemoSemiSSR.png"
},
    {
    id:"mem_bokuto_sp",
    name:"Bokuto SP",
    positions:["WS"],
    bonus:{ Serve:{flat:765}, Spike:{flat:838}, Set:{flat:583}, Receive:{flat:838}, Block:{flat:656}, Save:{flat:619} },
    desc:"A [Força] do membro que equipa esta memória aumenta em 24%. Quando o membro atacar com força, a [Técnica de Ataque] aumenta em 5%. Se a duração restante do [Despertar de Moral da Equipe] de um aliado for de 6 ou mais cruzadas de rede, a [Técnica de Ataque] aumenta em mais 20%.",
    img:"img/memories/MemoBokutoSP.png"
},
  {
    id:"mem_offense_defense_up_hoshiumi_ur",
    name:"Hoshiumi UR",
    positions:["WS"],
    bonus:{ Serve:{flat:665}, Spike:{flat:729}, Set:{flat:507}, Receive:{flat:729}, Block:{flat:570}, Save:{flat:539} },
    desc:"A [Técnica de Ataque] e a [Técnica de Defesa] aumentam em 6.4%. Quando a Habilidade/Habilidade Especial do membro é ativada, seus [Parâmetros Principais] aumentam em 2% (máx. 10 acúmulos). Se a jogada for [PERFECT], ganhe 1 acúmulo adicional.",
    img:"img/memories/MemoHoshiumiUR.png"
},
  {
    id:"mem_bokuto_ur",
    name:"Bokuto UR",
    positions:["WS"],
    bonus:{ Serve:{flat:665}, Spike:{flat:729}, Set:{flat:507}, Receive:{flat:729}, Block:{flat:570}, Save:{flat:539} },
    desc:"O membro que equipa esta memória tem seu [Ataque Potente] aumentado em 24%. Cada vez que um aliado ativar o [Despertar de Moral da Equipe], o [Ataque Potente] desse membro aumenta em 8% (até 3 acúmulos). Enquanto o membro estiver em quadra, a duração do bônus de Moral da Equipe dos aliados é aumentada em 2 cruzadas de rede.",
    img:"img/memories/MemoBokutoUR.png"
    },
  {
    id:"mem_Sakusa_ur",
    name:"Sakusa UR",
    positions:["WS"],
    bonus:{ Serve:{flat:765}, Spike:{flat:838}, Set:{flat:583}, Receive:{flat:838}, Block:{flat:656}, Save:{flat:619} },
    desc:"O membro que equipa esta memória tem seu [Ataque Potente] aumentado em 24%. Quando o membro receber, a [Técnica de Ataque] aumenta em 15% até a bola cruzar a rede duas vezes. Após receber, o [Empenho] do membro aumenta em 8% (até 4 acúmulos).",
    img:"img/memories/MemoSakusaUR.png"
    },
   {
    id:"mem_yui_ssr",
    name:"Yui SSR",
    positions:["WS"],
    bonus:{ Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461}, Receive:{flat:663}, Block:{flat:518}, Save:{flat:490} },
    desc:"A [Recepção] aumenta em 20%. Quando este membro receber, o [Ataque Potente] aumenta em 16% e dura até a bola cruzar a rede seis vezes. Se a recepção deste membro for [PERFECT], seu próximo Ataque Potente será garantidamente [PERFECT].",
    img:"img/memories/MemoYuiSSR.png"
    },
   {
    id:"mem_oshiro_ssr",
    name:"Oshiro SSR",
    positions:["WS"],
    bonus:{ Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461}, Receive:{flat:663}, Block:{flat:518}, Save:{flat:490} },
    desc:"O [Ataque Potente] aumenta em 20%. Para cada 6 de Stamina recuperada por este membro, o [Ataque Potente] aumenta em 6.3%. Este efeito dura até a bola cruzar a rede cinco vezes. Se a Stamina recuperada em uma única instância exceder 10, a [Técnica de Ataque] aumenta em 6.4% até a bola cruzar a rede cinco vezes.",
    img:"img/memories/MemoOshiroSSR.png"
},
    {
    id:"mem_kita_ssr",
    name:"Kita SSR",
    positions:["WS"],
    bonus:{ Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461}, Receive:{flat:663}, Block:{flat:518}, Save:{flat:490} },
    desc:"A [Recepção] aumenta em 20%. Se a recepção deste membro não for [PERFECT], o poder da próxima recepção de um aliado aumenta em 40% da [Recepção] do membro que receber.",
    img:"img/memories/MemoKitaSSR.png"
},
    {
    id:"mem_tanaka_ssr",
    name:"Tanaka SSR",
    positions:["WS"],
    bonus:{ Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461}, Receive:{flat:663}, Block:{flat:518}, Save:{flat:490} },
    desc:"O [Ataque Potente] aumenta em 20%. Para este membro, até o segundo Ataque Potente de cada set, o poder de finalização aumenta em 36% do [Ataque Potente].",
    img:"img/memories/MemoTanakaSSR.png"
},
    {
id:"mem_azumane_ssr",
name:"Azumane SSR",
positions:["WS"],
bonus:{ Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461}, Receive:{flat:663}, Block:{flat:518}, Save:{flat:490} },
desc:"Se o membro que equipa esta memória tiver 50 ou mais de Stamina, o [Ataque Potente] aumenta em 36%. Quando este membro ativar uma habilidade de Ataque Potente e a Stamina consumida for 20 ou mais, o poder desse Ataque Potente aumenta em 32% do [Ataque Potente].",
img:"img/memories/MemoAzumaneSSR.png"
},
    {
id:"mem_iwaizumi_ssr",
name:"Iwaizumi SSR",
positions:["WS"],
bonus:{ Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461}, Receive:{flat:663}, Block:{flat:518}, Save:{flat:490} },
desc:"Exclusivo de [WS]: aumenta a [Recepção] em 10%. Quando o equipador executar um Supremo de Ataque Potente Crítico, aumenta o [Ataque Potente] em 8% da [Recepção] por 3 cruzadas de rede.",
img:"img/memories/MemoIwaizumiSSR.png"
},
    {
id:"mem_futakuchi_ssr",
name:"Futakuchi SSR",
positions:["WS"],
bonus:{ Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461}, Receive:{flat:663}, Block:{flat:518}, Save:{flat:490} },
desc:"O [Bloqueio] aumenta em 20%. Para cada aliado do tipo Bloqueio em quadra, o poder de finalização da Habilidade Especial deste membro aumenta em 6.4% do parâmetro correspondente a essa Especial.",
img:"img/memories/MemoFutakuchiSSR.png"
},
    {
id:"mem_goshiki_ssr",
name:"Goshiki SSR",
positions:["WS"],
bonus:{ Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461}, Receive:{flat:663}, Block:{flat:518}, Save:{flat:490} },
desc:"O [Ataque Potente] aumenta em 20%. Enquanto o [Despertar de Moral da Equipe] de um aliado estiver ativo, o [Ataque Potente] deste membro aumenta em 32%.",
img:"img/memories/MemoGoshikiSSR.png"
},
    {
id:"mem_awareness_reaction_up_oshiro_ssr",
name:"Oshiro SSR",
positions:["WS"],
bonus:{ Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461}, Receive:{flat:663}, Block:{flat:518}, Save:{flat:490} },
desc:"Quando este membro ativar uma Habilidade, a [Percepção] aumenta em 3.2% e o [Reflexo] aumenta em 3.2%, até 5 acúmulos.",
img:"img/memories/MemoOshiroSSR.png"
},
    {
id:"mem_terushima_ssr",
name:"Terushima SSR",
positions:["WS"],
bonus:{ Serve:{flat:605}, Spike:{flat:663}, Set:{flat:461}, Receive:{flat:663}, Block:{flat:518}, Save:{flat:490} },
desc:"O [Ataque Potente] aumenta em 24%. Quando este membro ativar o efeito [Escolha Mais], ganhe 2 acúmulos de [Escolha Mais] e aumente a [Recepção] dos aliados da linha de trás em 12% por 1 rali. Para cada acúmulo de [Escolha Mais], o [Ataque Potente]/[Ataque Rápido] aumenta em 2.5%, até 4 acúmulos.",
img:"img/memories/MemoTerushimaSSR.png"
},
{
    id:"mem_kunimi",
    name:"Kunimi SP",
    positions:["OP"],
    bonus:{
      Serve:{flat:765}, Spike:{flat:838}, Set:{flat:583},
      Receive:{flat:838}, Block:{flat:656}, Save:{flat:619}
    },
    desc:"Enquanto esta memória estiver equipada, o [Ataque Potente] do membro aumenta em 24%.Se a Stamina desse membro estiver abaixo de 80, sua [Técnica de Ataque] aumenta em 12%.Sempre que a Stamina desse membro for recuperada, o [Poder] dele aumenta em 6% (máx. 5 acúmulos).",
    img:"img/memories/MemoKunimiSP.png"
  },
{
    id:"mem_koganegawa",
    name:"Koganegawa SP",
    positions:["S"],
    bonus:{
      Serve:{flat:765}, Spike:{flat:656}, Set:{flat:838},
      Receive:{flat:619}, Block:{flat:838}, Save:{flat:583}
    },
    desc:"O [Bloqueio] do membro que equipa esta memória +24%.Quando esse membro participar de bloqueio duplo ou triplo, o [Levantamento] dele +3% (máx. 5 acúmulos).Enquanto esse membro estiver em quadra, quando um aliado sacar, os aliados da linha de frente recebem [Técnica de Defesa] +16% por 1 rali.",
    img:"img/memories/MemoKoganegawaSP.png"
  },
];

/** Catálogo de SETS (POTENTIAL)  * */
const setCatalog = [
  {
  id:"set_rapid_quick_attack",
  name:"Rapid Quick Attack",
  twoPiece:{ Spike:{ pct:15 } },
  fourPiece:{Spike:{ pct:15 }}, // condicional
  img:"img/sets/rapid_quick_attack.png",
  desc2:"2p: Aumenta o atributo de Ataque Rápido em 15%.",
  desc4:"2p: Aumenta o atributo de Ataque Rápido em 15%. 4p: Cada vez que um Ataque Rápido for usado, aumenta o atributo de Ataque Rápido em 5%, até 5 acúmulos."
},
{
  id:"set_sharp_sense",
  name:"Sharp Sense",
  twoPiece:{ Spike:{ pct:15 } },
  fourPiece:{Spike:{ pct:15 }}, // condicional
  img:"img/sets/sharp_sense.png",
  desc2:"2p: Aumenta o atributo de Ataque Rápido em 15%.",
  desc4:"2p: Aumenta o atributo de Ataque Rápido em 15%. 4p: Aumenta a Percepção em 15%; quando um Ataque Rápido for Crítico, aumenta a Força em 10%."
},
{
  id:"set_power_vibe",
  name:"Power Vibe",
  twoPiece:{ Spike:{ pct:15 } },
  fourPiece:{Spike:{ pct:15 }}, // condicional
  img:"img/sets/power_vibe.png",
  desc2:"2p: Aumenta o atributo de Ataque Potente em 15%.",
  desc4:"2p: Aumenta o atributo de Ataque Potente em 15%. 4p: Aumenta a Percepção em 15%; quando um Ataque Potente for Crítico, aumenta a Força em 10%."
},
{
  id:"set_power_rise",
  name:"Power Rise",
  twoPiece:{ Spike:{ pct:15 } },
  fourPiece:{Spike:{ pct:15 }}, // condicional
  img:"img/sets/power_rise.png",
  desc2:"2p: Aumenta o atributo de Ataque Potente em 15%.",
  desc4:"2p: Aumenta o atributo de Ataque Potente em 15%. 4p: Aumenta a Técnica de Ataque em 10% ao usar Ataque Potente; ao pontuar com Ataque Potente, recupera 5 de Stamina."
},
{
  id:"set_precise_serve",
  name:"Precise Serve",
  twoPiece:{ Set:{ pct:15 } },
  fourPiece:{Set:{ pct:15 }}, // condicional
  img:"img/sets/precise_serve.png",
  desc2:"2p: Aumenta o atributo de Passe em 15%.",
  desc4:"2p: Aumenta o atributo de Passe em 15%. 4p: Os saques nunca falham e a Técnica de Ataque aumenta em 15% ao sacar."
},
{
  id:"set_precise_set",
  name:"Precise Set",
  twoPiece:{ Set:{ pct:15 } },
  fourPiece:{Set:{ pct:15 } }, // condicional
  img:"img/sets/precise_set.png",
  desc2:"2p: Aumenta o atributo de Passe em 15%.",
  desc4:"2p: Aumenta o atributo de Passe em 15%. 4p: Aumenta o poder do passe em 15% do atributo de Passe." 
},
{
  id:"set_precise_block",
  name:"Precise Block",
  twoPiece:{ Block:{ pct:15 } },
  fourPiece:{Block:{ pct:15 }}, // efeito condicional descrito abaixo
  img:"img/sets/precise_block.png",
  desc2:"2p: Aumenta o atributo de Bloqueio em 15%.",
  desc4:"2p: Aumenta o atributo de Bloqueio em 15%. 4p: Ao bloquear um Ataque Potente, aumenta o poder deste bloqueio em 20% do atributo de Bloqueio."
},
{
  id:"set_block_movement",
  name:"Block Movement",
  twoPiece:{ Block:{ pct:15 } },
  fourPiece:{Block:{ pct:15 }}, // efeito condicional descrito abaixo
  img:"img/sets/block_movement.png",
  desc2:"2p: Aumenta o atributo de Bloqueio em 15%.",
  desc4:"2p: Aumenta o atributo de Bloqueio em 15%. 4p: Ao bloquear um ataque com outros jogadores do tipo Bloqueio presentes na linha de frente, aumenta o poder deste bloqueio em 20% do atributo de Bloqueio."
},
 {
    id:"set_assist_receive",
    name:"Assist Receive",
    twoPiece:{ Receive:{ pct:15 } },
    fourPiece:{Receive:{ pct:15 }}, // efeito condicional descrito abaixo
    img:"img/sets/assist_receive.png",
    desc2:"2p: Aumenta o atributo de Recepção em 15%.",
    desc4:"2p: Aumenta o atributo de Recepção em 15%. 4p: Ao obter uma recepção PERFECT, aumenta o poder do próximo Spike do seu lado em 30% do atributo de Ataque Potente/Ataque Rápido do atacante."
  },
  {
    id:"set_supreme_receive",
    name:"Supreme Receive",
    twoPiece:{ Receive:{ pct:15 } },
    fourPiece:{Receive:{ pct:15 }}, // efeito condicional descrito abaixo
    img:"img/sets/supreme_receive.png",
    desc2:"2p: Aumenta o atributo de Recepção em 15%.",
    desc4:"2p: Aumenta o atributo de Recepção em 15%. 4p: Ao receber um Ataque Rápido, aumenta o poder desta recepção em 30% do atributo de Recepção."
  }
];
window.STATS_BONDS = {
  "Aoba Johsai's Sophomore": { "Watari SR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Yahaba SR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Kentaro SSR": "No buff" },
  "Behind the Smile": { "Daichi SSR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Kuro UR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%" },
  "Bench cheer": { "Hisashi R": "Serve +5/7/9/12/15, Serve +1/2/3/4/5%", "Kazuhito R": "Block +5/7/9/12/15, Block +1/2/3/4/5%" },
  "Building Team Chemistry": { "Kageyama SSR": "Serve +5/7/9/12/15, Serve +1/2/3/4/5%", "Tanaka SR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%" },
  "Cannon \\& Iron Wall": { "Azumane SSR": "Power Attack +5/7/9/12/15, Power Attack +1/2/3/4/5%", "Aone SSR": "No buff" },
  "Cannon and Iron Wall": { "Aone SP": "Serve +5/7/9/12/15, Serve +1/2/3/4/5%", "Azumane SSR": "" },
  "Classmates": { "Suna SSR": "Quick Attack +5/7/9/12/15, Quick Attack +1/2/3/4/5%", "Osamu UR": "Block +5/7/9/12/15, Block +1/2/3/4/5%" },
  "Date Kogyo's Captains": { "Kaname SR": "No buff", "Kenji SSR": "Power Attack +5/7/9/12/15, Power Attack +1/2/3/4/5%" },
  "Date Kogyo's Junior": { "Jingo R": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Sakunami R": "Quick Attack +5/7/9/12/15, Quick Attack stat by 6/7/8/9/10%" },
  "Date Kogyo's Setter": { "Kaname SR": "No buff", "Kaji SSR": "Set +5/7/9/12/15, Set +1/2/3/4/5%" },
  "Fated Rivals": { "Oikawa UR": "Toss +5/7/9/12/15, Toss +1/2/3/4/5%", "Ushijima UR": "" },
  "Flexible Aces": { "Hinata SSR": "Block +5/7/9/12/15, Block +1/2/3/4/5%", "Lev SSR": "Quick Attack +5/7/9/12/15, Quick Attack +1/2/3/4/5%" },
  "Formidable Opponent": { "Nishinoya SR": "Save +5/7/9/12/15, Save +1/2/3/4/5%", "Yaku SR": "Set +5/7/9/12/15, Set +1/2/3/4/5%" },
  "Friends from Volleyball Class": { "Atsumu UR": "Serve +5/7/9/12/15, Serve +1/2/3/4/5%", "Osamu UR": "Quick Attack +5/7/9/12/15, Quick Attack +1/2/3/4/5%", "Ojiro SSR": "Power Attack +5/7/9/12/15, Power Attack +1/2/3/4/5%" },
  "Fukurodani 3rd Years": { "Bokuto UR": "", "Komi SR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Konoha": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Sarukui SSR": "Power +5/7/9/12/15, Power +1/2/3/4/5%", "Washio SSR": "Block +5/7/9/12/15, Block +1/2/3/4/5%" },
  "Fukurodani MBs": { "Washio SSR": "Quick Attack +5/7/9/12/15, Quick Attack +1/2/3/4/5%", "Onaga R": "" },
  "Fukurodani WS": { "Bokuto UR": "", "Sarukui": "Serve +5/7/9/12/15, Serve +1/2/3/4/5%" },
  "Grit and Competitive": { "Yamamoto SR": "No buff", "Kenma SSR": "Set +5/7/9/12/15, Set +1/2/3/4/5%" },
  "Hidden Fire": { "Kentaro SSR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Yahaba SR": "No buff" },
  "Inarizaki 2nd Years": { "Suna SSR": "Quick Spike +5/7/9/12/15, Quick Spike +1/2/3/4/5%", "Ginjima SSR": "Power Spike +5/7/9/12/15, Power Spike +1/2/3/4/5%", "Osamu UR": "Quick Spike +5/7/9/12/15, Quick Spike +1/2/3/4/5%", "Atsumu UR": "", "Kosaku R": "" },
  "Inarizaki WS Teammates": { "Kita SSR": "Cover +5/7/9/12/15, Cover +1/2/3/4/5%", "Ojiro SSR": "Serve +5/7/9/12/15, Serve +1/2/3/4/5%", "Ginjima SSR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Kosaku R": "Serve +5/7/9/12/15, Serve +1/2/3/4/5%", "Riseki R": "Serve +5/7/9/12/15, Serve +1/2/3/4/5%" },
  "Japan Youth Training Camp Teammates": { "Kageyama UR": "", "Atsumu UR": "Toss +5/7/9/12/15, Toss +1/2/3/4/5%", "Sakusa UR": "Strong Spike +5/7/9/12/15, Strong Spike +1/2/3/4/5%", "Komori UR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Hoshiumi UR": "Strong Spike +5/7/9/12/15, Strong Spike +1/2/3/4/5%" },
  "Karasuno 3rd Years": { "Azumane SSR": "Power +5/7/9/12/15, Power +1/2/3/4/5%", "Daichi SSR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Sugawara SP": "Block +5/7/9/12/15, Block +1/2/3/4/5%" },
  "Karasuno's Failing Grades Group": { "Hinata SSR": "", "Kageyama UR": "", "Nishinoya SSR": "", "Tanaka SSR": "Strong Attack +5/7/9/12/15, Strong Attack +1/2/3/4/5%" },
  "Karasuno's Red Mark Squad (Hanami ver.)": { "Hinata SP": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Nishinoya SP": "Toss +5/7/9/12/15, Toss +1/2/3/4/5%", "Tanaka SSR": "", "Kageyama UR": "" },
  "Karasuno's Setters": { "Sugawara SR": "Toss +5/7/9/12/15, Toss +1/2/3/4/5%", "Kageyama UR": "" },
  "Karasuno's Wing Spiker": { "Tanaka SR": "Power Attack +5/7/9/12/15, Power Attack +1/2/3/4/5%", "Azumane SR": "Serve +5/7/9/12/15, Serve +1/2/3/4/5%", "Chikara SR": "Power Attack +5/7/9/12/15, Power Attack +1/2/3/4/5%" },
  "Leaders Cut from the Same Cloth": { "Daichi SR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Kuro SSR": "Block +5/7/9/12/15, Block +1/2/3/4/5%" },
  "Master and Apprentice": { "Tsuki SSR": "Block +5/7/9/12/15, Block +1/2/3/4/5%", "Kuro UR": "Block +5/7/9/12/15, Block +1/2/3/4/5%" },
  "Nekoma's Junior": { "Teshiro SR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Inuoka SR": "No buff", "Lev SSR": "No Buff" },
  "Number One Disciple": { "Bokuto UR": "Spike +5/7/9/12/15, Spike +1/2/3/4/5%", "Hinata SSR": "" },
  "Number One Disciple SP": { "Hinata SP": "Quick Attack +5/7/9/12/15, Quick Attack +1/2/3/4/5%", "Bokuto SP": "Strong Attack +5/7/9/12/15, Strong Attack +1/2/3/4/5%" },
  "One-on-One Training": { "Lev SR": "Block +5/7/9/12/15, Block +1/2/3/4/5%", "Yaku SR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%" },
  "Perseverance and Tenacity": { "Kenma SP": "Toss +5/7/9/12/15, Toss +1/2/3/4/5%", "Yamamoto SR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%" },
  "Prediction VS System": { "Tsuki SSR": "No buff", "Tendo SSR": "Block +5/7/9/12/15, Block +1/2/3/4/5%" },
  "Promising Senpai": { "Tendo SSR": "Quick Attack +5/7/9/12/15, Quick Attack +1/2/3/4/5%", "Goshiki SSR": "Power Attack +5/7/9/12/15, Power Attack +1/2/3/4/5%" },
  "Reliable Seniors": { "Kuro UR": "Quick Attack +5/7/9/12/15, Quick Attack +1/2/3/4/5%", "Yaku SSR": "", "Kai SR": "" },
  "Rival Friends": { "Hinata SSR": "Quick Attack +5/7/9/12/15, Quick Attack +1/2/3/4/5%", "Kenma SSR": "Set +5/7/9/12/15, Set +1/2/3/4/5%" },
  "Shiratorizawa 2nd Years": { "Shirabu SSR": "Toss +5/7/9/12/15, Toss +1/2/3/4/5%", "Taichi SR": "Quick +5/7/9/12/15, Quick +1/2/3/4/5%" },
  "Shiratorizawa 3rd Years": { "Ushijima UR": "", "Yamagata SSR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Ohira SSR": "Spike +5/7/9/12/15, Spike +1/2/3/4/5%", "Semi SSR": "Serve +5/7/9/12/15, Serve +1/2/3/4/5%", "Tendo SSR": "Block +5/7/9/12/15, Block +1/2/3/4/5%" },
  "Silence and Sarcasm": { "Aone SP": "Block +5/7/9/12/15, Block +1/2/3/4/5%", "Futakuchi SSR": "" },
  "Simulated Junior Training Teamate": { "Kanji SR": "Set +5/7/9/12/15, Set +1/2/3/4/5%", "Tsuki SR": "No buff" },
  "Strange Friendship": { "Hinata SP": "Quick Attack +5/7/9/12/15, Quick Attack +1/2/3/4/5%", "Aone SP": "Block +5/7/9/12/15, Block +1/2/3/4/5%" },
  "Team's Guardians": { "Nishinoya SSR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Yaku SSR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%" },
  "Team's Guardians (After School)": { "Nishinoya SP": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Yaku SSR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%" },
  "The \"Enigmatic\" Teammate": { "Lev SSR": "Block +5/7/9/12/15, Block +1/2/3/4/5%", "Kenma SSR": "No buff" },
  "The Absolute King VS the Freak Duo": { "Ushijima UR": "Spike +5/7/9/12/15, Spike +1/2/3/4/5%", "Hinata SSR": "", "Kageyama UR": "" },
  "The King and The Great King": { "Kageyama UR": "Serve +5/7/9/12/15, Serve +1/2/3/4/5%", "Oikawa UR": "Serve +5/7/9/12/15, Serve +1/2/3/4/5%" },
  "The Moment They Fell for Volleyball": { "Bokuto SP": "Spikes +5/7/9/12/15, Spikes +1/2/3/4/5%", "Tsuki SP": "Quick +5/7/9/12/15, Quick +1/2/3/4/5%" },
  "Third Year from Inarizaki": { "Kita SSR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Ojiro SSR": "Power Attack +5/7/9/12/15, Power Attack +1/2/3/4/5%", "Akagi SSR": "Cover +5/7/9/12/15, Cover +1/2/3/4/5%", "Omimi SR": "Block +5/7/9/12/15, Block +1/2/3/4/5%" },
  "To Greater Heights": { "Kindaichi SR": "", "Oikawa UR": "Toss +5/7/9/12/15, Toss +1/2/3/4/5%" },
  "Tokyo Training Camp Buddies": { "Bokuto SP": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Akaashi SP": "Toss +5/7/9/12/15, Toss +1/2/3/4/5%", "Tsuki SP": "Block +5/7/9/12/15, Block +1/2/3/4/5%", "Kuro SP": "Block +5/7/9/12/15, Block +1/2/3/4/5%" },
  "Tokyo Training Camp Self-Practice Buddies": { "Bokuto UR": "Serve +5/7/9/12/15, Serve +1/2/3/4/5%", "Akaashi SSR": "Toss +5/7/9/12/15, Toss +1/2/3/4/5%", "Kuro UR": "", "Tsuki SSR": "" },
  "Two High-Energy Guys": { "Bobata R": "", "Terushima SSR": "Attack +5/7/9/12/15, Attack +1/2/3/4/5%" },
  "Undisputed Aces": { "Goshiki SSR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Ushijima UR": "Power Attack +5/7/9/12/15, Power Attack +1/2/3/4/5%" },
  "Ushiwaka and Benkei": { "Ushijima UR": "Block +5/7/9/12/15, Block +1/2/3/4/5%", "Ohira SSR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%" },
  "Worthy Rival": { "Hinata SSR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Inuoka SR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%" },
  "Youth Camp Setters": { "Kageyama UR": "Toss +5/7/9/12/15, Toss +1/2/3/4/5%", "Atsumu UR": "Toss +5/7/9/12/15, Toss +1/2/3/4/5%" },
  "Youth Training Camp": { "Hoshiumi UR": "Serve +5/7/9/12/15, Serve +1/2/3/4/5%", "Kageyama UR": "" },
  "Similar Builds": { "Hinata SP": "Quick Attack +5/7/9/12/15, Quick Attack +1/2/3/4/5%", "Hoshiumi UR": "Strong Attack +5/7/9/12/15, Strong Attack +1/2/3/4/5%" },
  "Similar Physique Teammates": { "Hinata SSR": "", "Hoshiumi UR": "Power Strike +5/7/9/12/15, Power Strike +1/2/3/4/5%" },
  "Kiyoko's Protection Group": {"Tanaka SSR":"Strong Attack +5/7/9/12/15, Strong Attack +1/2/3/4/5%", "Nishinoya SP":"Receive +5/7/9/12/15, Receive +1/2/3/4/5%"},
  "Date Tech’s Setters": {"Koganegawa SP":"Toss +5/7/9/12/15, Toss +1/2/3/4/5%", "Moniwa SR":"Toss +5/7/9/12/15, Toss +1/2/3/4/5%"},
  "New-type Rookie & the New Captain": {"Koganegawa SP":"Block +5/7/9/12/15, Block +1/2/3/4/5%","Futakuchi SSR":"Block +5/7/9/12/15, Block +1/2/3/4/5%"}
};
window.STATS_BOND_MEMBERS = {
  // Exemplo; substitua pelo seu conteúdo completo:
  "Aoba Johsai's Sophomore": ["Watari SR, Yahaba SR, Kentaro SSR"],
  "Behind the Smile": ["Daichi SSR, Kuro UR"],
  "Bench cheer": ["Hisashi R, Kazuhito R"],
  "Building Team Chemistry": ["Kageyama SSR, Tanaka SR"],
  "Cannon \\& Iron Wall": ["Azumane SSR, Aone SSR"],
  "Cannon and Iron Wall": ["Aone SP, Azumane SSR"],
  "Classmates": ["Suna SSR, Osamu UR"],
  "Date Kogyo's Captains": ["Kaname SR, Kenji SSR"],
  "Date Kogyo's Junior": ["Jingo R, Sakunami R"],
  "Date Kogyo's Setter": ["Kaname SR, Kaji SSR"],
  "Fated Rivals": ["Oikawa UR, Ushijima UR"],
  "Flexible Aces": ["Hinata SSR, Lev SSR"],
  "Formidable Opponent": ["Nishinoya SR, Yaku SR"],
  "Friends from Volleyball Class": ["Atsumu UR, Osamu UR, Ojiro SSR"],
  "Fukurodani 3rd Years": ["Bokuto UR, Komi SR, Konoha, Sarukui SSR, Washio SSR"],
  "Fukurodani MBs": ["Washio SSR, Onaga R"],
  "Fukurodani WS": ["Bokuto UR, Sarukui"],
  "Grit and Competitive": ["Yamamoto SR, Kenma SSR"],
  "Hidden Fire": ["Kentaro SSR, Yahaba SR"],
  "Inarizaki 2nd Years": ["Suna SSR, Ginjima SSR, Osamu UR, Atsumu UR, Kosaku R"],
  "Inarizaki WS Teammates": ["Kita SSR, Ojiro SSR, Ginjima SSR, Kosaku R, Riseki R"],
  "Japan Youth Training Camp Teammates": ["Kageyama UR, Atsumu UR, Sakusa UR, Komori UR, Hoshiumi UR"],
  "Karasuno 3rd Years": ["Azumane SSR, Daichi SSR, Sugawara SP"],
  "Karasuno's Failing Grades Group": ["Hinata SSR, Kageyama UR, Nishinoya SSR, Tanaka SSR"],
  "Karasuno's Red Mark Squad (Hanami ver.)": ["Hinata SP, Nishinoya SP, Tanaka SSR, Kageyama UR"],
  "Karasuno's Setters": ["Sugawara SP, Kageyama UR"],
  "Karasuno's Wing Spiker": ["Tanaka SR, Azumane SR, Chikara SR"],
  "Leaders Cut from the Same Cloth": ["Daichi SR, Kuro SSR"],
  "Master and Apprentice": ["Tsuki SSR, Kuro UR"],
  "Nekoma's Junior": ["Teshiro SR, Inuoka SR, Lev SSR"],
  "Number One Disciple": ["Bokuto UR, Hinata SSR"],
  "Number One Disciple SP": ["Hinata SP, Bokuto SP"],
  "One-on-One Training": ["Lev SR, Yaku SR"],
  "Perseverance and Tenacity": ["Kenma SP, Yamamoto SR"],
  "Prediction VS System": ["Tsuki SSR, Tendo SSR"],
  "Promising Senpai": ["Tendo SSR, Goshiki SSR"],
  "Reliable Seniors": ["Kuro UR, Yaku SSR, Kai SR"],
  "Rival Friends": ["Hinata SSR, Kenma SSR"],
  "Shiratorizawa 2nd Years": ["Shirabu SSR, Taichi SR"],
  "Shiratorizawa 3rd Years": ["Ushijima UR, Yamagata SSR, Ohira SSR, Semi SSR, Tendo SSR"],
  "Silence and Sarcasm": ["Aone SP, Futakuchi SSR"],
  "Simulated Junior Training Teamate": ["Kanji SR, Tsuki SR"],
  "Strange Friendship": ["Hinata SP, Aone SP"],
  "Team's Guardians": ["Nishinoya SSR, Yaku SSR"],
  "Team's Guardians (After School)": ["Nishinoya SP, Yaku SSR"],
  "The \"Enigmatic\" Teammate": ["Lev SSR, Kenma SSR"],
  "The Absolute King VS the Freak Duo": ["Ushijima UR, Hinata SSR, Kageyama UR"],
  "The King and The Great King": ["Kageyama UR, Oikawa UR"],
  "The Moment They Fell for Volleyball": ["Bokuto SP, Tsuki SP"],
  "Third Year from Inarizaki": ["Kita SSR, Ojiro SSR, Akagi SSR, Omimi SR"],
  "To Greater Heights": ["Kindaichi SR, Oikawa UR"],
  "Tokyo Training Camp Buddies": ["Bokuto SP, Akaashi SP, Tsuki SP, Kuro SP"],
  "Tokyo Training Camp Self-Practice Buddies": ["Bokuto UR, Akaashi SSR, Kuro UR, Tsuki SSR"],
  "Two High-Energy Guys": ["Bobata R, Terushima SSR"],
  "Undisputed Aces": ["Goshiki SSR, Ushijima UR"],
  "Ushiwaka and Benkei": ["Ushijima UR, Ohira SSR"],
  "Worthy Rival": ["Hinata SSR, Inuoka SR"],
  "Youth Camp Setters": ["Kageyama UR, Atsumu UR"],
  "Youth Training Camp": ["Hoshiumi UR, Kageyama UR"],
  "Similar Builds": ["Hinata SP, Hoshiumi UR"],
  "Similar Physique Teammates": ["Hinata SSR, Hoshiumi UR"],
  "Kiyoko's Protection Group": ["Tanaka SSR, Nishinoya SP"],
  "Date Tech’s Setters":["Koganegawa SP, Moniwa SR"],
  "New-type Rookie & the New Captain":["Koganegawa SP, Futakuchi SSR"]
};

let selecionados = [];

let teams = window.teams || [];            // se já existir, reutiliza
let currentTeamIndex = window.currentTeamIndex || 0;
let __mtAdding = false;                    // lock anti-duplo clique

/* ====== FUNÇÕES ORIGINAIS (mantidas) ====== */
function addBenchSlot() {
    const benchRow = document.getElementById("bench-row");
    const slot = document.createElement("div");
    slot.className = "player-slot bench";
    slot.innerHTML = `<div class="bench-slot" data-role="bench"></div><div class="player-info">Bench</div>`;
    benchRow.insertBefore(slot, benchRow.querySelector(".add-slot-btn"));
    attachBenchEvents(slot.querySelector(".bench-slot"));
}

function attachBenchEvents(slot) {
  if (slot.__benchBound) return;         // evita duplicar handlers
  slot.__benchBound = true;

  let clickTimer = null;

  slot.addEventListener("click", (e) => {
    e.stopPropagation();

    // 2º clique dentro da janela => trata como duplo clique
    if (clickTimer) {
      clearTimeout(clickTimer);
      clickTimer = null;

      const nome = slot.dataset.nome;
      if (!nome) {
        // slot vazio: no duplo clique, abrimos o menu mesmo assim
        if (typeof showMenu === "function") showMenu("bench", slot);
        return;
      }

      const p = (typeof characters !== "undefined") && characters.find(x => x.nome === nome);
      if (!p) return;

      const sm = document.getElementById("scrollMenu");
      if (sm) sm.style.display = "none";     // fecha menu de seleção, se aberto

      if (typeof showCharacterDetails === "function") showCharacterDetails(p);

      const sidebar = document.getElementById("sidebar");
      const menuBtn = document.getElementById("menuBtn");
      if (sidebar) sidebar.classList.add("open");
      if (menuBtn) menuBtn.style.display = "none";
      return;
    }

    // 1º clique: se não vier 2º clique rápido, abre o menu do banco
    clickTimer = setTimeout(() => {
      clickTimer = null;
      if (typeof showMenu === "function") showMenu("bench", slot);
    }, 250);
  });

  // botão direito: remover do banco
  slot.addEventListener("contextmenu", (e) => {
    e.preventDefault();
    if (typeof removeCharacter === "function") removeCharacter(slot);
  });
}

function isAllowedForStarterSlot(slotRole, charRole) {
  const slot = String(slotRole || '').toUpperCase();
  const role = String(charRole || '').toUpperCase();
  if (!slot || slot === 'BENCH') return true;   // segurança
  if (slot === 'L') return role === 'L';
  return role !== 'L';
}

function showMenu(role, slot) {
  const scrollMenu = document.getElementById("scrollMenu");
  scrollMenu.innerHTML = '';
  scrollMenu.style.display = 'flex';
  scrollMenu.style.flexDirection = 'column';

  const isBench = (role === 'bench');
  const slotRole = isBench ? 'bench' : (slot.dataset.role || slot.getAttribute('data-role'));

  // Cabeçalho com botões
  const bar = document.createElement('div');
  bar.className = 'bench-quick-inside';

  const ROLES = ['All','S','MB','WS','OP','L'];
  // Filtro inicial: se for L, começa em L; caso contrário, começa em All (não-L).
  let currentFilter = isBench ? 'All' : (ROLES.includes(String(slotRole).toUpperCase()) ? String(slotRole).toUpperCase() : 'All');

  function roleAllowedInThisSlot(r){
    if (r === 'All') return true; // "All" será interpretado como "todos permitidos"
    if (slotRole === 'bench') return true; // bench não restringe por função aqui
    // starters
    return isAllowedForStarterSlot(slotRole, r);
  }

  ROLES.forEach(r => {
    const b = document.createElement('button');
    b.textContent = r;
    b.dataset.role = r;

    // Botões inválidos para o slot ficam desabilitados
    if (!roleAllowedInThisSlot(r)) {
      b.disabled = true;
      b.classList.add('disabled');
    }

    if (r === currentFilter) b.classList.add('active');
    b.addEventListener('click', (e) => {
      e.stopPropagation();
      if (b.disabled) return;
      currentFilter = r;
      bar.querySelectorAll('button').forEach(x => x.classList.toggle('active', x === b));
      render();
    });
    bar.appendChild(b);
  });

  scrollMenu.appendChild(bar);

  // Container das imagens
  const grid = document.createElement('div');
  grid.style.display = 'flex';
  grid.style.flexWrap  = 'wrap';
  grid.style.gap = '8px';
  scrollMenu.appendChild(grid);

  function render(){
    grid.innerHTML = '';

    let disponiveis = characters.filter(p => !selecionados.includes(p));

    // 1) aplica filtro por botão (exceto 'All')
    if (currentFilter !== 'All') {
      disponiveis = disponiveis.filter(p => p.funcao === currentFilter);
    }

    // 2) aplica regra do slot (para starters). Em 'All', isso converte "todos" em "todos permitidos"
    if (!isBench) {
      disponiveis = disponiveis.filter(p => isAllowedForStarterSlot(slotRole, p.funcao));
    } else {
      // bench mantém os próprios limites, se você quiser já pré-filtrar, pode aplicar aqui
      disponiveis = disponiveis.filter(p => respeitaLimiteBench(p, slot));
    }

    if (disponiveis.length === 0){
      grid.innerHTML = `<div style="color:#ccc; padding:8px;">
        No available ${currentFilter === 'All' ? '' : currentFilter}${isBench ? ' for bench' : ''}.
      </div>`;
      return;
    }

    disponiveis.forEach(p => {
      const img = document.createElement('img');
      img.src = p.img;
      img.alt = p.nome;
      img.title = p.nome;
      img.addEventListener('click', (e) => {
        e.stopPropagation();
        const keepRole = isBench ? 'bench' : slotRole; // preserva o label do slot
        setCharacter(slot, p, keepRole);
        scrollMenu.style.display = 'none';
      });
      grid.appendChild(img);
    });
  }

  render();
}

function respeitaLimiteBench(p, slot) {
    const Bench = Array.from(document.querySelectorAll(".bench-slot"))
        .map(s => s.dataset.nome && characters.find(x => x.nome === s.dataset.nome))
        .filter(Boolean);

    if (slot.dataset.nome === p.nome) return true;

    const contagem = Bench.reduce((acc, cur) => {
        acc[cur.funcao] = (acc[cur.funcao] || 0) + 1;
        return acc;
    }, {});

    if (p.funcao === "MB" && contagem["MB"] >= 6) return false;
    if (p.funcao === "WS" && contagem["WS"] >= 6) return false;
    if (["L",].includes(p.funcao) && contagem[p.funcao] >= 1) return false;

    return true;
}
    function getFirstEmptyBenchSlot() {
  // Procura um slot vazio do banco; se não houver, cria um novo
  const slots = Array.from(document.querySelectorAll(".bench-slot"));
  const empty = slots.find(s => !s.dataset.nome);
  if (empty) return empty;
  if (typeof addBenchSlot === "function") addBenchSlot(); // cria e já liga eventos
  const all = Array.from(document.querySelectorAll(".bench-slot"));
  return all[all.length - 1] || null;
}

function showBenchMenuByRole(role) {
  const slot = getFirstEmptyBenchSlot();
  if (!slot) return;

  const scrollMenu = document.getElementById("scrollMenu");
  scrollMenu.innerHTML = '';

  // Filtra por posição + respeita regras do banco
  const disponiveis = characters.filter(p =>
    p.funcao === role &&
    !selecionados.includes(p) &&
    respeitaLimiteBench(p, slot)   // mesma regra usada quando role === "bench"
  );

  if (disponiveis.length === 0) {
    scrollMenu.innerHTML = `<div style="color:#ccc; padding:8px;">No available ${role} for bench.</div>`;
  } else {
    disponiveis.forEach(p => {
      const img = document.createElement('img');
      img.src = p.img;
      img.alt = p.nome;
      img.title = p.nome;
      img.addEventListener('click', (e) => {
        e.stopPropagation();
        setCharacter(slot, p, 'bench');   // adiciona direto ao banco
        scrollMenu.style.display = 'none';
      });
      scrollMenu.appendChild(img);
    });
  }

  scrollMenu.style.display = 'flex';
}
document.querySelectorAll(".bench-quick-btn").forEach(btn => {
  btn.addEventListener("click", (e) => {
    e.stopPropagation();
    showBenchMenuByRole(btn.dataset.role);
  });
});

// índices dos 6 slots que formam o "anel" (L fica fora, é fixo no índice 3)
const RING_IDX = [0, 1, 2, 6, 5, 4]; // [S, MB, WS, OP, MB, WS] na orientação base

// Rotaciona o anel 'steps' vezes no sentido horário (move conteúdo e data-role)
function rotateRingClockwise(steps){
  const hexes = [...document.querySelectorAll('.hex')];
  const ring = RING_IDX.map(i => hexes[i]);
  const k = ((steps % 6) + 6) % 6;
  if (k === 0) return;
const ids = ring.map(h => getSlotId(h));
  const eq = ids.map(id => equipState.get(id) || null);
  const eqRot = eq.slice(-k).concat(eq.slice(0, -k));
  ids.forEach((id, idx) => {
    if (eqRot[idx]) equipState.set(id, eqRot[idx]); else equipState.delete(id);
  });
  // 1) Captura estado completo (inclui charName!)
  const state = ring.map(h => ({
    html: h.innerHTML,
    nome: h.dataset.nome || null,
    charName: h.dataset.charName || null,
    role: h.dataset.role || h.getAttribute('data-role') || ''
  }));

  // 2) Roda
  const rotated = state.slice(-k).concat(state.slice(0, -k));

  // 3) Aplica e reanexa handlers/badges
  ring.forEach((h, i) => {
    const st = rotated[i];
    h.innerHTML = st.html;                  // isto remove listeners antigos
    if (st.nome) h.dataset.nome = st.nome; else delete h.dataset.nome;
    h.dataset.role = st.role;
    if (st.charName) h.dataset.charName = st.charName; else delete h.dataset.charName; // **novo**

    // atualiza o label do slot
    const info = h.parentElement.querySelector('.player-info');
    if (info) {
      if (st.nome) {
        const p = (typeof characters !== "undefined") && characters.find(x => x.nome === st.nome);
        info.textContent = p ? `${st.nome} - ${p.funcao}` : st.nome;
      } else {
        info.textContent = st.role;
      }
    }
    
    // **importante**: recriar o botão ⚙️ com listener e a badge
    removeItemGear(h);
    ensureItemGear(h);
    updateItemBadge(h);
  });
}

// Ajusta a orientação do grid para coincidir com o time salvo
function orientGridToSavedTeam(team) {
  // pega a função (S/MB/WS/OP/L) em cada índice salvo
  const funcaoEm = (idx) => {
    const nome = team.main[idx];
    if (!nome) return null;
    const p = characters.find(x => x.nome === nome);
    return p ? p.funcao : null;
  };

  // Tentamos ancorar por S; se não existir, ancoramos por OP
  const idxS = RING_IDX.find(i => funcaoEm(i) === 'S');
  if (idxS !== undefined) {
    const posNoAnel = RING_IDX.indexOf(idxS); // onde o S está
    // na base, S está em RING_IDX[0] -> steps = pos atual
    rotateRingClockwise(posNoAnel);
    return;
  }
  const idxOP = RING_IDX.find(i => funcaoEm(i) === 'OP');
  if (idxOP !== undefined) {
    const posNoAnel = RING_IDX.indexOf(idxOP);
    // na base, OP está em RING_IDX[3] -> passos = pos atual - 3
    rotateRingClockwise((posNoAnel - 3 + 6) % 6);
  }
}

    
function setCharacter(slot, personagem, role) {
    // se já tinha alguém nesse slot, remove dos selecionados
    if (slot.dataset.nome) {
        selecionados = selecionados.filter(p => p.nome !== slot.dataset.nome);
    }

    // monta imagem
   slot.innerHTML = `<img src="${personagem.img}" alt="${personagem.nome}">`;
slot.dataset.nome = personagem.nome;
slot.dataset.role = role;

    afterAssignCharacter(slot, personagem.nome);

    // atualiza texto de info (procura .player-info no mesmo player-slot)
    const infoDiv = slot.parentElement.querySelector('.player-info');
    if (infoDiv) infoDiv.textContent = `${personagem.nome} - ${personagem.funcao}`;

    selecionados.push(personagem);
    updateSynergies();
}

function removeCharacter(slot) {
  if (slot.dataset.nome) {
    selecionados = selecionados.filter(p => p.nome !== slot.dataset.nome);

    // CHAME O HOOK ANTES de limpar o slot
    if (typeof window.afterRemoveCharacter === "function") {
      window.afterRemoveCharacter(slot);
    }

    slot.innerHTML = "";
    delete slot.dataset.nome;

    const infoDiv = slot.parentElement.querySelector('.player-info');
    if (slot.classList.contains("bench-slot")) {
      infoDiv.textContent = "Bench";
    } else {
      infoDiv.textContent = slot.dataset.role
        || slot.getAttribute("data-role")
        || slot.parentElement.querySelector('.hex')?.dataset.role || "";
    }

    updateSynergies();
    if (typeof afterRemoveCharacter === "function") afterRemoveCharacter(slot);
  }
}

function updateSynergies() {
    const synergyListEl = document.getElementById("synergy-list");
    synergyListEl.innerHTML = "";

    // === CONFIG: which bonds need 3 to activate ===
    // Put the EXACT vinculo names here (case-sensitive).
    const bondsRequire3 = new Set([
      "Natação",  
     "Cabeça dos Gêmeos", 
    ]);

    const DEFAULT_BOND_MIN = 2; // all bonds default to 2 unless listed above
    const SCHOOL_MIN = 4;       // school synergy rule stays the same

    const SchoolsCount = {};
    const vinculosCount = {};

    // --- Count Schools (starters only) ---
    document.querySelectorAll(".hex").forEach(slot => {
        if (slot.dataset.nome) {
            const p = characters.find(x => x.nome === slot.dataset.nome);
            if (!p) return;
            SchoolsCount[p.School] = (SchoolsCount[p.School] || 0) + 1;
        }
    });

    // --- Count Bonds (starters + bench) ---
    document.querySelectorAll(".hex, .bench-slot").forEach(slot => {
        if (slot.dataset.nome) {
            const p = characters.find(x => x.nome === slot.dataset.nome);
            if (!p) return;

            if (Array.isArray(p.vinculo)) {
                p.vinculo.forEach(v => {
                    vinculosCount[v] = (vinculosCount[v] || 0) + 1;
                });
            } else if (p.vinculo) {
                vinculosCount[p.vinculo] = (vinculosCount[p.vinculo] || 0) + 1;
            }
        }
    });

    let algumaSinergia = false;

    // --- School synergies (>= 4) ---
    for (const school in SchoolsCount) {
        if (SchoolsCount[school] >= SCHOOL_MIN) {
            synergyListEl.innerHTML += `
                <li>
                    <button class="bond-btn school-btn" data-school="${school}">
                        School: ${school}
                    </button>
                </li>
            `;
            algumaSinergia = true;
        }
    }

    // --- Bond synergies (>= per-bond threshold) ---
    for (const vinculo in vinculosCount) {
        const required = bondsRequire3.has(vinculo) ? 3 : DEFAULT_BOND_MIN;
        if (vinculosCount[vinculo] >= required) {
            synergyListEl.innerHTML += `
                <li>
                    <button class="bond-btn synergy-btn" data-bond="${vinculo}">
                        ${vinculo}
                    </button>
                </li>
            `;
            algumaSinergia = true;
        }
    }

    // === Click: School ===
    document.querySelectorAll(".school-btn").forEach(btn => {
        btn.addEventListener("click", (e) => {
            e.stopPropagation();
            const schoolName = btn.dataset.school;

            const relacionados = characters.filter(pers => pers.School === schoolName);

            sidebarContent.innerHTML = `
                <h3>School: ${schoolName}</h3>
                <p>${descricoesSinergia[schoolName] || "Sem descrição disponível"}</p>
                <div class="char-list">
                    ${relacionados.map(r => `
                        <div class="char-card" data-nome="${r.nome}">
                            <img src="${r.img}" alt="${r.nome}">
                            <p>${r.nome}</p>
                        </div>
                    `).join('')}
                </div>
                <button id="backToSynergies" class="bond-btn">← Voltar</button>
            `;

            sidebar.classList.add("open");
            menuBtn.style.display = "none";

            document.getElementById("backToSynergies").addEventListener("click", (e) => {
                e.stopPropagation();
                updateSynergies();
                sidebar.classList.add("open");
                menuBtn.style.display = "none";
            });

            sidebarContent.querySelectorAll(".char-card").forEach(card => {
                card.addEventListener("click", (e) => {
                    e.stopPropagation();
                    const nome = card.dataset.nome;
                    const personagem = characters.find(x => x.nome === nome);
                    showCharacterDetails(personagem);
                    sidebar.classList.add("open");
                    menuBtn.style.display = "none";
                });
            });
        });
    });

    // === Click: Bond ===
    document.querySelectorAll(".synergy-btn").forEach(btn => {
        btn.addEventListener("click", (e) => {
            e.stopPropagation();
            const bondName = btn.dataset.bond;

            const relacionados = characters.filter(pers => {
                if (Array.isArray(pers.vinculo)) return pers.vinculo.includes(bondName);
                return pers.vinculo === bondName;
            });

            sidebarContent.innerHTML = `
                <h3>Vínculo: ${bondName}</h3>
                <p>${descricoesSinergia[bondName] || "Sem descrição disponível"}</p>
                <div class="char-list">
                    ${relacionados.map(r => `
                        <div class="char-card" data-nome="${r.nome}">
                            <img src="${r.img}" alt="${r.nome}">
                            <p>${r.nome}</p>
                        </div>
                    `).join('')}
                </div>
                <button id="backToSynergies" class="bond-btn">← Voltar</button>
            `;

            sidebar.classList.add("open");
            menuBtn.style.display = "none";

            document.getElementById("backToSynergies").addEventListener("click", (e) => {
                e.stopPropagation();
                updateSynergies();
                sidebar.classList.add("open");
                menuBtn.style.display = "none";
            });

            sidebarContent.querySelectorAll(".char-card").forEach(card => {
                card.addEventListener("click", (e) => {
                    e.stopPropagation();
                    const nome = card.dataset.nome;
                    const personagem = characters.find(x => x.nome === nome);
                    showCharacterDetails(personagem);
                    sidebar.classList.add("open");
                    menuBtn.style.display = "none";
                });
            });
        });
    });

    if (!algumaSinergia) {
        synergyListEl.innerHTML = "<li>Only Deployment Synergies are displayed.Synergies will only work when players are in court inside the game.</li>";
    }
    // --- Tipo do time (apenas titulares) ---
(function renderTeamType(){
  function symbolToType(sym){
    const s = String(sym||"").toLowerCase();
    if (s.includes("quicksymbol"))   return "quick";
    if (s.includes("powersymbol"))   return "power";
    if (s.includes("receivesymbol")) return "receive";
    if (s.includes("blocksymbol"))   return "block";
    return null;
  }

  const TYPE_DEFAULT_MIN = 4;
  const typeCounts = {};

  // conta tipos só dos titulares (.hex)
  document.querySelectorAll(".hex").forEach(slot => {
    const nome = slot.dataset?.nome;
    if (!nome) return;
    const p = characters.find(x => x.nome === nome);
    if (!p) return;
    const syms = Array.isArray(p.symbols) ? p.symbols : [];
    const types = new Set(syms.map(symbolToType).filter(Boolean));
    types.forEach(t => { typeCounts[t] = (typeCounts[t] || 0) + 1; });
  });

  // vencedores entre os ativados
  let top = []; let topCount = 0;
  for (const [t, c] of Object.entries(typeCounts)) {
    const min = (t === "receive") ? 5 : TYPE_DEFAULT_MIN;
    if (c >= min) {
      if (c > topCount) { top = [t]; topCount = c; }
      else if (c === topCount) top.push(t);
    }
  }

  // garante cabeçalho flex ao redor do título "Synergies"
  const box = synergyListEl?.parentElement || document; // container da lista
  let title = box.querySelector('h2');
  if (!title) return;

  let header = title.closest('.synergy-header');
  if (!header){
    header = document.createElement('div');
    header.className = 'synergy-header';
    title.replaceWith(header);
    header.appendChild(title);
  }

  // cria/atualiza a badge ao lado do título
  let badge = header.querySelector('.team-type-badge');
  if (!badge){
    badge = document.createElement('span');
    badge.className = 'team-type-badge';
    header.appendChild(badge);
  }

  if (top.length){
    const label = {
      quick:"Quick Attack", power:"Power Attack", receive:"Receive", block:"Block"
    };
    const names = top.map(t => label[t] || t).join(" ou ");
    badge.textContent = `Team type: ${names} (${topCount})`;
  } else {
    badge.textContent = ''; // nada ativado, não mostra texto
  }
})();
}
// ====== Eventos iniciais (grid principal com detecção de duplo clique) ======
document.querySelectorAll(".hex").forEach(slot => {
  // Timer por slot para distinguir clique simples x duplo clique
  slot.__clickTimer = null;

  slot.addEventListener("click", (e) => {
    e.stopPropagation();

    // Se já existe um timer, este clique é o 2º -> trata como duplo clique
    if (slot.__clickTimer) {
      clearTimeout(slot.__clickTimer);
      slot.__clickTimer = null;

      // ⏩ Duplo clique: abrir detalhes (se houver personagem nesse slot)
      const nome = slot.dataset.nome;
      if (!nome) return; // slot vazio
      const p = (typeof characters !== "undefined") && characters.find(x => x.nome === nome);
      if (!p) return;

      // fecha o menu, se estiver aberto
      const sm = document.getElementById("scrollMenu");
      if (sm) sm.style.display = "none";

      // mostra detalhes no painel lateral
      if (typeof showCharacterDetails === "function") {
        showCharacterDetails(p);
      }
      // garante que o painel lateral fique aberto (se você usa esses ids)
      const sidebar = document.getElementById("sidebar");
      const menuBtn = document.getElementById("menuBtn");
      if (sidebar) sidebar.classList.add("open");
      if (menuBtn) menuBtn.style.display = "none";

      return;
    }

    // 1º clique: arma o timer; se não houver 2º clique, abre o menu
    slot.__clickTimer = setTimeout(() => {
      slot.__clickTimer = null;
      // ✅ Clique simples (sem 2º clique): abre o menu de seleção
      if (typeof showMenu === "function") {
        showMenu(slot.dataset.role, slot);
      }
    }, 250); // janela para detectar duplo clique
  });

  // Botão direito: remover personagem (igual antes)
  slot.addEventListener("contextmenu", (e) => {
    e.preventDefault();
    if (typeof removeCharacter === "function") removeCharacter(slot);
  });
});

document.querySelectorAll(".bench-slot").forEach(slot => attachBenchEvents(slot));

/* ====== SIDEBAR NAV ====== */
const sidebarContent = document.getElementById("sidebar-content");
document.querySelectorAll(".menu-link").forEach(btn => {
  btn.addEventListener("click", (e) => {
    e.stopPropagation();
    const section = btn.dataset.section;
    if (section === "characters") {
      showCharacterList();
    } else if (section === "schools") {
      showSchoolsList();             
    } else if (section === "save") {
      showSavedTeams();
    } else if (section === "help") {
    sidebarContent.innerHTML = `
        <h3>Info</h3>
        <div style="display:flex; flex-direction:column; gap:10px;">
            <button id="faqBtn" class="bond-btn">📄 FAQ</button>
            <button id="creditsBtn" class="bond-btn">👥 Credits</button>
            <button id="patchBtn" class="bond-btn">🔄 Patch</button>
        </div>
    `;

    // Botão FAQ
    document.getElementById("faqBtn").addEventListener("click", (e) => {
        e.stopPropagation();
        sidebarContent.innerHTML = `
            <h3>FAQ</h3>
            <p>Player bonds work if one is benched?</p>
            <p>It doesn't, only gonna be applied in game when the bond players are in court</p>
            <p>"X" bond doesn't show, why?</p>
            <p>This version only shows DEPLOYMENT bonds, since "normal" bonds requirements are just to have the characters on the account, meaning they don't have to be in court to activate</p>
            <p>How can i help with team builderr?</p>
            <p>Contact goN6 on discord, to send ideas, fixes to erros, new information, etc.</p>
            <button id="backToHelp" class="bond-btn">← Voltar</button>
        `;
        document.getElementById("backToHelp").addEventListener("click", (e) => {
            e.stopPropagation();
            document.querySelector('.menu-link[data-section="help"]').click();
            sidebar.classList.add("open");
            menuBtn.style.display = "none";
        });
    });

    // Botão Credits
    document.getElementById("patchBtn").addEventListener("click", (e) => {
        e.stopPropagation();
        sidebarContent.innerHTML = `
            <h3>Patch notes</h3>
            <p>Patch 1.2.1 Added:</p>
            <p>NO position restriction filter for new JP mechanic</p>
            <p>Shows new "Team Type" mechanic</p>
            <p>Multi teams function</p>
            <p>Patch 1.2 Added:</p>
            <p>Drag/drop players to bench and to starting line up</p>
            <p>Filter players by type (quick/power/etc)</p>
            <p>Team recommendations based on most synergies</p>
            <p>Memory and potential sets on character</p>
            <p>School page with all characters from each school and its buff</p>
            <p>Fixed:</p>
            <p>Some synergies that required 3 players were not being displayed correctly</p>
            <p>Some bench rules were not working correctly, EX: couldnt add more than 2 MB's on bench</p>
            <p>Added:</p>
            <p>Double click opens character details</p>
            <p>Bench filter per positions</p>
            <p>Side menu</p>
            <p>Save and Load teams</p>
            <p>Clear all button</p>
            <p>Filter characters on side menu</p>
            <p>Character Skills description</p>
            <p>Character Stats</p>
            <p>Expected release date</p>
            <button id="backToHelp" class="bond-btn">← Back</button>
        `;
        document.getElementById("backToHelp").addEventListener("click", (e) => {
            e.stopPropagation();
            document.querySelector('.menu-link[data-section="help"]').click();
            sidebar.classList.add("open");
            menuBtn.style.display = "none";
        });
    });
               // Botão FAQ
    document.getElementById("creditsBtn").addEventListener("click", (e) => {
        e.stopPropagation();
        sidebarContent.innerHTML = `
            <h3>Credits</h3>
            <p>Devoy Aces: goN6 , Kari, Marin, Kaito</p>
            <p>Tradução para inglês by KRILL group https://discord.gg/EEBqSKvAsp</p>
            <button id="backToHelp" class="bond-btn">← Voltar</button>
            
        `;
        document.getElementById("backToHelp").addEventListener("click", (e) => {
            e.stopPropagation();
            document.querySelector('.menu-link[data-section="help"]').click();
            sidebar.classList.add("open");
            menuBtn.style.display = "none";
        });
    });
}
    });
});

/* ====== LISTA / FILTROS DE characters (mantida com stopPropagation nos clicks) ====== */
function showCharacterList() {
    const funcoes = [...new Set(characters.map(p => p.funcao))];
    const escolas = [...new Set(characters.map(p => p.School))];
    const StatsKeys = [...new Set(characters.flatMap(p => Object.keys(p.Stats || {})))];
    function symbolToType(sym){
  const s = String(sym||"").toLowerCase();
  if (s.includes("quicksymbol"))   return "quick";
  if (s.includes("powersymbol"))   return "power";
  if (s.includes("servesymbol"))   return "serve";
  if (s.includes("settersymbol"))  return "setter";
  if (s.includes("receivesymbol")) return "receive";
  if (s.includes("blocksymbol"))   return "block";
  if (s.includes("savesymbol"))    return "save";
  return null;
}

// tipos únicos lendo characters[*].symbols
const allTypes = [...new Set(
  characters.flatMap(p => (Array.isArray(p.symbols) ? p.symbols : [])
    .map(symbolToType).filter(Boolean))
)].sort();

    let html = `
    <h3>Characters</h3>
    <div class="filtros">
        <div>
            <label>Role:</label>
            <select id="filtroFuncao">
                <option value="">All</option>
                ${funcoes.map(f => `<option value="${f}">${f}</option>`).join('')}
            </select>
        </div>
        <div>
            <label>School:</label>
            <select id="filtroEscola">
                <option value="">All</option>
                ${escolas.map(e => `<option value="${e}">${e}</option>`).join('')}
            </select>
        </div>
        <div>
            <label>Stats:</label>
            <select id="filtroStats">
                <option value="">All</option>
                ${StatsKeys.map(s => `<option value="${s}">${s}</option>`).join('')}
            </select>
        </div>
                <div>
            <label>Expected Release Date:</label>
            <select id="filtroDataOrdem" title="Ordenar pela data (ignora quem não tem data)">
                <option value="">Ignorar</option>
                <option value="asc">Ascendente (MM/DD/YY)</option>
                <option value="desc">Descendente (MM/DD/YY)</option>
            </select>
        </div>
        <div>
             <label>Type:</label>
             <div id="filtroType">
             ${allTypes.map(t => `
             <label style="display:inline-flex;align-items:center;gap:6px;margin:2px 8px 2px 0;">
             <input type="checkbox" name="typeFilter" value="${t}"> ${t.toUpperCase()}
             </label>
             `).join("")}
             </div>
        </div>
<button id="limparFiltros">Limpar</button>
    </div>
<div class='char-list' id="charList"></div>
    `;

    sidebarContent.innerHTML = html;
    const list = document.getElementById('charList');
if (list) list.classList.remove('is-hidden');
    enableCloseOutsideCharList();

    // Helpers de data (MM/DD/YY)
    function parseDateMMDDYY(s) {
        if (typeof s !== "string") return null;
        const m = s.match(/^(\d{2})\/(\d{2})\/(\d{2})$/);
        if (!m) return null;
        const mm = parseInt(m[1], 10), dd = parseInt(m[2], 10), yy = 2000 + parseInt(m[3], 10);
        const d = new Date(yy, mm - 1, dd);
        return Number.isNaN(d.getTime()) ? null : d;
    }
    function hasValidDate(p) {
        return !!parseDateMMDDYY(p?.data);
    }

function getStatsSafe(p, key) {
  const v = p?.Stats?.[key];
  return (typeof v === "number") ? v : "-";
}


   function renderLista() {
  const listaEl   = document.getElementById("charList");
  if (listaEl) listaEl.classList.remove('is-hidden');

  const funcaoSel = (document.getElementById("filtroFuncao").value || "").trim();
  const escolaSel = (document.getElementById("filtroEscola").value || "").trim();
  let   StatsSel = (document.getElementById("filtroStats").value || "").trim();
  const dataOrdem = (document.getElementById("filtroDataOrdem")?.value || "").trim();
  const typeSel = Array.from(
  document.querySelectorAll('#filtroType input[name="typeFilter"]:checked')
).map(el => el.value);
  const typeBox = document.getElementById('filtroType');
if (typeBox) typeBox.addEventListener('change', renderLista);

  function getCharTypes(p){
  const arr = Array.isArray(p?.symbols) ? p.symbols : [];
  const types = new Set(arr.map(symbolToType).filter(Boolean));
  return [...types];
}

  if (StatsSel.toLowerCase() === "todos") StatsSel = "";

  // 1) filtro base
  let filtrados = characters.filter(p =>
    (funcaoSel === "" || p.funcao === funcaoSel) &&
    (escolaSel === "" || p.School === escolaSel) &&
    (typeSel.length === 0 || typeSel.every(t => getCharTypes(p).includes(t)))
  );

  // 2) ordenar por data quando escolhido (e ignorar sem data)
  if (dataOrdem === "asc" || dataOrdem === "desc") {
    filtrados = filtrados
      .filter(hasValidDate)
      .sort((a, b) => {
        const da = parseDateMMDDYY(a.data);
        const db = parseDateMMDDYY(b.data);
        return dataOrdem === "asc" ? (da - db) : (db - da);
      });
  } else if (StatsSel) {
    // 3) ordenar por Stats quando data está em "Ignorar"
    filtrados.sort((a, b) => {
      const bv = (b.Stats && typeof b.Stats[StatsSel] === "number") ? b.Stats[StatsSel] : -Infinity;
      const av = (a.Stats && typeof a.Stats[StatsSel] === "number") ? a.Stats[StatsSel] : -Infinity;
      return bv - av;
    });
  }

  // 4) render (agora em <li>)
  const html = filtrados.map((p, i) => {
    const metaLine =
      (dataOrdem === "asc" || dataOrdem === "desc")
        ? (hasValidDate(p) ? `<div class="card-sub">Expected Release Date: ${p.data}</div>` : "")
        : (StatsSel ? `<div class="card-sub">${StatsSel}: ${getStatsSafe(p, StatsSel)}</div>` : "");

    return `
      <li class="person-card" data-idx="${i}">
        <img src="${p.img}" alt="${p.nome}">
        <div class="card-name">${p.nome}</div>
        ${metaLine}
      </li>
    `;
  }).join("");

  listaEl.innerHTML = html;

  // 5) clique abre detalhes
  listaEl.querySelectorAll(".person-card").forEach(card => {
    card.addEventListener("click", (ev) => {
      ev.stopPropagation();  
      const idx = +card.getAttribute("data-idx");
      const person = filtrados[idx];
      if (person) showCharacterDetails(person);
    });
  });
}

    // listeners dos filtros
document.getElementById("filtroFuncao").addEventListener("change", renderLista);
document.getElementById("filtroEscola").addEventListener("change", renderLista);
document.getElementById("filtroStats").addEventListener("change", renderLista);
document.getElementById("filtroDataOrdem").addEventListener("change", renderLista);


// botão Limpar
document.getElementById("limparFiltros").addEventListener("click", () => {
  document.getElementById("filtroFuncao").value = "";
  document.getElementById("filtroEscola").value = "";
  document.getElementById("filtroStats").value = "";
  document.querySelectorAll('#filtroType input[name="typeFilter"]').forEach(cb => cb.checked = false);
  const selData = document.getElementById("filtroDataOrdem");
  if (selData) selData.value = "";
  renderLista();
});

// ⬇️ AQUI (fora do botão, depois dos listeners)
const listaEl = document.getElementById("charList");
if (listaEl && !listaEl.dataset.stopCloseBound) {
  listaEl.addEventListener("click", (ev) => ev.stopPropagation());
  listaEl.dataset.stopCloseBound = "1";
}

// primeira renderização
renderLista();
}

function showSchoolsList(){
  const sidebar = document.getElementById("sidebar");
  const menuBtn  = document.getElementById("menuBtn");

  const schools = [...new Set(characters.map(p => p.School))].sort((a,b)=>a.localeCompare(b));

  sidebarContent.innerHTML = `
    <h3>Schools</h3>
    <div style="display:flex; flex-direction:column; gap:8px;">
      ${schools.map(s => `
        <button class="bond-btn school-open" data-school="${s}">
           ${s}
        </button>
      `).join("")}
    </div>
  `;

  // abre e esconde o botão verde
  if (sidebar) sidebar.classList.add("open");
  if (menuBtn) menuBtn.style.display = "none";

  // clique de cada escola abre a página detalhada
  sidebarContent.querySelectorAll(".school-open").forEach(btn=>{
    btn.addEventListener("click", (e)=>{
      e.stopPropagation();
      showSchoolDetail(btn.dataset.school);
    });
  });
}

// Página de uma escola específica: descrição + personagens
function showSchoolDetail(schoolName){
  const sidebar = document.getElementById("sidebar");
  const menuBtn  = document.getElementById("menuBtn");

  const relacionados = characters.filter(p => p.School === schoolName);
  const desc = (typeof descricoesSinergia === "object" && descricoesSinergia[schoolName])
             ? descricoesSinergia[schoolName]
             : "No description available.";

  sidebarContent.innerHTML = `
    <h3>School: ${schoolName}</h3>
    <p>${desc}</p>
    <div class="char-list">
      ${relacionados.map(r => `
        <div class="char-card" data-nome="${r.nome}">
          <img src="${r.img}" alt="${r.nome}">
          <p>${r.nome}</p>
        </div>
      `).join("")}
    </div>
    <button id="backToSchools" class="bond-btn">← Voltar</button>
  `;

  if (sidebar) sidebar.classList.add("open");
  if (menuBtn) menuBtn.style.display = "none";

  // voltar para a lista de Schools
  document.getElementById("backToSchools").addEventListener("click", (e)=>{
    e.stopPropagation();
    showSchoolsList();
  });

  // clicar num personagem abre os detalhes dele (já existe showCharacterDetails)
  sidebarContent.querySelectorAll(".char-card").forEach(card=>{
    card.addEventListener("click", (e)=>{
      e.stopPropagation();
      const nome = card.dataset.nome;
      const p = characters.find(x => x.nome === nome);
      if (p && typeof showCharacterDetails === "function") {
        showCharacterDetails(p);
      }
    });
  });
}

function showCharacterDetails(p) {
  // Normalize fields so we can safely render
  const bonds   = Array.isArray(p?.vinculo) ? p.vinculo.filter(Boolean)
                : (p?.vinculo ? [p.vinculo] : []);
  const skills  = Array.isArray(p?.habilidades) ? p.habilidades : [];
  const symbols = Array.isArray(p?.symbols) ? p.symbols : [];
  const Stats  = Array.isArray(p?.Stats) ? p.Stats : [];
 // Stat Bonds que esse personagem participa
  const myStatBonds = Object.entries(window.STATS_BONDS || {})
    .filter(([bondName, map]) => Object.prototype.hasOwnProperty.call(map, p.nome));

  const pillsHtml = myStatBonds.length ? `
    <h4 style="margin-top:12px;">Stat Bonds</h4>
    <div>
      ${myStatBonds.map(([bn])=>`<button class="pill statbond-pill" data-bond="${bn}">${bn}</button>`).join('')}
    </div>
    <div id="statBondDesc" class="subdesc"></div>
  ` : '';

  sidebarContent.innerHTML = `
    <h3>${p.nome}</h3>
    <img src="${p.img}" alt="${p.nome}" style="width:100%;">

    ${symbols.length ? `
      <div class="person-symbols">
        ${symbols.map(sym => `<img src="${sym}" class="symbol-icon">`).join("")}
      </div>` : ""}

    ${p.data ? `<p><b>Expected Release Date:</b> ${p.data}</p>` : ""}
    <p><b>Position:</b> ${p.funcao || "-"}</p>
    <p><b>School:</b> ${p.School || "-"}</p>

    ${bonds.length ? `
      <p><b>Bonds:</b></p>
      <ul>
        ${bonds.map(v => `<li><button class="bond-btn bond-link" data-bond="${v}">${v}</button></li>`).join("")}
      </ul>` : `<p><b>Bonds:</b> <i>None</i></p>`}

    ${skills.length ? `
      <h4>Skills</h4>
      <ul>
        ${skills.map(h => `<li><button class="skill-btn" data-skill="${h.nome}">${h.nome}</button></li>`).join("")}
      </ul>` : ""}

    ${p.descricao ? `<p style="margin-top:8px;">${p.descricao}</p>` : ""}

    ${p.Stats ? `
      <ul>
        <li><b>Serve:</b> ${p.Stats.Serve}</li>
        <li><b>Spike:</b> ${p.Stats.Spike}</li>
        <li><b>Set:</b> ${p.Stats.Set}</li>
        <li><b>Receive:</b> ${p.Stats.Receive}</li>
        <li><b>Block:</b> ${p.Stats.Block}</li>
        <li><b>Save:</b> ${p.Stats.Save}</li>
      </ul>` : ""}

    ${pillsHtml}

    <button id="backToList" class="bond-btn">← Voltar</button>
  `;

  // Mantém aberto etc. (o resto do teu código permanece)
  sidebar.classList.add("open"); menuBtn.style.display = "none";

  // Back → lista
  document.getElementById("backToList").addEventListener("click", (e) => {
    e.stopPropagation(); showCharacterList();
  });

  // Abrir “Bond” normal (já existia)
  sidebarContent.querySelectorAll(".bond-link").forEach(btn => {
    btn.addEventListener("click", (e) => {
      e.stopPropagation();
      const bondName = btn.dataset.bond;
      const relacionados = characters.filter(pers =>
        Array.isArray(pers.vinculo) ? pers.vinculo.includes(bondName) : pers.vinculo === bondName
      );
      sidebarContent.innerHTML = `
        <h3>Bond: ${bondName}</h3>
        <p>${descricoesSinergia[bondName] || "Sem descrição disponível"}</p>
        <div class="char-list">
          ${relacionados.map(r => `
            <div class="char-card" data-nome="${r.nome}">
              <img src="${r.img}" alt="${r.nome}">
              <p>${r.nome}</p>
            </div>
          `).join("")}
        </div>
        <button id="backToChar" class="bond-btn">← Voltar</button>
      `;
      document.getElementById("backToChar").addEventListener("click", (e) => {
        e.stopPropagation(); showCharacterDetails(p);
      });
      sidebarContent.querySelectorAll(".char-card").forEach(card => {
        card.addEventListener("click", (e) => {
          e.stopPropagation();
          const nome = card.dataset.nome;
          const personagem = characters.find(x => x.nome === nome);
          if (personagem) showCharacterDetails(personagem);
        });
      });
    });
  });

  // Clique nas pills de Stat Bonds → descreve os participantes + buffs
  sidebarContent.querySelectorAll(".statbond-pill").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const bondName = btn.dataset.bond;
      const mapping = (window.STATS_BONDS||{})[bondName] || {};
      const html = `
        <b>${bondName}</b>
        <ul>
          ${Object.entries(mapping).map(([nm,buff])=>`
            <li><b>${nm}</b> — ${String(buff||'').trim() ? buff : '<em>sem buff</em>'}</li>
          `).join('')}
        </ul>`;
      const box = sidebarContent.querySelector('#statBondDesc');
      if (box) box.innerHTML = html;
    });
  });

  // Skills (mantido)
  sidebarContent.querySelectorAll(".skill-btn").forEach(btn => {
    btn.addEventListener("click", (e) => {
      e.stopPropagation();
      const skillName = btn.dataset.skill;
      const habilidade = skills.find(h => h.nome === skillName);
      if (!habilidade) return;
      sidebarContent.innerHTML = `
        <h3>Skill: ${habilidade.nome}</h3>
        <p>${habilidade.descricao || ""}</p>
        <button id="backToChar" class="bond-btn">← Voltar</button>
      `;
      document.getElementById("backToChar").addEventListener("click", (e) => {
        e.stopPropagation(); showCharacterDetails(p);
      });
    });
  });


  // Keep sidebar open
  sidebar.classList.add("open");
  menuBtn.style.display = "none";

  // Back to character list
  document.getElementById("backToList").addEventListener("click", (e) => {
    e.stopPropagation();
    showCharacterList();
  });

  // Open a Bond page
  sidebarContent.querySelectorAll(".bond-link").forEach(btn => {
    btn.addEventListener("click", (e) => {
      e.stopPropagation();
      const bondName = btn.dataset.bond;

      const relacionados = characters.filter(pers =>
        Array.isArray(pers.vinculo) ? pers.vinculo.includes(bondName)
                                    : pers.vinculo === bondName
      );

      sidebarContent.innerHTML = `
        <h3>Bond: ${bondName}</h3>
        <p>${descricoesSinergia[bondName] || "Sem descrição disponível"}</p>
        <div class="char-list">
          ${relacionados.map(r => `
            <div class="char-card" data-nome="${r.nome}">
              <img src="${r.img}" alt="${r.nome}">
              <p>${r.nome}</p>
            </div>
          `).join("")}
        </div>
        <button id="backToChar" class="bond-btn">← Voltar</button>
      `;

      sidebar.classList.add("open");
      menuBtn.style.display = "none";

      // Back to THIS character's details
      document.getElementById("backToChar").addEventListener("click", (e) => {
        e.stopPropagation();
        showCharacterDetails(p);
      });

      // Jump from bond list to another character
      sidebarContent.querySelectorAll(".char-card").forEach(card => {
        card.addEventListener("click", (e) => {
          e.stopPropagation();
          const nome = card.dataset.nome;
          const personagem = characters.find(x => x.nome === nome);
          if (personagem) showCharacterDetails(personagem);
        });
      });
    });
  });

  // Open a Skill page
  sidebarContent.querySelectorAll(".skill-btn").forEach(btn => {
    btn.addEventListener("click", (e) => {
      e.stopPropagation();
      const skillName = btn.dataset.skill;
      const habilidade = skills.find(h => h.nome === skillName);
      if (!habilidade) return;

      sidebarContent.innerHTML = `
        <h3>Skill: ${habilidade.nome}</h3>
        <p>${habilidade.descricao || ""}</p>
        <button id="backToChar" class="bond-btn">← Voltar</button>
      `;
      document.getElementById("backToChar").addEventListener("click", (e) => {
        e.stopPropagation();
        showCharacterDetails(p);
      });
    });
  });
}

/* ====== SALVAR / Load TIMES (localStorage) ====== */

// pega composição atual por NOME do personagem (não por src)
function getCurrentTeamByName() {
    // titulares: procuramos .hex dentro de .player-slot (apenas as hex)
    const mainHexes = Array.from(document.querySelectorAll(".hex"));
    const main = mainHexes.map(h => h.dataset.nome || null);

    // bench: cada .bench-slot
    const benches = Array.from(document.querySelectorAll(".bench-slot"));
    const benchNames = benches.map(b => b.dataset.nome || null);

    return { main, bench: benchNames };
}

const saveTeamBtn = document.getElementById("saveTeamBtn");
saveTeamBtn.addEventListener("click", (e) => {
    e.stopPropagation();
    const teamName = prompt("Type team name:");
    if (!teamName) return;

    let teams = JSON.parse(localStorage.getItem("savedTeams") || "{}");

    if (teams[teamName]) {
        if (!confirm(`Team "${teamName}" is already saved. Do you want to replace?`)) {
            return;
        }
    }

    const savePayload = {
  ...getCurrentTeamByName(),   // { main: [...], bench: [...] }
  items: serializeTeamItems()  // <- memories / potentials por slot
};

teams[teamName] = savePayload;
localStorage.setItem("savedTeams", JSON.stringify(teams));
    alert(`Team "${teamName}" saved!`);

    showSavedTeams();
    sidebar.classList.add("open");
    menuBtn.style.display = "none";
});

    // wrapper: um passo no sentido horário + housekeeping
  function rotateMainGridClockwise() {
  rotateRingClockwise(1);           // gira o anel (L fica parado)
  const sm = document.getElementById("scrollMenu");
  if (sm) sm.style.display = "none";
  if (typeof updateSynergies === "function") updateSynergies();
  }
    const rotateBtn = document.getElementById("rotateBtn");
  if (rotateBtn) {
  rotateBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      rotateMainGridClockwise();
    });
  }
/* mostra lista de times salvos no painel lateral */
function showSavedTeams() {
    const teams = JSON.parse(localStorage.getItem("savedTeams") || "{}");
    let html = "<h3>Saved teams</h3>";

    if (Object.keys(teams).length === 0) {
        html += "<p>Sem times salvos</p>";
    } else {
        html += `<div class="saved-list">`;
        for (const [name, team] of Object.entries(teams)) {
            html += `
                <div style="margin-bottom:8px; display:flex; align-items:center; justify-content:space-between;">
                    <div style="text-align:left;">
                        <b>${name}</b>
                    </div>
                    <div>
                        <button class="load-btn" data-name="${name}">Load</button>
                        <button class="del-btn" data-name="${name}">Delete</button>
                    </div>
                </div>
            `;
        }
        html += `</div>`;
    }

    sidebarContent.innerHTML = html;


    document.querySelectorAll(".load-btn").forEach(btn => {
        btn.addEventListener("click", (e) => {
        e.stopPropagation();
        const name = btn.dataset.name;
        loadTeam(name);

        // Atualiza sinergias e mantém menu aberto na lista
        updateSynergies();
        sidebar.classList.add("open");
        menuBtn.style.display = "none";
        });
    });

    document.querySelectorAll(".del-btn").forEach(btn => {
        btn.addEventListener("click", (e) => {
            e.stopPropagation();
            const name = btn.dataset.name;
            if (confirm(`Delete team "${name}"?`)) {
                deleteTeam(name);
                showSavedTeams();
            }
        });
    });
}

function deleteTeam(name) {
    let teams = JSON.parse(localStorage.getItem("savedTeams") || "{}");
    delete teams[name];
    localStorage.setItem("savedTeams", JSON.stringify(teams));
}

/* Carrega time — monta usando setCharacter... */
function loadTeam(name) {
  equipState.clear();  // evita lixo de items grudado em slots antigos
  const teams = JSON.parse(localStorage.getItem("savedTeams") || "{}");
  const team = teams[name];
  if (!team) return;

  selecionados = [];

  // limpa grid e bench
  document.querySelectorAll(".hex, .bench-slot").forEach(slot => {
    slot.innerHTML = "";
    delete slot.dataset.nome;
    const infoDiv = slot.parentElement.querySelector('.player-info');
    if (infoDiv) {
      if (slot.classList.contains("bench-slot")) infoDiv.textContent = "Bench"; // ou "Bench"
      else infoDiv.textContent = slot.dataset.role || slot.getAttribute("data-role") || "";
    }
  });

  // 🔧 NOVO: alinhar orientação do grid ao time salvo
  orientGridToSavedTeam(team);

  // agora preenche titulares nos índices do time salvo
  const hexes = Array.from(document.querySelectorAll(".hex"));
  team.main.forEach((nome, i) => {
    if (!nome) return;
    const personagem = characters.find(p => p.nome === nome);
    if (personagem && hexes[i]) {
      setCharacter(hexes[i], personagem, hexes[i].dataset.role || hexes[i].getAttribute("data-role"));
    }
  });

    const benches = Array.from(document.querySelectorAll(".bench-slot"));
    team.bench.forEach((nome, i) => {
        if (!nome) return;
        const personagem = characters.find(p => p.nome === nome);
        if (personagem && benches[i]) {
            setCharacter(benches[i], personagem, 'bench');
            attachBenchEvents(benches[i]);
        }
    });

    equipState.clear();                 // (garante que nada antigo fique no Map)
    restoreTeamItems(team.items);       // <- aplica memories/potentials
    updateSynergies();
}

/* ====== ABRIR / FECHAR MENU ====== */
const menuBtn = document.getElementById("menuBtn");
const sidebar = document.getElementById("sidebar");
const closeSidebar = document.getElementById("closeSidebar");

menuBtn.addEventListener("click", (e) => {
    e.stopPropagation();
    sidebar.classList.add("open");
    menuBtn.style.display = "none";
});

closeSidebar.addEventListener("click", (e) => {
    e.stopPropagation();
    sidebar.classList.remove("open");
    menuBtn.style.display = "block";
});

// Fecha se clicar fora do painel (ignora se clicar dentro)
document.addEventListener("click", (e) => {
    // Clique dentro do sidebar ou no botão de abrir → não fecha
    if (sidebar.contains(e.target) || e.target === menuBtn) {
        return;
    }

    // Clique num personagem → não fecha
   if (e.target.closest(".char-card, .person-card, #charList")) {
  return;
}

    // Clique em botões de voltar (FAQ, Credits, Synergies, Detalhes) → não fecha
    if (
        e.target.closest("#backToHelp") ||
        e.target.closest("#backToSynergies") ||
        e.target.closest("#backToChar")
    ) {
        return;
    }

    // Fecha apenas se realmente foi fora
    if (sidebar.classList.contains("open")) {
        sidebar.classList.remove("open");
        menuBtn.style.display = "block";
    }
});
    // Botão para limpar todo o time e resetar o banco
    document.getElementById("clearTeamBtn").addEventListener("click", (e) => {
    e.stopPropagation();
    if (!confirm("Are you sure you want to reset court and bench?")) return;

    // Fecha o Side Menu se estiver aberto
    sidebar.classList.remove("open");
    menuBtn.style.display = "block";

    // Limpa seleção
    selecionados = [];
    equipState.clear();
    document.querySelectorAll('.hex, .bench-slot')
   .forEach(el => el.querySelectorAll('.item-badge,.item-gear').forEach(n => n.remove()));

    clearAllEquips();
    document.querySelectorAll('.hex, .bench-slot').forEach(el => {
    if (el.dataset.nome || el.dataset.charName) removeCharacter(el);
});
    // Reseta todos os slots principais
    document.querySelectorAll(".hex").forEach(slot => {
        slot.innerHTML = "";
        delete slot.dataset.nome;
        const infoDiv = slot.parentElement.querySelector('.player-info');
        infoDiv.textContent = slot.dataset.role || slot.getAttribute("data-role") || "";
    });

    // Reseta banco para 3 slots
    const benchRow = document.getElementById("bench-row");
    benchRow.querySelectorAll(".player-slot.bench").forEach((benchSlot, index) => {
        if (index >= 3) {
            benchSlot.remove();
        } else {
            const slot = benchSlot.querySelector(".bench-slot");
            slot.innerHTML = "";
            delete slot.dataset.nome;
            const infoDiv = benchSlot.querySelector('.player-info');
            infoDiv.textContent = "Bench";
        }
    });
    updateSynergies();
    });
    /* ===================== ITEMS: Memory + Potential (4p/2p) ===================== */

/** Estat keys do seu dataset */
const STAT_KEYS = ["Serve","Spike","Set","Receive","Block","Save"];

/** Estado por slot: { memoryId, set4, set2 } */
const equipState = new Map();

/** Utils de slot */
function getSlotId(el){
  if(!el.dataset.slotId){
    const prefix = el.classList.contains('bench-slot') ? 'bench' : 'court';
    const all = [...document.querySelectorAll('.hex, .bench-slot')];
    const idx = all.indexOf(el);
    el.dataset.slotId = `${prefix}-${idx >= 0 ? idx : Math.random().toString(36).slice(2,8)}`;
  }
  return el.dataset.slotId;
}
function getSlotChar(el){ return el?.dataset?.charName || null; }
function findCharacterByName(name){ return characters.find(c => c.nome === name) || null; }

/** Aplicadores de bônus */
function applyBonus(twoPiece, bonus){
  if(!bonus) return;
  for(const [stat, mod] of Object.entries(bonus)){
    if(twoPiece[stat] == null) continue;
    if(mod.pct)  twoPiece[stat] = Math.round(twoPiece[stat]*(1+mod.pct/100));
    if(mod.flat) twoPiece[stat] = Math.max(0, twoPiece[stat]+mod.flat);
  }
}
function computeEffectiveStats(baseStats, memoryId, set4Id, set2Id){
  const out = { ...baseStats};
  // Memory
  if(memoryId){
    const mem = memoryCatalog.find(m=>m.id===memoryId);
    if(mem) applyBonus(out, mem.bonus);
  }
  // Potential (sets)
  if(set2Id){
    const s2 = setCatalog.find(s=>s.id===set2Id);
    if(s2) applyBonus(out, s2.twoPiece);
  }
  if(set4Id){
    const s4 = setCatalog.find(s=>s.id===set4Id);
    if(s4){
      // comportamento comum: 4p também concede o 2p do mesmo set
      if(!set2Id || set2Id===set4Id) applyBonus(out, s4.twoPiece);
      applyBonus(out, s4.fourPiece);
    }
  }
  return out;
}


// normaliza função (role) do personagem para os códigos do catálogo
function normalizeRole(role){
  const r = String(role||"").toLowerCase();
  if (["s","setter","levantador"].includes(r)) return "S";
  if (["mb","middle","middle blocker","central","meio"].includes(r)) return "MB";
  if (["ws","wing","wing spiker","ponteiro","ponta"].includes(r)) return "WS";
  if (["op","opposite","oposto"].includes(r)) return "OP";
  if (["l","libero","líbero","libero"].includes(r)) return "L";
  return role || "WS"; // fallback
}

// pega % de um bônus {pct} dado um stat
function pctOf(obj, key){
  return (obj && obj[key] && typeof obj[key].pct === "number") ? obj[key].pct : 0;
}

// normaliza nomes p/ casar personagem com memória
function norm(s){
  return (s||"").toLowerCase()
    .normalize('NFD').replace(/[\u0300-\u036f]/g,'') // sem acento
    .replace(/[^\p{L}\p{N}]+/gu,' ')                 // sem pontuação
    .trim();
}
function recommendMemoryForCharacter(ch, allowedMem){
  if (!allowedMem || allowedMem.length === 0) return null;
  const cname = norm(ch.nome || ch.name);

  // 1) owner explícito (se você usa esse campo)
  let cand = allowedMem.find(m => m.owner && norm(m.owner) === cname);
  if (cand) return cand.id;

  // 2) nome/id contém o nome do personagem (ex.: "Ushijima UR")
  cand = allowedMem.find(m => norm(m.name).includes(cname) || norm(m.id).includes(cname.replace(/\s+/g,'_')));
  if (cand) return cand.id;

  // 3) todos os tokens do nome do personagem aparecem no nome da memória
  const tokens = cname.split(' ').filter(Boolean);
  cand = allowedMem.find(m => tokens.every(t => norm(m.name).includes(t)));
  if (cand) return cand.id;

  // 4) fallback: primeira compatível
  return allowedMem[0]?.id || null;
}


function topStatKey(stats){
  let bestK=null, bestV=-Infinity;
  for(const k of STAT_KEYS){
    const v = typeof stats?.[k] === "number" ? stats[k] : -Infinity;
    if (v > bestV){ bestV=v; bestK=k; }
  }
  return bestK;
}

function totalPctForCombo(set4, set2, statKey){
  let total = 0;
  if (set4){
    // 4p concede 2p do mesmo set quando não há 2p selecionado ou quando é o mesmo set
    if ((!set2 || set2.id === set4.id) && set4.twoPiece) total += pctOf(set4.twoPiece, statKey);
    if (set4.fourPiece) total += pctOf(set4.fourPiece, statKey);
  }
  if (set2 && (!set4 || set2.id !== set4.id) && set2.twoPiece){
    total += pctOf(set2.twoPiece, statKey);
  }
  return total;
}

// util: pega % de um bônus para um stat
function pctOf(obj, key){
  return (obj && obj[key] && typeof obj[key].pct === 'number') ? obj[key].pct : 0;
}
// util: qual o maior stat base do personagem
function topStatKey(stats){
  let bestK=null, bestV=-Infinity;
  for(const k of STAT_KEYS){
    const v = typeof stats?.[k] === "number" ? stats[k] : -Infinity;
    if (v > bestV){ bestV=v; bestK=k; }
  }
  return bestK;
}

function recommendSetsByTopStat(ch, allowedSet){
  if (!allowedSet || allowedSet.length === 0) return { set4:null, set2:null };

  // helpers locais
  const findSetIdByName = (arr, name) => {
    const n = (name||"").toLowerCase();
    const hit = arr.find(s =>
      (s.name && s.name.toLowerCase() === n) ||
      (s.id   && s.id.toLowerCase()   === n)
    );
    return hit ? hit.id : null;
  };
  const hasSymbol = (sym) => Array.isArray(ch.symbols) && ch.symbols.includes(sym);

  // escolhe o melhor 4p e 2p para um stat (mantém a sua regra anterior)
  const bestByStat = (statKey) => {
    let best4 = null, best4Score = -Infinity;
    for (const s4 of allowedSet){
      const score = pctOf(s4.twoPiece, statKey) + pctOf(s4.fourPiece, statKey);
      if (score > best4Score){ best4Score = score; best4 = s4; }
    }
    let best2 = null, best2Score = -Infinity;
    for (const s2 of allowedSet){
      if (best4 && s2.id === best4.id) continue;      // 2p diferente do 4p
      const score = pctOf(s2.twoPiece, statKey);
      if (score > best2Score){ best2Score = score; best2 = s2; }
    }
    return { set4: best4?.id || null, set2: best2?.id || null };
  };

  const role = normalizeRole(ch.funcao); // já existe no seu código
  const top  = topStatKey(ch.Stats || {}); // já existe no seu código

  // --- Regra 1: Setters (S) têm recomendação fixa
  if (role === 'S'){ // Ex.: é montado a partir de ch.funcao na abertura do modal
    const s4 = findSetIdByName(allowedSet, 'Precise Set');
    const s2 = findSetIdByName(allowedSet, 'Precise Serve');
    return { set4: s4, set2: (s2 && s2 !== s4) ? s2 : null };
  }

  // --- Regra 3: maior atributo = Spike -> símbolos "quick" ou "power"
  if (top === 'Spike'){
    if (hasSymbol('img/quicksymbol.png')){
      const s4 = findSetIdByName(allowedSet, 'Rapid Quick Attack');
      const s2 = findSetIdByName(allowedSet, 'Sharp Sense');
      if (s4 || s2) return { set4: s4, set2: (s2 && s2 !== s4) ? s2 : null };
      // se não achar pelos nomes (catálogo diferente), cai no fallback
    }
    if (hasSymbol('img/powersymbol.png')){
      const s4 = findSetIdByName(allowedSet, 'Power Vibe');
      const s2 = findSetIdByName(allowedSet, 'Power Rise');
      if (s4 || s2) return { set4: s4, set2: (s2 && s2 !== s4) ? s2 : null };
    }
  }

  // --- Regra 2 (fallback): como antes, escolher pelo maior atributo
  return bestByStat(top || 'Spike'); // se não houver top claro, Spike como padrão
}

// helper p/ gerar HTML de um ícone com etiqueta opcional
function badgeIconHTML(src, title, tagText){
  if(!src) return "";
  return `
    <span class="ico" title="${title || ""}">
      <img src="${src}" alt="">
      ${tagText ? `<span class="tag">${tagText}</span>` : ""}
    </span>`;
}

function updateItemBadge(slotEl){
  // remove a badge anterior
  slotEl.querySelectorAll('.item-badge').forEach(n=>n.remove());

  // não mostra badge se o slot estiver vazio
  if(!slotEl.dataset.charName) return;

  const slotId = getSlotId(slotEl);
  const eq = equipState.get(slotId);
  if(!eq) return;

  const mem = eq.memoryId ? memoryCatalog.find(m=>m.id===eq.memoryId) : null;
  const s4  = eq.set4      ? setCatalog.find(s=>s.id===eq.set4)       : null;
  const s2  = eq.set2      ? setCatalog.find(s=>s.id===eq.set2)       : null;

  if(!mem && !s4 && !s2) return;

  const badge = document.createElement('div');
  badge.className = 'item-badge';

  // ÍCONES (sem texto). Etiqueta pequena: "M", "4", "2" (remova se não quiser nada)
  const parts = [];
  if(mem) parts.push(badgeIconHTML(mem.img,  `Memory: ${mem.name}`,          "M"));
  if(s4)  parts.push(badgeIconHTML(s4.img,   `Potential 4-Piece: ${s4.name}`, "4"));
  if(s2)  parts.push(badgeIconHTML(s2.img,   `Potential 2-Piece: ${s2.name}`, "2"));

  badge.innerHTML = parts.join("");
  slotEl.appendChild(badge);
}

/** Botão ⚙️ para abrir o modal (não conflita com seu dblclick de Details) */
function ensureItemGear(slotEl){
  if(slotEl.querySelector('.item-gear')) return;
  if(!slotEl.dataset.charName) return;
  const btn = document.createElement('button');
  btn.type = 'button';
  btn.className = 'item-gear';
  btn.title = 'Items (Memory + Potential)';
  btn.innerHTML = '⚙️';
  btn.addEventListener('click', (e)=>{ e.stopPropagation(); e.preventDefault(); openItemModal(slotEl); });
  slotEl.appendChild(btn);
}
function removeItemGear(slotEl){ slotEl.querySelectorAll('.item-gear').forEach(n=>n.remove()); }

/** MODAL com Memory + Potential (4p/2p) */
function openItemModal(slotEl){
  const charName = getSlotChar(slotEl);
  if(!charName){ alert('Coloque um personagem no slot antes de equipar.'); return; }
  const ch = findCharacterByName(charName);
  if(!ch){ alert('Personagem não encontrado.'); return; }

  const slotId = getSlotId(slotEl);
  const current = equipState.get(slotId) || { memoryId:null, set4:null, set2:null };

  const role = normalizeRole(ch.funcao);
const allowedMem = memoryCatalog.filter(m => m.positions?.includes(role));
const allowedSet = setCatalog.filter(s => !s.positions || s.positions.includes(role));

  const $back = document.createElement('div'); $back.className = 'item-modal-backdrop';
  const $box  = document.createElement('div'); $box.className  = 'item-modal';
  $back.appendChild($box);

  $box.innerHTML = `
  <h3>Items for <b>${ch.nome}</b> (${ch.funcao})</h3>

   <div class="items-3col">
    <div class="row-3col">
      <div class="label">Memory</div>
      <img id="memThumb" class="big-thumb" src="" alt="">
      <div>
        <select id="memSel" class="select-wide">
          <option value="">— none —</option>
          ${allowedMem.map(m=>`<option value="${m.id}" ${m.id===current.memoryId?'selected':''}>${m.name}</option>`).join('')}
        </select>
        <div id="memDesc" class="subdesc"></div>
      </div>
    </div>

    <div class="row-3col">
      <div class="label">4-Piece</div>
      <img id="set4Thumb" class="big-thumb" src="" alt="">
      <div>
        <select id="set4Sel" class="select-wide">
          <option value="">— none —</option>
          ${allowedSet.map(s=>`<option value="${s.id}" ${s.id===current.set4?'selected':''}>${s.name}</option>`).join('')}
        </select>
        <div id="set4Desc" class="subdesc"></div>
      </div>
    </div>

    <div class="row-3col">
      <div class="label">2-Piece</div>
      <img id="set2Thumb" class="big-thumb" src="" alt="">
      <div>
        <select id="set2Sel" class="select-wide">
          <option value="">— none —</option>
          ${allowedSet.map(s=>`<option value="${s.id}" ${s.id===current.set2?'selected':''}>${s.name}</option>`).join('')}
        </select>
        <div id="set2Desc" class="subdesc"></div>
      </div>
    </div>

    <div class="row-3col">
      <div class="label">Stats</div>
      <div></div>
      <div><ul id="statsList" class="stats-list"></ul></div>
    </div>
  </div>

  <div class="item-actions">
    <button class="item-btn" id="btnRec">Recommend</button>
    <button class="item-btn" id="btnClear">Clear</button>
    <button class="item-btn" id="btnSave">Save</button>
    <button class="item-btn" id="btnClose">Close</button>
  </div>
`;
  document.body.appendChild($back);

  const $mem  = $box.querySelector('#memSel');
  const $mD   = $box.querySelector('#memDesc');
  const $set4 = $box.querySelector('#set4Sel');
  const $set2 = $box.querySelector('#set2Sel');
  const $d4   = $box.querySelector('#set4Desc');
  const $d2   = $box.querySelector('#set2Desc');
  const $statsList = $box.querySelector('#statsList');
  const $memThumb  = $box.querySelector('#memThumb');
  const $set4Thumb = $box.querySelector('#set4Thumb');
  const $set2Thumb = $box.querySelector('#set2Thumb');

  function getSetBonusPct(statKey){
  let total = 0;
  const s4 = setCatalog.find(s => s.id === $set4.value);
  const s2 = setCatalog.find(s => s.id === $set2.value);

  if (s4){
    if (s4.twoPiece && s4.twoPiece[statKey] && typeof s4.twoPiece[statKey].pct === "number")
      total += s4.twoPiece[statKey].pct;   // 2p “embutido” no 4p
    if (s4.fourPiece && s4.fourPiece[statKey] && typeof s4.fourPiece[statKey].pct === "number")
      total += s4.fourPiece[statKey].pct;  // 4p
  }
  // só soma 2p diferente do 4p
  if (s2 && (!s4 || s2.id !== s4.id)){
    if (s2.twoPiece && s2.twoPiece[statKey] && typeof s2.twoPiece[statKey].pct === "number")
      total += s2.twoPiece[statKey].pct;
  }
  return total;
}

  function refreshThumbs(){
  const mem = memoryCatalog.find(m=>m.id===$mem.value);
  const s4  = setCatalog.find(s=>s.id===$set4.value);
  const s2  = setCatalog.find(s=>s.id===$set2.value);
  $memThumb.src  = mem?.img  || "";
  $set4Thumb.src = s4?.img   || "";
  $set2Thumb.src = s2?.img   || "";
}

  function renderChoice($el, item, fallbackTitle){
  if(item){
    $el.classList.remove('empty');
    $el.querySelector('img').src = item.img || "";
    $el.querySelector('.title').textContent = item.name;
    $el.querySelector('.subtitle').textContent = item.short || ""; // opcional
  }else{
    $el.classList.add('empty');
    $el.querySelector('img').src = "";
    $el.querySelector('.title').textContent = fallbackTitle || "— none —";
    $el.querySelector('.subtitle').textContent = "";
  }
}

function refreshChoices(){
  const mem = memoryCatalog.find(m=>m.id===$mem.value);
  const s4  = setCatalog.find(s=>s.id===$set4.value);
  const s2  = setCatalog.find(s=>s.id===$set2.value);
  renderChoice($box.querySelector('#memChoice'),  mem, "— none —");
  renderChoice($box.querySelector('#set4Choice'), s4,  "— none —");
  renderChoice($box.querySelector('#set2Choice'), s2,  "— none —");
}
  function updateSetLocks(){
  const v4 = $set4.value, v2 = $set2.value;
  [...$set2.options].forEach(o => o.disabled = !!v4 && o.value === v4 && o.value !== "");
  [...$set4.options].forEach(o => o.disabled = !!v2 && o.value === v2 && o.value !== "");
}
$set4.addEventListener('change', ()=>{ updateSetLocks(); refreshDescs(); renderStats(); });
$set2.addEventListener('change', ()=>{ updateSetLocks(); refreshDescs(); renderStats(); });
updateSetLocks();

  function refreshDescs(){
  const mem = memoryCatalog.find(m=>m.id===$mem.value);
  const s4  = setCatalog.find(s=>s.id===$set4.value);
  const s2  = setCatalog.find(s=>s.id===$set2.value);
  $mD.textContent = mem ? (mem.desc || '') : '';
  $d4.textContent = s4 ? (s4.desc4 || '') : '';
  $d2.textContent = s2 ? (s2.desc2 || '') : '';
  refreshThumbs();
}
// Retorna quanto a Memory soma EM PONTOS para um stat específico
function getMemoryBonusAbs(statKey){
  const mem = memoryCatalog.find(m=>m.id===$mem.value);
  if(!mem || !mem.bonus || !mem.bonus[statKey]) return 0;
  const base = ch.Stats[statKey] || 0;
  const mod  = mem.bonus[statKey];
  const pct  = mod.pct ? Math.round(base * (mod.pct/100)) : 0;
  const flat = mod.flat ? mod.flat : 0;
  return pct + flat; // valor absoluto adicionado pela memória
}

// Retorna o TOTAL de % dos sets (2p/4p) efetivamente aplicados para o stat
function getSetBonusPct(statKey){
  let total = 0;

  const s4 = setCatalog.find(s=>s.id===$set4.value);
  const s2 = setCatalog.find(s=>s.id===$set2.value);

  // 4p selecionado: normalmente concede o 2p do mesmo set se o 2p não estiver escolhido
  if(s4){
    // aplica 2p do 4p quando NÃO há set2 OU quando set2 é o mesmo set
    if((!s2 || s2.id === s4.id) && s4.twoPiece && s4.twoPiece[statKey]?.pct){
      total += s4.twoPiece[statKey].pct;
    }
    // aplica 4p
    if(s4.fourPiece && s4.fourPiece[statKey]?.pct){
      total += s4.fourPiece[statKey].pct;
    }
  }

  // 2p de um set diferente do 4p
  if(s2 && (!s4 || s2.id !== s4.id)){
    if(s2.twoPiece && s2.twoPiece[statKey]?.pct){
      total += s2.twoPiece[statKey].pct;
    }
  }

  return total; // só porcentagem
}

  // helper para considerar 0, 0.0, null etc.
function zeroish(x){ return !x || Math.abs(x) < 1e-6; }

function renderStats(){
  const rows = STAT_KEYS.map((k)=>{
    const base   = ch.Stats[k] || 0;
    const memAbs = getMemoryBonusAbs(k);   // pontos absolutos da Memory
    const setPct = getSetBonusPct(k);      // % total dos sets para esse stat

    const parts = [String(base)];
    if (!zeroish(memAbs)) parts.push(`+ ${memAbs}`);
    if (!zeroish(setPct)) parts.push(`+ ${setPct}%`); // só mostra se > 0%

    return `<li><b>${k}:</b> ${parts.join(' ')}</li>`;
  }).join('');
  $statsList.innerHTML = rows;
}

  $mem.addEventListener('change', ()=>{ refreshDescs(); renderStats(); });
  $set4.addEventListener('change', ()=>{ updateSetLocks(); refreshDescs(); renderStats(); });
  $set2.addEventListener('change', ()=>{ updateSetLocks(); refreshDescs(); renderStats(); });
  updateSetLocks();refreshDescs(); renderStats();

  $box.querySelector('#btnClose').onclick = ()=> $back.remove();
  $box.querySelector('#btnClear').onclick = ()=>{
    $mem.value=""; $set4.value=""; $set2.value="";
    refreshDescs(); renderStats();
  };
  $box.querySelector('#btnSave').onclick = ()=>{
    const data = { memoryId: $mem.value || null, set4: $set4.value || null, set2: $set2.value || null };
    equipState.set(slotId, data);
    updateItemBadge(slotEl);
    $back.remove();
  };
  $box.querySelector('#btnRec').onclick = ()=>{
  const memId = recommendMemoryForCharacter(ch, allowedMem);
  const rec   = recommendSetsByTopStat(ch, allowedSet);

  if (memId) $mem.value = memId;
  if (rec.set4) $set4.value = rec.set4;
  $set2.value = rec.set2 || "";           // sempre tenta diferente; se não houver, fica vazio

  updateSetLocks();                        // mantém 4p/2p mutuamente exclusivos na UI
  refreshDescs();
  renderStats();
};
}

/** Hooks para seu fluxo atual */
window.afterAssignCharacter = function(slotEl, charName){
  slotEl.dataset.charName = charName;
  updateItemBadge(slotEl);
  ensureItemGear(slotEl); // botão ⚙️ para abrir o modal (não conflita com dblclick de detalhes)
};
window.afterRemoveCharacter = function(slotEl){
  delete slotEl.dataset.charName;   // mantém compatibilidade com suas badges
  clearSlotEquip(slotEl);           // <- limpa Map + badges/engrenagem
  updateItemBadge(slotEl);          // defensivo (como já faz no assign)
};

// Guarda por slot, mas também salva o nome do char para restaurar por nome
function serializeTeamItems(){
  const data = {};
  document.querySelectorAll('.hex, .bench-slot').forEach(el=>{
    const id = getSlotId(el);
    const charName = el.dataset.charName || el.dataset.nome || null;
    if (!charName) return;
    const eq = equipState.get(id) || { memoryId:null, set4:null, set2:null };
    data[id] = { charName, ...eq };
  });
  return data;
}

// Ao carregar: 1) limpa tudo; 2) tenta aplicar itens pelo NOME do char.
// Se não achar o nome no grid atual, cai no slot salvo (fallback).
function restoreTeamItems(saved){
  clearAllEquips();
  if (!saved) return;

  const allSlots = Array.from(document.querySelectorAll('.hex, .bench-slot'));

  // mapa rápido: nome -> slot atual
  const byName = new Map();
  allSlots.forEach(el=>{
    const n = el.dataset.charName || el.dataset.nome || null;
    if (n) byName.set(n, el);
  });

  for (const [slotId, payload] of Object.entries(saved)){
    const target =
      byName.get(payload.charName) ||
      allSlots.find(e => getSlotId(e) === slotId);

    if (!target) continue;

    const id = getSlotId(target);
    equipState.set(id, {
      memoryId: payload.memoryId || null,
      set4:     payload.set4     || null,
      set2:     payload.set2     || null
    });
    updateItemBadge(target);
    ensureItemGear(target);
  }
}
// ========= DRAG & DROP (compatível com sua estrutura) =========
(function(){
  if (window.__dndFix) return; window.__dndFix = true;

  const getChar = n => characters.find(c => c.nome === n);
  let dragCtx = null; // {type:'character'|'slot', nome?, id?}

  function setDragCtx(obj, e){
    dragCtx = obj;
    try { e.dataTransfer.setData('application/json', JSON.stringify(obj)); } catch(_) {}
    try { e.dataTransfer.setData('text/plain', JSON.stringify(obj)); } catch(_) {}
    e.dataTransfer.effectAllowed = (obj.type === 'slot') ? 'move' : 'copyMove';
  }
  function isAllowedForStarterSlot(slotRole, charRole) {
  if (!slotRole || slotRole === 'bench') return true; // não é starter
  if (slotRole === 'L') return charRole === 'L';
  return charRole !== 'L';
}

  function canDropCharOn(slot, p){
  const isBench = slot.classList.contains('bench-slot');
  if (isBench) return respeitaLimiteBench(p, slot);

  const role = (slot.dataset.role || slot.getAttribute('data-role') || '').toUpperCase();
  if (role === 'L') return p.funcao === 'L';  // Líbero só no L
  return p.funcao !== 'L';                    // demais titulares: qualquer NÃO-L
}

  function dropCharacterOn(slot, p) {
  // zera items pendurados nesse slot (é um overwrite vindo do menu)
  equipState.delete(getSlotId(slot));

  const isBench = slot.classList.contains('bench-slot');
  const role = isBench ? 'bench' : (slot.dataset.role || slot.getAttribute('data-role'));
  setCharacter(slot, p, role);

  const sm = document.getElementById("scrollMenu");
  if (sm) sm.style.display = "none";
}
 // Helper: pega o personagem de um slot (titular ou banco)
function getCharacterFromSlot(el){
  if (!el) return null;
  const n = el.dataset?.nome || el.dataset?.charName || null;
  return n ? (characters.find(c => c.nome === n) || null) : null;
}

  // Troca/move entre slots (qualquer posição entre si, exceto L só em L)
function moveBetweenSlots(srcEl, dstEl){
  if (!srcEl || !dstEl || srcEl === dstEl) return;

  const pSrc = getCharacterFromSlot(srcEl);
  const pDst = getCharacterFromSlot(dstEl);
  if (!pSrc && !pDst) return;   // nada para fazer
  if (!pSrc) return;            // origem vazia (arraste inválido)

  const srcIsBench = srcEl.classList.contains('bench-slot');
  const dstIsBench = dstEl.classList.contains('bench-slot');

  const srcRole = ((srcEl.dataset.role || srcEl.getAttribute('data-role') || '') + '').toUpperCase();
  const dstRole = ((dstEl.dataset.role || dstEl.getAttribute('data-role') || '') + '').toUpperCase();

  // Regras dos titulares: L só em L; demais titulares: qualquer NÃO-L
  function allowedForStarter(slotRole, charRole){
    if (!slotRole || slotRole === 'BENCH') return true;
    if (slotRole === 'L') return charRole === 'L';
    return charRole !== 'L';
  }

  // 1) Validar destino para pSrc
  if (dstIsBench) {
    if (!respeitaLimiteBench(pSrc, dstEl)) return;
  } else {
    if (!allowedForStarter(dstRole, pSrc.funcao)) return;
  }

  // 2) Se houver pDst (swap), validar “volta” para pDst
  if (pDst){
    if (srcIsBench) {
      if (!respeitaLimiteBench(pDst, srcEl)) return;
    } else {
      if (!allowedForStarter(srcRole, pDst.funcao)) return;
    }
  }

  // --- Itens (equipState): preparar ids e estados
  const srcId = getSlotId(srcEl);
  const dstId = getSlotId(dstEl);
  const srcEq = equipState.get(srcId) || null;
  const dstEq = equipState.get(dstId) || null;

  const srcKeepRole = srcIsBench ? 'bench' : srcRole;
  const dstKeepRole = dstIsBench ? 'bench' : dstRole;

  if (pDst){
    // SWAP: troca itens também
    if (srcEq) equipState.set(dstId, srcEq); else equipState.delete(dstId);
    if (dstEq) equipState.set(srcId, dstEq); else equipState.delete(srcId);

    removeCharacter(srcEl);
    removeCharacter(dstEl);
    setCharacter(srcEl, pDst, srcKeepRole);
    setCharacter(dstEl, pSrc, dstKeepRole);
  } else {
    // MOVE: leva itens juntos
    const keep = srcEq ? { ...srcEq } : null;
    equipState.delete(srcId);
    if (keep) equipState.set(dstId, keep);

    removeCharacter(srcEl);
    setCharacter(dstEl, pSrc, dstKeepRole);
  }

  // Atualiza badges/engrenagem (seu fluxo atual)
  if (typeof updateItemBadge === 'function') { updateItemBadge(srcEl); updateItemBadge(dstEl); }
  if (typeof ensureItemGear   === 'function') { ensureItemGear(srcEl); ensureItemGear(dstEl); }
}

  function decorateDropTarget(slot){
    slot.addEventListener('dragover', (e)=>{
      // permita o drop SEM depender de getData()
      e.preventDefault();
      const ctx = dragCtx;
      let ok = false;
      if (ctx?.type === 'character'){
        const p = getChar(ctx.nome);
        ok = !!p && canDropCharOn(slot, p);
      } else if (ctx?.type === 'slot'){
        const srcEl = Array.from(document.querySelectorAll('.hex, .bench-slot')).find(el => getSlotId(el) === ctx.id);
        const p = srcEl?.dataset.nome ? getChar(srcEl.dataset.nome) : null;
        ok = !!p && (slot === srcEl || canDropCharOn(slot, p));
      }
      slot.classList.toggle('drop-ok', ok);
      slot.classList.toggle('drop-bad', ctx && !ok);
    });

    slot.addEventListener('dragleave', ()=> slot.classList.remove('drop-ok','drop-bad'));

    slot.addEventListener('drop', (e)=>{
      e.preventDefault();
      slot.classList.remove('drop-ok','drop-bad');
      const ctx = dragCtx; dragCtx = null; // consome o contexto

      if (!ctx) return;
      if (ctx.type === 'character'){
        const p = getChar(ctx.nome);
        if (p && canDropCharOn(slot, p)) dropCharacterOn(slot, p);
      } else if (ctx.type === 'slot'){
        const srcEl = Array.from(document.querySelectorAll('.hex, .bench-slot')).find(el => getSlotId(el) === ctx.id);
        if (srcEl) moveBetweenSlots(srcEl, slot);
      }
    });

    // habilita arrastar a partir do slot quando tiver personagem
    const refresh = ()=> slot.setAttribute('draggable', slot.dataset.nome ? 'true' : 'false');
    refresh();
    slot.addEventListener('dragstart', (e)=>{
      if (!slot.dataset.nome) return;
      setDragCtx({ type:'slot', id:getSlotId(slot), nome:slot.dataset.nome }, e);
    });

    // atualiza o draggable quando setar/remover
    const oldAssign = window.afterAssignCharacter;
    window.afterAssignCharacter = function(el, name){
      if (typeof oldAssign === 'function') oldAssign(el, name);
      if (el === slot) slot.setAttribute('draggable','true');
    };
    const oldRemove = window.afterRemoveCharacter;
    window.afterRemoveCharacter = function(el){
      if (typeof oldRemove === 'function') oldRemove(el);
      if (el === slot) slot.setAttribute('draggable','false');
    };
  }

  function decorateAll(){ document.querySelectorAll('.hex, .bench-slot').forEach(decorateDropTarget); }

  function initDnd(){
    // 1) Fontes: **#charList** (lista do menu lateral)
    const list = document.getElementById('charList');
    if (list){
      list.addEventListener('dragstart', (e)=>{
        const img = e.target.closest('img'); if (!img) return;
        const nome = img.alt || img.title;
        if (getChar(nome)) { img.setAttribute('draggable','true'); setDragCtx({type:'character', nome}, e); }
      });
      list.querySelectorAll('img').forEach(img => img.setAttribute('draggable','true'));
    }

    // 2) Fontes: #scrollMenu (seu menu flutuante por posição)
    const sm = document.getElementById('scrollMenu');
    if (sm){
      sm.addEventListener('dragstart', (e)=>{
        const img = e.target.closest('img'); if (!img) return;
        const nome = img.alt || img.title;
        if (getChar(nome)) { img.setAttribute('draggable','true'); setDragCtx({type:'character', nome}, e); }
      });
      sm.querySelectorAll('img').forEach(img => img.setAttribute('draggable','true'));
    }

    // 3) Alvos e fontes: quadra + banco
    decorateAll();

    // redecorar após rotacionar (se você rotaciona os hex com innerHTML)
    if (typeof window.rotateRingClockwise === 'function' && !window.__dndWrapRot){
      const old = window.rotateRingClockwise;
      window.rotateRingClockwise = function(){
        const r = old.apply(this, arguments);
        try { RING_IDX.map(i => document.querySelectorAll('.hex')[i]).forEach(decorateDropTarget); }
        catch(_) { decorateAll(); }
        return r;
      };
      window.__dndWrapRot = true;
    }

    // redecorar após adicionar novo slot de bench
    if (typeof window.addBenchSlot === 'function' && !window.__dndWrapAdd){
      const old = window.addBenchSlot;
      window.addBenchSlot = function(){
        const r = old.apply(this, arguments);
        const last = Array.from(document.querySelectorAll('.bench-slot')).pop();
        if (last) decorateDropTarget(last);
        return r;
      };
      window.__dndWrapAdd = true;
    }
  }

  (function bootOnce(){
  function start(){
    if (!window.__dndInited){ window.__dndInited = true; initDnd(); }
    if (!window.__mtInited){ window.__mtInited = true; initMultiTeams(); }
    if (!window.__recoInited){ window.__recoInited = true; bindRecommendControls(); }
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', start);
  } else {
    start();
  }
})();
})();

// === fechar #charList ao clicar fora / ESC, ligado sob demanda ===
(function(){
  let off = null; // guard para remover handlers antigos

  function enableCloseOutsideCharList(){
  if (off) { off(); off = null; }

  const list = document.getElementById('charList');
  if (!list) return;

  const onDown = (e) => {
    // ✅ qualquer clique dentro do sidebar (filtros + lista) NÃO fecha
    if (e.target.closest('#sidebar-content')) return;

    // cliques no link que abre Characters também não fecham
    if (e.target.closest("[data-section='characters'], [data-open-charlist]")) return;

    // ❌ clique realmente fora => fecha
    list.classList.add('is-hidden');
    cleanup();
  };

    const onEsc = (e)=>{
      if (e.key === "Escape") {
        list.classList.add('is-hidden');
        cleanup();
      }
    };

    function cleanup(){
      document.removeEventListener('pointerdown', onDown, true);
      document.removeEventListener('keydown', onEsc);
      off = null;
    }

    document.addEventListener('pointerdown', onDown, true); // captura cedo
    document.addEventListener('keydown', onEsc);

    // fornece um “desligar” externo para quando trocar de seção
    off = cleanup;
  }

  // deixa acessível para chamar ao montar a seção
  window.enableCloseOutsideCharList = enableCloseOutsideCharList;
})();

function clearSlotEquip(slotEl){
  const id = getSlotId(slotEl);
  equipState.delete(id);
  slotEl.querySelectorAll('.item-badge,.item-gear').forEach(n=>n.remove());
}

function clearAllEquips(){
  equipState.clear();
  document.querySelectorAll('.hex, .bench-slot')
    .forEach(el => el.querySelectorAll('.item-badge,.item-gear').forEach(n=>n.remove()));
}

// mover o “equip” junto com o personagem (A -> B), trocando se B já tiver algo
function transferEquipState(fromEl, toEl){
  const a = getSlotId(fromEl);
  const b = getSlotId(toEl);
  const aEq = equipState.get(a) || null;
  const bEq = equipState.get(b) || null;

  if (aEq == null && bEq == null) return;

  // se B já tem alguém, trocamos; se B estava vazio, apenas movemos
  if (bEq != null && aEq != null){
    equipState.set(a, bEq);
    equipState.set(b, aEq);
  } else if (aEq != null){
    equipState.delete(a);
    equipState.set(b, aEq);
  } else { // bEq != null
    equipState.set(a, bEq);
    equipState.delete(b);
  }

  updateItemBadge(fromEl);
  updateItemBadge(toEl);
}
// ===== Recommend: preenche os slots vazios maximizando sinergias =====

// Soma total dos Stats do personagem
function sumStats(p){
  const S = p.Stats || {};
  let total = 0;
  for (const k in S) total += (S[k] || 0);
  return total;
}

// Coleta nomes atuais (starters e bench)
function getCurrentTeamNames(){
  const main = [...document.querySelectorAll('.hex')]
    .map(s => s.dataset.nome).filter(Boolean);
  const bench = [...document.querySelectorAll('.bench-slot')]
    .map(s => s.dataset.nome).filter(Boolean);
  return { main, bench };
}

// Quais slots de titulares estão vazios
function getEmptyStarterSlots(){
  return [...document.querySelectorAll('.hex')].filter(s => !s.dataset.nome);
}

// === Índices de sinergias (construídos 1x) ===
let BOND_INDEX = null;    // { bondName -> Set(nomes) }
let SCHOOL_INDEX = null;  // { schoolName -> Set(nomes) }

function buildSynergyIndices(){
  if (BOND_INDEX && SCHOOL_INDEX) return;
  BOND_INDEX = {};
  SCHOOL_INDEX = {};

  for (const p of characters){
    // Schools
    if (p.School){
      if (!SCHOOL_INDEX[p.School]) SCHOOL_INDEX[p.School] = new Set();
      SCHOOL_INDEX[p.School].add(p.nome);
    }
    // Bonds (vinculo pode ser string ou array)
    const vs = Array.isArray(p.vinculo) ? p.vinculo : (p.vinculo ? [p.vinculo] : []);
    for (const v of vs){
      if (!BOND_INDEX[v]) BOND_INDEX[v] = new Set();
      BOND_INDEX[v].add(p.nome);
    }
  }
}

// Conta quantas sinergias ativas (Schools + Bonds) do time final
// incluem ao menos 1 dos titulares que já estavam no grid (âncora).
function anchoredSynergyScore(activeSchools, activeBonds, oldMainSet){
  let score = 0;

  // Schools: se a school ativa tem pelo menos 1 membro já presente no grid original
  for (const sch of activeSchools){
    const members = SCHOOL_INDEX[sch];
    if (!members) continue;
    for (const name of members){
      if (oldMainSet.has(name)){
        score++;
        break;
      }
    }
  }
  // Bonds: se o bond ativo tem pelo menos 1 participante que já estava no grid original
  for (const bond of activeBonds){
    const members = BOND_INDEX[bond];
    if (!members) continue;
    for (const name of members){
      if (oldMainSet.has(name)){
        score++;
        break;
      }
    }
  }
  return score;
}

// Conta quantas sinergias ficariam ativas com os nomes passados
// (mesma regra do updateSynergies: Schools=starter-only com 4+, Bonds=starter+bench com 2+, exceto algumas que pedem 3)
function computeActivatedSynergyCount(mainNames, benchNames){
  // Mesmas exceções do seu painel
  const bondsRequire3 = new Set(["Natação","Cabeça dos Gêmeos"]);  // idem ao updateSynergies
  const DEFAULT_BOND_MIN = 2;
  const SCHOOL_MIN = 4;

  const SchoolsCount = {};
  const vinculosCount = {};

  // Contagem de School: só starters
  for (const nome of mainNames){
    const p = characters.find(x => x.nome === nome);
    if (!p) continue;
    SchoolsCount[p.School] = (SchoolsCount[p.School] || 0) + 1;
  }

  // Contagem de Bonds: starters + bench
  const allForBonds = [...mainNames, ...benchNames];
  for (const nome of allForBonds){
    const p = characters.find(x => x.nome === nome);
    if (!p) continue;
    const vs = Array.isArray(p.vinculo) ? p.vinculo : (p.vinculo ? [p.vinculo] : []);
    for (const v of vs){
      vinculosCount[v] = (vinculosCount[v] || 0) + 1;
    }
  }

  let count = 0;
  const activeSchools = new Set();
  const activeBonds = new Set();

  // Schools
  for (const school in SchoolsCount){
    if (SchoolsCount[school] >= SCHOOL_MIN){
      count++;
      activeSchools.add(school);
    }
  }
  // Bonds
  for (const v in vinculosCount){
    const required = bondsRequire3.has(v) ? 3 : DEFAULT_BOND_MIN;
    if (vinculosCount[v] >= required){
      count++;
      activeBonds.add(v);
    }
  }

  return { count, activeSchools, activeBonds };
}

// Gera todas as combinações escolhendo 1 candidato por slot (sem repetir nomes)
function* cartesianByIndex(lists){
  // lists: array de arrays (candidatos por slot)
  const idx = lists.map(()=>0);
  const lens = lists.map(l=>l.length);
  if (lens.some(len => len===0)) return;

  while (true){
    // combinação atual
    const combo = lists.map((l,i)=>l[idx[i]]);
    // valida duplicados de nomes
    const names = new Set(combo.map(c=>c.nome));
    if (names.size === combo.length) yield combo;

    // próximo índice (odômetro)
    let k = lists.length - 1;
    while (k >= 0){
      idx[k]++;
      if (idx[k] < lens[k]) break;
      idx[k] = 0;
      k--;
    }
    if (k < 0) break;
  }
}
// Contagens de school/bond a partir de conjuntos de nomes (starters e bench)
function synergyCounts(startersSet, benchSet){
  const all = new Set(startersSet);
  if (benchSet) benchSet.forEach(n=> all.add(n));
  const schools = {};  // {name: count}
  const bonds   = {};  // {name: count}

  all.forEach(n=>{
    const p = characters.find(x=>x.nome === n); if (!p) return;
    if (p.School) schools[p.School] = (schools[p.School]||0)+1;
    (Array.isArray(p.vinculo)?p.vinculo:[]).forEach(b=>{
      bonds[b] = (bonds[b]||0)+1;
    });
  });
  return {schools, bonds};
}

// Ativadas (o que você já usava) a partir das contagens
function synergyActivatedTotalFromCounts(cnt){
  const actSchools = Object.values(cnt.schools).filter(c=> c>=4).length;
  const actBonds   = Object.entries(cnt.bonds).filter(([b,c])=> c >= bondRequired(b)).length;
  return actSchools + actBonds;
}

// 🔥 Progresso fracionado rumo à ativação (0..nSchools+nBonds)
function synergyProgressFromCounts(cnt){
  let prog = 0;
  // schools (precisam de 4)
  for (const c of Object.values(cnt.schools)) prog += Math.min(c/4, 1);
  // bonds (precisam de 2, exceto alguns = 3)
  for (const [b,c] of Object.entries(cnt.bonds)) {
    const need = bondRequired(b);
    prog += Math.min(c/need, 1);
  }
  return prog;
}
function bondRequired(b){
  const k = String(b||'').trim().toLowerCase();
  return (k === 'Natação' || k === 'Cabeça dos Gêmeos') ? 3 : 2;
}
// ==================== Recommend 2.0 ====================
const RecommendCfg = {
  wSynergy: 3, wAnchor: 1, wStats: 1,
  allowCrossRole: true,
  preferTypes: new Set(),     // 'quick','power','block','receive'

  // 🔥 pesos governados pelo slider wTeamType:
  typePrefWeight: 2.0,        // progresso
  typeActivateBonus: 6.0,     // ativou (4 / 5) -> bônus forte
  typeMajorityBonus: 3.0,     // virou majoritário
  typeNonPreferredPenalty: 2.0, // majoritário ≠ preferido? penaliza

  preselectPerSlot: 10,
  beamWidth: 100
};

// Liga os controles de recomendação (abre/fecha painel e botão Aplicar)
function bindRecommendControls(){
  const panel = document.getElementById('recoPanel');
  const btnToggle = document.getElementById('recommendBtn');
  const btnRun = document.getElementById('runRecommendBtn');
  const btnClose = document.getElementById('closeRecoBtn');

  function initSlidersOnce(){
    if (panel.__inited) return;
    panel.__inited = true;

    // sliders principais
    [
      ['wSynergy','wSynergyVal','wSynergy'],
      ['wAnchor','wAnchorVal','wAnchor'],
      ['wStats','wStatsVal','wStats']
    ].forEach(([inputId, outId, key])=>{
      const el = document.getElementById(inputId);
      const out = document.getElementById(outId);
      if (!el || !out) return;
      el.value = RecommendCfg[key];
      out.textContent = el.value;
      el.addEventListener('input', ()=>{ RecommendCfg[key] = +el.value; out.textContent = el.value; });
    });

    // 🔥 slider de Tipo do time -> typePrefWeight
    const wTT = document.getElementById('wTeamType');
const wTTv = document.getElementById('wTeamTypeVal');
if (wTT && wTTv){
  const applyTypeWeights = v => {
    const x = +v;              // 0..5 (ou o range que você definiu)
    RecommendCfg.typePrefWeight       = x;        // progresso
    RecommendCfg.typeActivateBonus    = 3 * x;    // ativar vale bastante
    RecommendCfg.typeMajorityBonus    = 1.5 * x;  // ser majoritário também ajuda
    RecommendCfg.typeNonPreferredPenalty = 1 * x; // e punimos majoritário “errado”
    wTTv.textContent = v;
  };
  wTT.value = String(RecommendCfg.typePrefWeight);
  applyTypeWeights(wTT.value);
  wTT.addEventListener('input', ()=> applyTypeWeights(wTT.value));
}

    const chkCR = document.getElementById('allowCrossRole');
    if (chkCR){
      chkCR.checked = RecommendCfg.allowCrossRole;
      chkCR.addEventListener('change', ()=> RecommendCfg.allowCrossRole = chkCR.checked);
    }

    // checkboxes de tipo preferido
    [
      ['prefQuick','quick'],
      ['prefPower','power'],
      ['prefBlock','block'],
      ['prefReceive','receive'],
    ].forEach(([id, t])=>{
      const cb = document.getElementById(id);
      if (!cb) return;
      cb.checked = RecommendCfg.preferTypes.has(t);
      cb.addEventListener('change', ()=>{
        if (cb.checked) RecommendCfg.preferTypes.add(t);
        else RecommendCfg.preferTypes.delete(t);
      });
    });
  }

  if (btnToggle && !btnToggle.__bound){
    btnToggle.__bound = true;
    btnToggle.addEventListener('click', ()=>{
      initSlidersOnce();
      panel.classList.toggle('open');
    });
  }
  if (btnRun && !btnRun.__bound){
    btnRun.__bound = true;
    btnRun.addEventListener('click', ()=>{ recommendFillSlots2(); /* panel.classList.remove('open'); */ });
  }
  if (btnClose && !btnClose.__bound){
    btnClose.__bound = true;
    btnClose.addEventListener('click', ()=> panel.classList.remove('open'));
  }
}

// helpers
function symbolToType(sym){
  const s = String(sym||"").toLowerCase();
  if (s.includes("quicksymbol"))   return "quick";
  if (s.includes("powersymbol"))   return "power";
  if (s.includes("servesymbol"))   return "serve";
  if (s.includes("settersymbol"))  return "setter";
  if (s.includes("receivesymbol")) return "receive";
  if (s.includes("blocksymbol"))   return "block";
  if (s.includes("savesymbol"))    return "save";
  return null;
}
const TYPE_MIN = t => (t === 'receive' ? 5 : 4);
const RARITY_TOKENS = new Set(['UR','SSR','SP','SR','R','N','MR']);
function baseName(name){
  const parts = String(name||'').trim().split(/\s+/);
  if (!parts.length) return '';
  const last = parts[parts.length-1].toUpperCase().replace(/[+]/g,'');
  if (RARITY_TOKENS.has(last)) parts.pop();   // remove “UR/SSR/SP/…”
  return parts.join(' ');
}

function typeProgress(counts, preferSet){
  let total = 0;
  preferSet.forEach(t=>{
    const c = counts[t] || 0;
    total += c / TYPE_MIN(t);
  });
  return total;
}
function startersSlots(){ return Array.from(document.querySelectorAll('.hex')); }
function benchSlots(){ return Array.from(document.querySelectorAll('.bench-slot')); }
function slotRole(el){ return (el.dataset.role || el.getAttribute('data-role') || '').toUpperCase(); }
function slotName(el){ return el?.dataset?.nome || null; }
function charByName(n){ return characters.find(c => c.nome === n); }
function sumStats(p){
  const S = p?.Stats || {};
  return (S.Serve|0)+(S.Spike|0)+(S.Set|0)+(S.Receive|0)+(S.Block|0)+(S.Save|0);
}
function allowedRolesForSlot(role, allowCross){
  if (role === 'L') return ['L'];
  return allowCross ? ['S','MB','WS','OP'] /* não-L */ : [role];
}

// contagem de tipos entre titulares (Set de nomes)
function teamTypeCountsFromNames(nameSet){
  const counts = {};
  nameSet.forEach(n=>{
    const p = characters.find(x => x.nome === n); if (!p) return;
    (Array.isArray(p.symbols)?p.symbols:[]).map(symbolToType).filter(Boolean)
      .forEach(t => counts[t] = (counts[t]||0)+1);
  });
  return counts;
}
function maxTypeInfo(counts){
  let best = [], bestN = 0;
  for (const [t,c] of Object.entries(counts)){
    if (c > bestN){ best=[t]; bestN=c; }
    else if (c === bestN) best.push(t);
  }
  return {types:best, count:bestN};
}

// Schools e Bonds ativados, recebendo SET de titulares e SET de banco (opcional)
function schoolsAndBondsActivated(startersSet, benchSet){
  const all = new Set(startersSet);
  if (benchSet) benchSet.forEach(n=> all.add(n));

  const schoolCount = {};
  const bondCount = {};
  all.forEach(n=>{
    const p = characters.find(x => x.nome === n); if (!p) return;
    if (p.School) schoolCount[p.School] = (schoolCount[p.School]||0)+1;
    (Array.isArray(p.vinculo)?p.vinculo:[]).forEach(b=>{
      bondCount[b] = (bondCount[b]||0)+1;
    });
  });

  const schoolsActive = Object.values(schoolCount).filter(c=>c>=4).length;
  const bondsActive = Object.entries(bondCount).filter(([b,c])=> c >= bondRequired(b)).length;
  return {schoolsActive, bondsActive, total: schoolsActive + bondsActive};
}

// âncora: quantas novas sinergias (school/bond) incluem ao menos 1 nome já existente
function anchorGain(beforeSet, afterSet){
  const added = new Set([...afterSet].filter(n=>!beforeSet.has(n)));
  if (!added.size) return 0;

  const bondMembers = {}, schoolMembers = {};
  afterSet.forEach(n=>{
    const p = characters.find(x => x.nome === n); if (!p) return;
    if (p.School) (schoolMembers[p.School]||(schoolMembers[p.School]=new Set())).add(n);
    (Array.isArray(p.vinculo)?p.vinculo:[]).forEach(b=>{
      (bondMembers[b]||(bondMembers[b]=new Set())).add(n);
    });
  });

  let gain = 0;
  for (const [school, members] of Object.entries(schoolMembers)){
    if (members.size>=4){
      const hasOld = [...members].some(n=>beforeSet.has(n));
      const hasNew = [...members].some(n=>added.has(n));
      if (hasOld && hasNew) gain += 1;
    }
  }
  for (const [bond, members] of Object.entries(bondMembers)){
    if (members.size>=bondRequired(bond)){
      const hasOld = [...members].some(n=>beforeSet.has(n));
      const hasNew = [...members].some(n=>added.has(n));
      if (hasOld && hasNew) gain += 1;
    }
  }
  return gain;
}

// construção de candidatos por slot
function candidatePoolForSlot(slot, excludeNames, allowCross){
  const role = slotRole(slot);
  const allowed = new Set(allowedRolesForSlot(role, allowCross));
  return characters.filter(p=>{
    if (excludeNames.has(p.nome)) return false;
    // L só pode ir no L; se allowed == [role] no modo não-cross, já restringe
    if (role === 'L') return p.funcao === 'L';
    if (!allowCross) return p.funcao === role;
    return p.funcao !== 'L'; // cross-role: qualquer não-L em slots não-L
  });
}

// cria produto cartesiano limitado
function* cartesianLimited(arrays, limit){
  const idx = arrays.map(()=>0);
  let produced = 0;
  while (arrays.length && produced < limit){
    // yield combinação atual
    yield arrays.map((a,i)=>a[idx[i]]);
    produced++;
    // incrementa
    let k = arrays.length - 1;
    while (k>=0){
      idx[k]++;
      if (idx[k] < arrays[k].length) break;
      idx[k]=0; k--;
    }
    if (k<0) break;
  }
}

function recommendFillSlots2(){
  const starterEls = Array.from(document.querySelectorAll('.hex'));
  const benchEls   = Array.from(document.querySelectorAll('.bench-slot'));

  // 1) Estado atual
  const beforeStarters = new Set(starterEls.map(s => s.dataset?.nome).filter(Boolean));
  const benchNames     = new Set(benchEls.map(s => s.dataset?.nome).filter(Boolean));
  const emptySlots     = starterEls.filter(s => !s.dataset?.nome);
  if (!emptySlots.length) return;

  // 2) Sinergias "antes"
  const beforeCnt     = synergyCounts(beforeStarters, benchNames);
  const synBeforeAct  = synergyActivatedTotalFromCounts(beforeCnt);
  const synBeforeProg = synergyProgressFromCounts(beforeCnt);

  // 3) Pré-cálculos
  const filledBase       = new Set([...beforeStarters, ...benchNames].map(baseName));
  const beforeTypeCounts = teamTypeCountsFromNames(beforeStarters);
  const baseTypeProg     = typeProgress(beforeTypeCounts, RecommendCfg.preferTypes);
  const synBeforeTotal   = schoolsAndBondsActivated(beforeStarters, benchNames).total;

  // utils
  const slotRole = el => (el.dataset.role || el.getAttribute('data-role') || '').toUpperCase();
  const allowedRolesForSlot = role => role==='L' ? ['L'] : (RecommendCfg.allowCrossRole ? ['S','MB','WS','OP'] : [role]);
  const sumStats = p => { const S=p.Stats||{}; return (S.Serve|0)+(S.Spike|0)+(S.Set|0)+(S.Receive|0)+(S.Block|0)+(S.Save|0); };

  // 4) Pools por slot (pré-seleção por sinergia + tipo + stats)
  const pools = emptySlots.map(slot=>{
    const role = slotRole(slot);

    let list = characters.filter(p=>{
      if (beforeStarters.has(p.nome) || benchNames.has(p.nome)) return false;
      if (filledBase.has(baseName(p.nome))) return false;      // evita duplicar jogador em outra raridade
      if (role==='L') return p.funcao==='L';
      return RecommendCfg.allowCrossRole ? (p.funcao!=='L') : (p.funcao===role);
    });

    list = list.map(p=>{
      // --- Sinergia 1 passo: ativadas + progresso ---
      const afterStarters = new Set(beforeStarters); afterStarters.add(p.nome);
      const cntAfter   = synergyCounts(afterStarters, benchNames);
      const synAct     = synergyActivatedTotalFromCounts(cntAfter);
      const synProg    = synergyProgressFromCounts(cntAfter);
      const synDeltaAct  = synAct  - synBeforeAct;
      const synDeltaProg = synProg - synBeforeProg;
      const synScore     = RecommendCfg.wSynergy * (synDeltaAct + 0.5*synDeltaProg);

      // --- Tipo preferido ---
      const typeCountsAfter = {...beforeTypeCounts};
      (Array.isArray(p.symbols)?p.symbols:[]).map(symbolToType).filter(Boolean)
        .forEach(t=> typeCountsAfter[t]=(typeCountsAfter[t]||0)+1);

      const prefProgressAfter = typeProgress(typeCountsAfter, RecommendCfg.preferTypes);
      const prefDelta         = prefProgressAfter - baseTypeProg;

      const afterMax = maxTypeInfo(typeCountsAfter);
      const activatedPreferred   = afterMax.types.some(t=>RecommendCfg.preferTypes.has(t)) && afterMax.count >= TYPE_MIN(afterMax.types[0]||'');
      const majorityPreferred    = afterMax.types.some(t=>RecommendCfg.preferTypes.has(t));
      const majorityActivated    = afterMax.count >= TYPE_MIN(afterMax.types[0]||'');
      const nonPreferredMajority = majorityActivated && !majorityPreferred;

      const typeScore =
        (RecommendCfg.typePrefWeight * prefDelta) +
        (activatedPreferred   ? RecommendCfg.typeActivateBonus       : 0) +
        (majorityPreferred    ? RecommendCfg.typeMajorityBonus       : 0) +
        (nonPreferredMajority ? -RecommendCfg.typeNonPreferredPenalty: 0);

      return { p,
        heur: synScore + typeScore + (RecommendCfg.wStats * (sumStats(p)/2000))
      };
    })
    .sort((a,b)=> b.heur - a.heur)
    .slice(0, RecommendCfg.preselectPerSlot)
    .map(x=>x.p);

    // fallback por stats
    if (!list.length){
      list = characters
        .filter(p=> !beforeStarters.has(p.nome)
                 && !benchNames.has(p.nome)
                 && !filledBase.has(baseName(p.nome))
                 && (role==='L' ? p.funcao==='L'
                                 : (RecommendCfg.allowCrossRole ? p.funcao!=='L' : p.funcao===role)))
        .sort((a,b)=> sumStats(b)-sumStats(a))
        .slice(0, RecommendCfg.preselectPerSlot);
    }
    return list;
  });

  // 5) BEAM search
  let beam = [{ pick:[], names:new Set(), base:new Set(filledBase), score:0, stats:0 }];
  emptySlots.forEach((slot, stepIdx)=>{
    const next = [];
    for (const state of beam){
      for (const p of pools[stepIdx]){
        if (state.names.has(p.nome)) continue;
        const b = baseName(p.nome);
        if (state.base.has(b)) continue;

        const namesAfter = new Set([...beforeStarters, ...state.names, p.nome]);

        const synAfter = schoolsAndBondsActivated(namesAfter, benchNames).total;
        const synDelta = synAfter - synBeforeTotal;

        const ancGain = anchorGain(beforeStarters, namesAfter);

        const afterTypeCounts   = teamTypeCountsFromNames(namesAfter);
        const prefProgressAfter = typeProgress(afterTypeCounts, RecommendCfg.preferTypes);
        const prefDelta         = prefProgressAfter - baseTypeProg;

        const afterMax = maxTypeInfo(afterTypeCounts);
        const activatedPreferred   = afterMax.types.some(t=>RecommendCfg.preferTypes.has(t)) && afterMax.count >= TYPE_MIN(afterMax.types[0]||'');
        const majorityPreferred    = afterMax.types.some(t=>RecommendCfg.preferTypes.has(t));
        const majorityActivated    = afterMax.count >= TYPE_MIN(afterMax.types[0]||'');
        const nonPreferredMajority = majorityActivated && !majorityPreferred;

        const typeScore =
          (RecommendCfg.typePrefWeight * prefDelta) +
          (activatedPreferred   ? RecommendCfg.typeActivateBonus       : 0) +
          (majorityPreferred    ? RecommendCfg.typeMajorityBonus       : 0) +
          (nonPreferredMajority ? -RecommendCfg.typeNonPreferredPenalty: 0);

        const statsSum   = state.stats + sumStats(p);
        const statsScore = statsSum / ((state.pick.length + 1) * 2000);

        const score = (RecommendCfg.wSynergy*synDelta)
                    + (RecommendCfg.wAnchor*ancGain)
                    + typeScore
                    + (RecommendCfg.wStats*statsScore);

        next.push({
          pick:[...state.pick, {slot, p}],
          names:new Set([...state.names, p.nome]),
          base:new Set([...state.base, b]),
          score, stats: statsSum
        });
      }
    }
    next.sort((a,b)=> b.score - a.score);
    beam = next.slice(0, RecommendCfg.beamWidth);
  });

  if (!beam.length || !beam[0].pick?.length) return;

  // 6) Aplicar nos slots vazios
  beam[0].pick.forEach(({slot, p})=>{
    const keepRole = slotRole(slot)==='L' ? 'L' : (slot.dataset.role || slot.getAttribute('data-role'));
    setCharacter(slot, p, keepRole);
  });

  if (typeof updateSynergies === 'function') updateSynergies();
}



// ======================= Multi Teams =========================

// Coleta estado atual do grid (titulares + banco + itens)
function collectTeamState(name){
  const state = { name: name || `Time ${currentTeamIndex+1}`, starters:{}, bench:{}, equip:{} };

  // titulares
  document.querySelectorAll('.hex').forEach(slot=>{
    const id   = getSlotId(slot);
    const nome = slot.dataset?.nome || null;
    if (nome) state.starters[id] = nome;
    const eq = equipState.get(id);
    if (eq) state.equip[id] = JSON.parse(JSON.stringify(eq));
  });

  // banco
  document.querySelectorAll('.bench-slot').forEach(slot=>{
    const id   = getSlotId(slot);
    const nome = slot.dataset?.nome || null;
    if (nome) state.bench[id] = nome;
    const eq = equipState.get(id);
    if (eq) state.equip[id] = JSON.parse(JSON.stringify(eq));
  });

  return state;
}

// Cria um estado vazio (novo time)
function makeEmptyTeamState(name){
  return { name: name || `Time ${teams.length+1}`, starters:{}, bench:{}, equip:{} };
}

// Limpa completamente o grid atual (remove personagens e itens)
function clearWholeGrid(){
  document.querySelectorAll('.hex,.bench-slot').forEach(slot=>{
    if (slot.dataset?.nome) removeCharacter(slot);
    const id = getSlotId(slot);
    equipState.delete(id);
  });
}

// Aplica um estado ao grid
function applyTeamState(state){
  clearWholeGrid();

  // titulares
  Object.entries(state.starters || {}).forEach(([slotId, nome])=>{
    const slot = document.querySelector(`[data-slot-id="${slotId}"]`) || document.getElementById(slotId);
    if (!slot) return;
    const role = slot.classList.contains('bench-slot') ? 'bench' : (slot.dataset.role || slot.getAttribute('data-role'));
    const p = characters.find(c => c.nome === nome);
    if (p) setCharacter(slot, p, role);
  });

  // banco
  Object.entries(state.bench || {}).forEach(([slotId, nome])=>{
    const slot = document.querySelector(`[data-slot-id="${slotId}"]`) || document.getElementById(slotId);
    if (!slot) return;
    const role = 'bench';
    const p = characters.find(c => c.nome === nome);
    if (p) setCharacter(slot, p, role);
  });

  // itens
  Object.entries(state.equip || {}).forEach(([slotId, obj])=>{
    equipState.set(slotId, JSON.parse(JSON.stringify(obj)));
  });

  // atualiza UI dependente
  if (typeof updateSynergies === 'function') updateSynergies();
  if (typeof refreshAllGears  === 'function') refreshAllGears();
}

// Salva o time atual no array
function saveCurrentTeam(){
  if (!teams.length) return;
  const oldName = teams[currentTeamIndex]?.name || `Time ${currentTeamIndex+1}`;
  teams[currentTeamIndex] = collectTeamState(oldName);
}

// Renderiza as abas
function renderTeamTabs(){
  const tabs = document.getElementById('teamTabs');
  if (!tabs) return;
  tabs.innerHTML = '';

  teams.forEach((t, i)=>{
    const b = document.createElement('button');
    b.className = 'team-tab' + (i===currentTeamIndex ? ' active' : '');
    b.textContent = t.name;
    b.title = `Selecionar ${t.name}`;

    // evita troca enquanto estiver editando
    b.addEventListener('click', ()=>{
      if (b.classList.contains('editing')) return;
      if (i === currentTeamIndex) return;
      saveCurrentTeam();
      currentTeamIndex = i;
      applyTeamState(teams[i]);
      renderTeamTabs();
    });

    // === Renomear no dblclick ===
    b.addEventListener('dblclick', (e)=>{
      e.preventDefault();
      e.stopPropagation();
      if (b.classList.contains('editing')) return;

      b.classList.add('editing');
      const oldName = teams[i].name;
      b.textContent = ''; // limpar para inserir input

      const input = document.createElement('input');
      input.className = 'team-tab-edit';
      input.type = 'text';
      input.value = oldName;
      input.setAttribute('maxlength', 40);
      b.appendChild(input);
      input.focus();
      input.select();

      const commit = ()=>{
        const val = (input.value || '').trim();
        teams[i].name = val || oldName; // se vazio, mantém
        b.classList.remove('editing');
        renderTeamTabs();
      };
      const cancel = ()=>{
        b.classList.remove('editing');
        renderTeamTabs();
      };

      input.addEventListener('keydown', (ev)=>{
        if (ev.key === 'Enter') commit();
        else if (ev.key === 'Escape') cancel();
      });
      input.addEventListener('blur', commit);
    });

    tabs.appendChild(b);
  });
}

// Inicializa a barra de times
function initMultiTeams(){
  const addBtn = document.getElementById('addTeamBtn');

  if (teams.length === 0){
    teams.push(collectTeamState('Team 1'));
    currentTeamIndex = 0;
  }
  renderTeamTabs();

  // evita ligar o clique mais de uma vez
  if (addBtn && !addBtn.__mtBound){
    addBtn.__mtBound = true;
    addBtn.addEventListener('click', ()=>{
      if (__mtAdding) return;          // trava se já estiver rodando
      __mtAdding = true;
      try {
        saveCurrentTeam();
        const newIdx = teams.length + 1;
        const empty = makeEmptyTeamState(`Team ${newIdx}`);
        teams.push(empty);
        currentTeamIndex = teams.length - 1;
        applyTeamState(empty);
        renderTeamTabs();
      } finally {
        // solta o lock no próximo ciclo do event loop
        setTimeout(()=>{ __mtAdding = false; }, 0);
      }
    });
  }

  // opcional: salvar automaticamente após qualquer mudança
  // se você já usa hooks globais, podemos plugar aqui:
  const oldAfterAssign = window.afterAssignCharacter;
  window.afterAssignCharacter = function(el, nome){
    if (typeof oldAfterAssign === 'function') oldAfterAssign(el, nome);
    saveCurrentTeam();
  };
  const oldAfterRemove = window.afterRemoveCharacter;
  window.afterRemoveCharacter = function(el){
    if (typeof oldAfterRemove === 'function') oldAfterRemove(el);
    saveCurrentTeam();
  };
}

</script>


<!-- ===================== PLANEJADOR DE RECURSOS (PÁGINA NOVA) ===================== -->
<style>
  /* Páginas alternáveis */
  .page { display: none; }
  .page.active { display: block; }
  /* Quando a classe show-planner está no <body>, mostramos o planner em overlay e ocultamos overflow */
  body.show-planner { overflow: hidden; }
  body.show-planner .hide-when-planner { display: none !important; }
  body.show-planner #pagePlanner { display: block; position: fixed; inset: 0; z-index: 9999; background:#111; overflow:auto; }

  /* Barra do botão Planejador acima de Save & Load */
  #plannerTopBar {
    display:flex; gap:10px; align-items:center; justify-content:center;
    margin: 14px 0 0;
  }
  #openPlannerBtn {
    background:#ffd54f; color:#222; border:0; font-weight:800;
    padding:10px 14px; border-radius:10px; cursor:pointer;
    box-shadow:0 3px 0 rgba(0,0,0,.25);
  }
  #openPlannerBtn:hover{ transform: translateY(-1px); }

  /* Layout do Planejador */
  #pagePlanner { padding: 18px; }
  .planner-wrap{
    max-width: 1180px; margin: 0 auto;
    display:grid; grid-template-columns: 1.1fr .9fr;
    gap: 20px;
    background:#2a2a2a; border:1px solid #3a3a3a; border-radius:14px; padding:16px;
  }
  @media (max-width: 980px){
    .planner-wrap{ grid-template-columns: 1fr; }
  }

  .panel {
    background:#242424; border:1px solid #3a3a3a; border-radius:12px; padding:12px;
  }
  .panel h3{ margin: 0 0 10px; }
  .panel .sub{ opacity:.8; font-size:.9rem; margin-top:-6px; }

  /* tabelas editáveis */
  .grid-table{ width:100%; border-collapse: collapse; }
  .grid-table th, .grid-table td{
    border-bottom: 1px solid #3a3a3a; padding:6px 8px; text-align:left;
  }
  .grid-table th{ background:#1f1f1f; position:sticky; top:0; z-index:1; }
  .grid-table input[type="number"], .grid-table input[type="text"], .grid-table select{
    width:100%; background:#1d1d1d; color:#fff; border:1px solid #555; border-radius:8px;
    padding:6px 8px; box-sizing:border-box;
  }
  .grid-table input[type="checkbox"]{ transform: scale(1.2); }

  .row-actions{ display:flex; gap:6px; }
  .btn { background:#333; color:#fff; border:1px solid #666; border-radius:8px; padding:8px 10px; cursor:pointer; }
  .btn.del{ background:#a33; border-color:#d66; }
  .btn.add{ background:#2f6; color:#000; font-weight:800; }
  .btn.primary{ background:#40f06a; color:#000; font-weight:800; }
  .btn.light{ background:#111; border-color:#444; }

  .flex { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  .right { text-align:right; }

  /* Resumo */
  .summary{ display:grid; grid-template-columns: repeat(4,1fr); gap:10px; margin-top:10px; }
  .metric{
    background:#1e1e1e; border:1px solid #3a3a3a; border-radius:10px; padding:10px;
    text-align:center;
  }
  .metric b{ display:block; font-size:1.1rem; }

  /* Tabela de Simulação por Banner */
  #simTable{ width:100%; border-collapse: collapse; margin-top:10px; }
  #simTable th, #simTable td{ border-bottom:1px solid #3a3a3a; padding:8px; text-align:right; }
  #simTable th{ text-align:center; background:#1f1f1f; }
  #simTable td:first-child, #simTable th:first-child{ text-align:left; }
  /* === Planner em tela cheia === */
#pagePlanner{
  position: fixed;      /* vira um overlay */
  inset: 0;             /* top/right/bottom/left = 0 */
  width: 100vw;
  height: 100vh;
  margin: 0;
  padding: 16px clamp(12px,2vw,24px) 24px;
  background: #121212;  /* use a cor do seu tema, se tiver variável */
  z-index: 999;         /* acima do restante da UI */
  overflow: auto;       /* rolagem interna */
}

/* evita “caixa” estreita por max-width herdado */
#pagePlanner .container,
#pagePlanner .planner-box,
#pagePlanner .planner-wrap,
#pagePlanner .planner-grid{
  max-width: none !important;
  width: 100% !important;
}

/* mantém cabeçalho/toolbar visível enquanto rola o planner */
#pagePlanner .planner-header{
  position: sticky;
  top: 0;
  z-index: 1;
  background: inherit;
  padding-bottom: 8px;
}

/* quando o planner está aberto, trava o scroll do body atrás */
body.planner-open{ overflow: hidden; }
#simInputs small.muted{opacity:.9}
#simTable tfoot{ display:none; }
#simTable .neg{ color:#ff5c5c; font-weight:700; }
/* Caixa numérica padrão do planner (usar em Saldo Inicial, Tickets e Memórias) */
.planner-input{
  width: 140px;      /* ajuste conforme seu layout */
  padding: 6px 10px;
  background:#111;
  color:#fff;
  border:1px solid #444;
  border-radius:8px;
  outline:none;
}
.planner-input:focus{ border-color:#777; }
.sim-extras{
  border-top:1px solid #333;
  padding-top:8px;
  font-weight:600;
  display:flex;
  flex-wrap:wrap;
  gap:10px 16px;
}
.sim-extras .pill{
  background:#1d1d1d;
  border:1px solid #444;
  border-radius:999px;
  padding:4px 10px;
}
/* ===== Planner: 2 colunas mais equilibradas ===== */


/* Simulação (direita) garante que não estoure a largura */
#pagePlanner .planner-sim{
  width: 100%;
  box-sizing: border-box;
}

/* Evita qualquer overflow horizontal do planner */
#pagePlanner{ overflow-x: hidden; }

/* ===== Cartões de banner mais enxutos ===== */
/* use uma “variável” pra controlar o tamanho dos cards */
:root{ --card-w: 200px; }          /* antes: 320px */
.banner-card,
.rebanner-card{
  width: var(--card-w);
  flex: 0 0 var(--card-w);         /* não estica */
  margin: 0 auto;
}
.month-row > div{ min-width: 0; }  /* impede que colunas internas forcem largura */

/* Em telas um pouco menores, encolhe mais um pouco os cards */
@media (max-width: 1700px){
  :root{ --card-w: 280px; }
}

/* === 50% | 50%: Banners (esq) e Simulação (dir) === */
#pagePlanner .planner-right-grid,
#pagePlanner .planner-two-col{
  display: grid;
  grid-template-columns: 1fr 1fr;   /* META: meio a meio */
  gap: 12px;
  align-items: start;
}

/* Simulação fixa visível e scrollável dentro da metade direita (opcional) */
#simPane{
  position: sticky;
  top: 12px;
  max-height: calc(100vh - 120px);
  overflow: auto;
}

/* Em telas menores, caia para 1 coluna para não esmagar conteúdo */
@media (max-width: 1200px){
  #pagePlanner .planner-right-grid,
  #pagePlanner .planner-two-col{
    grid-template-columns: 1fr;
  }
}
/* Gutter (recuo) à direita da aba Simulação */
:root{
  --sim-gutter: clamp(8px, 1vw, 16px); /* ajuste aqui se quiser mais/menos */
}

#simPane{
  padding-right: calc(var(--sim-gutter) + env(safe-area-inset-right, 0px));
  box-sizing: border-box;   /* evita “estourar” a metade direita */
  /* já deve existir overflow:auto; mantenha */
}
/* ---------- Desktop (já existente): duas colunas ---------- */
/* (mantenha como estiver hoje; não precisa mexer) */


/* ---------- Mobile: <= 980px ---------- */
@media (max-width: 980px){

  /* A grade vira 1 coluna, e controlamos a ordem com áreas */
  #pagePlanner .planner-right-grid{
    display: grid;
    grid-template-columns: 1fr;
    grid-template-areas:
      "sim"
      "banners";
    row-gap: 14px;
  }

  /* Nomear as áreas */
  #bannersPane{ grid-area: banners; }
  #simPane{ grid-area: sim; }

  /* A Simulação NÃO deve ser sticky no mobile: mostra tudo */
  #simPane{
    position: static;
    max-height: none;
    overflow: visible;
    padding-right: var(--sim-gutter, 12px); /* mantém o leve recuo que fizemos */
    box-sizing: border-box;
  }

  /* Cards de banner ocupam 100% da linha para caber bem */
  .month-row{
    grid-template-columns: 1fr;   /* 1 por linha */
    gap: 12px;
  }
  .banner-card,
  .rebanner-card{
    width: 100%;
    max-width: 100%;
  }

  /* Inputs da Simulação não estourarem largura */
  #simPane #simInputs label{ display:flex; align-items:center; gap:10px; }
  #simPane #simInputs input{ max-width: 240px; }
}


</style>

<!-- ===================== PLANEJADOR DE RECURSOS (NOVA PÁGINA) ===================== -->
<section id="pagePlanner" class="page"
  style="display:none; text-align:left; position:fixed; inset:0; width:100vw; height:100vh; margin:0; padding:16px 20px; background:#121212; overflow:auto; z-index:999;">

  <!-- Cabeçalho -->
  <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
    <h3 style="margin:0;">Planejamento de Banners</h3>
    <button id="btnVoltarBuilder" class="btn" type="button"
      style="background:#444;border:1px solid #777;color:#fff;border-radius:8px;padding:6px 10px;cursor:pointer">
      ← Voltar ao Builder
    </button>
  </div>

  <!-- Duas colunas principais: Fontes (esq) | Painel de Banners+Simulação (dir) -->
  <div class="planner-wrap" style="display:grid; grid-template-columns: 420px 1fr; gap:16px; align-items:start;">

    <!-- Coluna ESQUERDA: Fontes de diamantes -->
    <div class="panel sources" style="background:#2a2a2a;border:1px solid #444;border-radius:10px;padding:10px;">
      <h3 style="display:flex;align-items:center;justify-content:space-between;margin:0 0 8px;">
        Fontes de Diamantes (editáveis)
        <button id="toggleSources" class="btn mini" type="button"
          style="background:#555;border:1px solid #777;color:#fff;border-radius:8px;padding:4px 8px;cursor:pointer">
          Minimizar
        </button>
      </h3>

      <!-- FREE -->
      <div style="font-weight:700;opacity:.9;margin-top:6px;">Fontes FREE</div>
      <table id="tblFree" class="grid-table" style="width:100%;border-collapse:separate;border-spacing:6px 6px;">
        <thead>
          <tr><th>Usar</th><th class="col-sistema">Sistema</th><th>Quantidade</th><th>Frequência</th><th></th></tr>
        </thead>
        <tbody></tbody>
      </table>
      <button id="addFree" class="btn" type="button"
        style="background:#3a6bd4;color:#fff;border:0;border-radius:8px;padding:6px 10px;cursor:pointer">+ Fonte FREE</button>

      <!-- CASH -->
      <div style="font-weight:700;opacity:.9;margin-top:14px;">Fontes CASH</div>
      <table id="tblCash" class="grid-table" style="width:100%;border-collapse:separate;border-spacing:6px 6px;">
        <thead>
          <tr><th>Usar</th><th class="col-sistema">Sistema</th><th>Quantidade</th><th>Frequência</th><th></th></tr>
        </thead>
        <tbody></tbody>
      </table>
      <button id="addCash" class="btn" type="button"
        style="background:#3a6bd4;color:#fff;border:0;border-radius:8px;padding:6px 10px;cursor:pointer">+ Fonte CASH</button>

      <!-- (qualquer outro bloco/observação que você já tinha pode ficar aqui) -->
    </div>

    <!-- Coluna DIREITA: Controles + Banners (esq) | Simulação (dir) -->
    <div class="panel" style="background:#2a2a2a;border:1px solid #444;border-radius:10px;padding:10px;">

      <!-- Controles do plano -->

        <label>Nome do Planejamento:
          <input id="nomePlano" type="text"
            style="background:#1d1d1d;color:#fff;border:1px solid #555;border-radius:8px;padding:4px 6px;min-width:220px;">
        </label>

        <select id="slotsPlanos"
          style="background:#1d1d1d;color:#fff;border:1px solid #555;border-radius:8px;padding:6px;">
          <option value="">(selecione um plano salvo)</option>
        </select>

        <button id="btnSalvarPlano" class="btn"
          style="background:#3a6bd4;color:#fff;border:0;border-radius:8px;padding:6px 10px;">Salvar / Atualizar</button>
        <button id="btnNovoPlano" class="btn"
          style="background:#555;color:#fff;border:0;border-radius:8px;padding:6px 10px;">Novo</button>
        <button id="btnExcluirPlano" class="btn"
          style="background:#b63a3a;color:#fff;border:0;border-radius:8px;padding:6px 10px;">Excluir</button>
      </div>

      <!-- Grid interno: Banners (esquerda) + Simulação (direita/sticky) -->
      <div class="planner-right-grid">

        <!-- BANNERS POR MÊS (ESQUERDA) -->
        <section id="bannersPane">
          <h4 style="margin:12px 0 6px;text-align:center;">Ordem dos Banners</h4>
<!-- NOVO: alternador de servidor -->
<div id="serverSwitch" class="server-switch">
  <button id="serverJPBtn" class="server-btn active" type="button">Japão</button>
  <button id="serverCNBtn" class="server-btn" type="button">China</button>
</div>

<!-- já existente -->
<div id="bannersCards"></div>
        </section>

        <!-- SIMULAÇÃO (DIREITA, STICKY) -->
        <aside id="simPane" style="position:sticky; top:12px; max-height:calc(100vh - 120px); overflow:auto;">
          <h4 style="margin:12px 0 6px;text-align:center;">Simulação</h4>
          <!-- Inputs iniciais (agora dentro da Simulação) -->
<div id="simInputs" style="display:flex; flex-direction:column; gap:8px; margin-bottom:10px;">

  <label style="display:flex; gap:8px; align-items:center;">
    <label>Saldo Inicial (cristais):
  <input id="saldoInicial" type="number" class="planner-input" inputmode="numeric">
</label>

  <label style="display:flex; gap:8px; align-items:center;">
  <label>Data de início:
  <input id="planStartDate" type="date" class="planner-input">
  <button id="startTodayBtn" class="btn mini" type="button">Hoje</button>
</label>

  <div style="display:flex; gap:8px;">
    <button id="openSourcesBtn" class="bond-btn" type="button">+ Recursos de cristais</button>
  </div>
  
</div>
          <table id="simTable" style="width:100%;border-collapse:separate;border-spacing:6px 6px;">
            <thead>
              <tr>
                <th>Mês</th>
                
                <th>Ganhos (FREE+CASH)</th>
                <th>Gasto Bruto</th>
                <th>Cashback</th>
                <th>Custo Líquido</th>
                <th>Saldo Início</th>
                <th>Saldo Final</th>
              </tr>
            </thead>
            <tbody></tbody>
            <tfoot>
              <tr style="font-weight:800;">
                <td>Total</td>
                <td></td>
                <td class="right" id="tGanhos">0</td>
                <td class="right" id="tGastoBruto">0</td>
                <td class="right" id="tCashback">0</td>
                <td class="right" id="tLiquido">0</td>
                <td></td>
                <td class="right" id="tSaldoFinal">0</td>
              </tr>
            </tfoot>
          </table>
          <div id="simExtras" class="sim-extras"></div>
        </aside>

      </div><!-- /planner-right-grid -->
    </div><!-- /panel direita -->
  </div><!-- /planner-wrap -->


  <!-- Modal de Recursos (FREE/CASH) -->
<div id="sourcesModal" class="modal-overlay" aria-hidden="true">
  <div class="modal-backdrop" data-close="1"></div>
  <div class="modal-dialog" role="dialog" aria-modal="true" aria-labelledby="sourcesTitle">
    <div class="modal-header">
      <h3 id="sourcesTitle">Recursos de cristais</h3>
      <button id="closeSourcesBtn" class="bond-btn">Fechar</button>
    </div>
    <div id="sourcesModalBody" class="modal-body">
      <!-- o painel .panel.sources será movido pra cá ao abrir -->
    </div>
  </div>
</div>

</section>

<!-- =================== FIM DO PLANEJADOR =================== -->


<script>
  
(function(){
  // ===== Configurações =====
  const MONTHS = ['Janeiro','Fevereiro','Março','Abril','Maio','Junho','Julho','Agosto','Setembro','Outubro','Novembro','Dezembro'];
  const FREQS  = ['Diário','Semanal','Quinzenal','Mensal'];
  const TYPE_ORDER = { 'Banner 1': 0, 'Rebanner': 1, 'Banner 2': 2 };
  const COLLAPSE_KEY = 'hqPlannerSourcesCollapsed';
  const PLANS_KEY = 'hqPlannerPlansV1';
  const DRAFT_KEY = 'hqPlannerDraftV1';

  // ===== Defaults de fontes =====
  const DEFAULT_FREE = [
    {usar:true, nome:'Programa de Treinamento', qtd:75,  freq:'Diário'},
    {usar:true, nome:'Missão Diária',            qtd:60,  freq:'Diário'},
    {usar:true, nome:'Missão Semanal',           qtd:100, freq:'Semanal'},
    {usar:true, nome:'Desafio Máximo',           qtd:15,  freq:'Diário'},
    {usar:true, nome:'Desafio Máximo Ranking',   qtd:20,  freq:'Diário'},
    {usar:true, nome:'Jogos Casuais',            qtd:150, freq:'Semanal'},
    {usar:true, nome:'Quiz',                     qtd:10,  freq:'Diário'},
    {usar:true, nome:'Exercícios',               qtd:10,  freq:'Diário'},
    {usar:true, nome:'Bonus Fim de Semana',      qtd:120, freq:'Semanal'},
    {usar:true, nome:'Sequência de Partidas',    qtd:640, freq:'Quinzenal'},
    {usar:true, nome:'Teste de Especialidade',   qtd:320, freq:'Semanal'},
    {usar:true, nome:'Lojinha banner 1 e 2',   qtd:2500, freq:'Mensal'},
    {usar:true, nome:'Checkin banner 1 e 2',   qtd:1500, freq:'Mensal'},
  ];

  const DEFAULT_CASH = [
    {usar:true, nome:'Passe Mensal',           porDia:90,  dias:30},
    {usar:true, nome:'Passe Mensal Premium',   porDia:100, dias:30},
    {usar:true, nome:'Conversão Diária 80',    porDia:80,  dias:30},
    {usar:true, nome:'Conversão Diária 60',    porDia:60,  dias:14},
  ];

  // ===== Cronograma da planilha (por mês) =====
  const BANNER_SHEET = {
    'Agosto':   { b1:'Ushijima UR',      rebs:[],                           b2:'Kuroo UR' },
    'Setembro': { b1:'Oikawa UR',        rebs:[],                           b2:'Bokuto UR' },
    'Outubro':  { b1:'Miya Atsumu UR',   rebs:[],                           b2:'Miya Osamu UR' },
    'Novembro': { b1:'Hoshiumi UR',         rebs:['Oikawa UR'],                b2:'Hirugami UR' },
    'Dezembro': { b1:'Kageyama UR',      rebs:['Bokuto UR','Hoshiumi UR'],     b2:'Hinata SP' },
    'Janeiro':  { b1:'Kenma SP',         rebs:['Hirugami UR'],              b2:'Nishinoya SP' },
    'Fevereiro':{ b1:'Sugawara SP',      rebs:['Kuro UR'],                 b2:'Bokuto SP' },
    'Março':    { b1:'Akaashi SP',       rebs:['Kageyama UR'],   b2:'Aone SP' },
    'Abril':    { b1:'Sakusa UR',    rebs:['Osamu UR'],                 b2:'Komori UR' },
    'Maio':     { b1:'Tsuki SP',         rebs:[],                           b2:'Kuro SP' },
    'Junho':    { b1:'Kunimi SP',        rebs:[],                           b2:'Koganegawa SP' },
  };

  // ===== Estado =====
  let planner = {
    saldoInicial: 0,
    nomePlano: '',
    free: JSON.parse(JSON.stringify(DEFAULT_FREE)),
    cash: JSON.parse(JSON.stringify(DEFAULT_CASH)),
    banners: []
  };

  // ===== Helpers =====
  const $ = (s, el=document)=>el.querySelector(s);
  const $$ = (s, el=document)=>Array.from(el.querySelectorAll(s));
  const fmt = n => (Math.round((+n||0))).toLocaleString('pt-BR');

  // liga a data de início ao render dos banners e à simulação
(function bindPlanStartDate(){
  const dateEl = document.getElementById('planStartDate');
  const btnToday = document.getElementById('startTodayBtn');
  if(!dateEl) return;

  // quando mudar a data, re-renderiza e recalcula
  const onChange = ()=>{
    if (typeof renderBanners === 'function') renderBanners();
    if (typeof recalc === 'function') recalc();
  };
  dateEl.addEventListener('change', onChange);

  // botão "Hoje"
  if(btnToday){
    btnToday.addEventListener('click', ()=>{
      const now = new Date();
      dateEl.value = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')}`;
      onChange();
    });
  }

  // define um valor padrão (hoje) se estiver vazio ao abrir
  if(!dateEl.value){
    const now = new Date();
    dateEl.value = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')}`;
  }
})();


  function setCollapsed(on){
    document.body.classList.toggle('planner-collapsed', !!on);
    const btn = document.getElementById('toggleSources');
    if(btn) btn.textContent = on ? 'Maximizar' : 'Minimizar';
    try{ localStorage.setItem(COLLAPSE_KEY, on?'1':'0'); }catch(e){}
  }

  function sortBannersFixed(){
  const monthsSeq = Object.keys(BANNER_SHEET);
  planner.banners.sort((a,b)=>{
    const am = monthsSeq.indexOf(a.mes);
    const bm = monthsSeq.indexOf(b.mes);
    if (am !== bm) return am - bm;                    // ordem da planilha
    return (TYPE_ORDER[a.tipo] ?? 99) - (TYPE_ORDER[b.tipo] ?? 99); // dentro do mês
  });
}


  // Geração de caminho de imagem a partir do nome
  function nameToImgCandidates(nome){
    if(!nome) return [];
    const rar = (nome.match(/\b(UR|SP)\b/i)||[])[1];
    if(!rar) return [];
    const rarity = rar.toUpperCase();
    const base = nome.replace(/\b(UR|SP)\b/i,'').trim()
      .normalize('NFD').replace(/[\u0300-\u036f]/g,'');
    const parts = base.split(/\s+/).filter(Boolean);
    if(!parts.length) return [];
    const lower = s => s.toLowerCase();
    const camel = parts.map((p,i)=> i===0 ? p.toLowerCase() : (p[0]||'').toUpperCase()+p.slice(1).toLowerCase()).join('');
    const last = lower(parts[parts.length-1]);
    const fullCamel = camel;
    return [
      `img/${last}${rarity}.png`,
      `img/${fullCamel}${rarity}.png`,
      `img/${last}${rarity}.webp`,
      `img/${fullCamel}${rarity}.webp`
    ];
  }
  function getBannerImage(b){
    if(b.img && b.img.trim()) return b.img;
    const list = nameToImgCandidates(b.nome);
    return list[0] || '';
  }

  // Cashback milestones
  function cashbackMilestones(totalPulls){
    let back150 = 0, back100 = 0;
    const extras = { ssrBox:0, milk:0, copy:0 };
    if(totalPulls >= 10)  back150 += 2;
    if(totalPulls >= 20)  back100 += 5;
    if(totalPulls >= 50)  back150 += 5;
    if(totalPulls >= 80)  back100 += 5;
    if(totalPulls >= 120) extras.ssrBox += 1;
    if(totalPulls >= 160) extras.milk   += 5;
    if(totalPulls >= 200) extras.copy   += 1;
    if(totalPulls >= 220) extras.milk   += 5;
    if(totalPulls >= 350) extras.milk   += 10;
    const cashbackDiamonds = back150*150 + back100*100;
    return { back150, back100, cashbackDiamonds, extras };
  }

  // Seed banners from sheet
  function uid(){ return 'b' + Math.random().toString(36).slice(2,9); }
  function seedBannersFromSheet(){
  planner.banners = [];
  // Ordem = a ordem de inserção em BANNER_SHEET
  for (const mes of Object.keys(BANNER_SHEET)) {
    const row = BANNER_SHEET[mes]; if(!row) continue;

    if (row.b1){
      const img = getBannerImage({nome: row.b1});
      planner.banners.push({ id: uid(), mes, tipo:'Banner 1', nome: row.b1, img, dias:14, t150:0, m100:0, cashback:0 });
    }
    if (Array.isArray(row.rebs)){
      row.rebs.forEach(nome=>{
        const img = getBannerImage({nome});
        planner.banners.push({ id: uid(), mes, tipo:'Rebanner', nome, img, dias:14, t150:0, m100:0, cashback:0 });
      });
    }
    if (row.b2){
      const img = getBannerImage({nome: row.b2});
      planner.banners.push({ id: uid(), mes, tipo:'Banner 2', nome: row.b2, img, dias:14, t150:0, m100:0, cashback:0 });
    }
  }
}


  // ===== Renderers =====
  function renderFree(){
    const tb = $('#tblFree tbody'); if(!tb) return;
    tb.innerHTML = '';
    planner.free.forEach((row, idx)=>{
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td><input type="checkbox" data-k="usar" ${row.usar?'checked':''}></td>
        <td class="col-sistema"><input type="text" data-k="nome" value="${row.nome}" title="${row.nome}"></td>
        <td><input type="number" data-k="qtd" min="0" step="1" value="${row.qtd}"></td>
        <td><select data-k="freq">${FREQS.map(f=>`<option ${f===row.freq?'selected':''}>${f}</option>`).join('')}</select></td>
        <td class="row-actions">
          <button class="btn light up">↑</button>
          <button class="btn light down">↓</button>
          <button class="btn del rm">🗑</button>
        </td>
      `;
      const onEdit = (e)=>{
        const k = e.target.getAttribute('data-k'); if(!k) return;
        if(k==='usar'){ planner.free[idx][k] = e.target.checked; }
        else if(k==='nome' || k==='freq'){ planner.free[idx][k] = e.target.value; if(k==='nome') e.target.title = e.target.value; }
        else { planner.free[idx][k] = +e.target.value || 0; }
        recalc();
      };
      tr.addEventListener('input', onEdit); tr.addEventListener('change', onEdit);
      tr.querySelector('.rm').onclick   = ()=>{ planner.free.splice(idx,1); renderFree(); recalc(); };
      tr.querySelector('.up').onclick   = ()=>{ if(idx>0){ const t=planner.free[idx-1]; planner.free[idx-1]=planner.free[idx]; planner.free[idx]=t; renderFree(); recalc(); } };
      tr.querySelector('.down').onclick = ()=>{ if(idx<planner.free.length-1){ const t=planner.free[idx+1]; planner.free[idx+1]=planner.free[idx]; planner.free[idx]=t; renderFree(); recalc(); } };
      tb.appendChild(tr);
    });
  }

  function renderCash(){
    const tb = $('#tblCash tbody'); if(!tb) return;
    tb.innerHTML = '';
    planner.cash.forEach((row, idx)=>{
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td><input type="checkbox" data-k="usar" ${row.usar?'checked':''}></td>
        <td class="col-sistema"><input type="text" data-k="nome" value="${row.nome}" title="${row.nome}"></td>
        <td><input type="number" data-k="porDia" min="0" step="1" value="${row.porDia}"></td>
        <td><input type="number" data-k="dias" min="0" step="1" value="${row.dias}"></td>
        <td class="row-actions">
          <button class="btn light up">↑</button>
          <button class="btn light down">↓</button>
          <button class="btn del rm">🗑</button>
        </td>
      `;
      const onEdit = (e)=>{
        const k = e.target.getAttribute('data-k'); if(!k) return;
        if(k==='usar'){ planner.cash[idx][k] = e.target.checked; }
        else if(k==='nome'){ planner.cash[idx][k] = e.target.value; e.target.title = e.target.value; }
        else { planner.cash[idx][k] = +e.target.value || 0; }
        recalc();
      };
      tr.addEventListener('input', onEdit); tr.addEventListener('change', onEdit);
      tr.querySelector('.rm').onclick   = ()=>{ planner.cash.splice(idx,1); renderCash(); recalc(); };
      tr.querySelector('.up').onclick   = ()=>{ if(idx>0){ const t=planner.cash[idx-1]; planner.cash[idx-1]=planner.cash[idx]; planner.cash[idx]=t; renderCash(); recalc(); } };
      tr.querySelector('.down').onclick = ()=>{ if(idx<planner.cash.length-1){ const t=planner.cash[idx+1]; planner.cash[idx+1]=planner.cash[idx]; planner.cash[idx]=t; renderCash(); recalc(); } };
      tb.appendChild(tr);
    });
  }
  
  function renderBanners(){
  // === helpers para normalizar mês (sem acento / minúsculo) e obter índice 1..12 ===
  const rmAccents = (s)=> String(s||'').normalize('NFD').replace(/[\u0300-\u036f]/g,'');
  const norm = (s)=> rmAccents(s).trim().toLowerCase();
  const MONTH_IDX = {
    "janeiro":1, "fevereiro":2, "marco":3, "março":3, "abril":4, "maio":5, "junho":6,
    "julho":7, "agosto":8, "setembro":9, "outubro":10, "novembro":11, "dezembro":12
  };
  // ————— util para data de início e rotação de meses —————
function getPlanStartMonth(){
  const el = document.getElementById('planStartDate');
  if(!el || !el.value) return 8; // padrão Agosto (ou ajuste)
  const dt = new Date(el.value + 'T00:00:00');
  const m = dt.getMonth()+1;
  return (m>=1 && m<=12) ? m : 8;
}
  // 1) setup padrão (mantido)
  
  const wrap = document.getElementById('bannersCards'); if(!wrap) return;
  wrap.innerHTML='';

  // 2) agrupar banners por mês (mantido)
  const byMonth={};
  (planner.banners||[]).forEach(b=>{
    if(!b||!b.mes) return;
    (byMonth[b.mes] ||= []).push(b);
  });

  // 3) determinar mês de início a partir de #planStartDate (fallback = mês atual)
  let startMonth = (new Date()).getMonth() + 1; // 1..12
  const startEl = document.getElementById('planStartDate');
  if (startEl && startEl.value){
    const d = new Date(startEl.value + 'T00:00:00');
    if (!Number.isNaN(d.getTime())) startMonth = d.getMonth() + 1;
  }
  // Use a ordem cronológica definida na planilha (BANNER_SHEET) como linha do tempo
const monthsSeq = Object.keys(BANNER_SHEET);

// Índice de início = primeiro mês cujo número (1..12) >= startMonth
let startIdx = monthsSeq.findIndex(m => PT_MONTH_INDEX[norm(m)] >= startMonth);
if (startIdx < 0) startIdx = 0;

// Da data inicial em diante (inclui Janeiro..Junho do “próximo ano”)
// e ainda filtra para manter só meses que realmente têm banners no dataset atual
const monthsToRender = monthsSeq.slice(startIdx).filter(m => byMonth[m]);

// ====== A partir daqui renderiza
monthsToRender.forEach(mes=>{
    const arr = byMonth[mes];
    const b1   = arr.find(x=>x.tipo==='Banner 1');
    const b2   = arr.find(x=>x.tipo==='Banner 2');
    const rebs = arr.filter(x=>x.tipo==='Rebanner'); // 0..2

    const group = document.createElement('div');
    group.className='month-group';
    group.innerHTML=`<div class="month-title">${mes}</div>`;

    const row = document.createElement('div');
    row.className='month-row';

    const mkLinesHTML = (b)=>{
      const t150 = +b.t150 || 0;
      const m100 = +b.m100 || 0;

      // cashback de marcos e %: **apenas para tickets**
      const gastoTickets   = 150 * t150;
      const cbMilTickets   = cashbackMilestones(t150); // só tickets contam
      const cashbackPerc   = Math.round(gastoTickets * ((+b.cashback || 0)/100));
      const cashbackTotal  = (cbMilTickets.cashbackDiamonds || 0) + cashbackPerc;

      return `<div class="banner-lines">
        <span>Tickets: ${t150.toLocaleString('pt-BR')}</span>
        <span>Memórias: ${m100.toLocaleString('pt-BR')}</span>
        <span>Cashback: ${cashbackTotal.toLocaleString('pt-BR')}</span>
      </div>`;
    };

    const mkCard=(b,label)=>{
      const el=document.createElement('div'); el.className='banner-card';
      const imgSrc=getBannerImage(b);
      el.innerHTML=`
        <h5>${label} • ${b.nome||''}</h5>
        ${imgSrc?`<img src="${imgSrc}" onerror="this.style.display='none'>`:
          `<div style="height:210px;border:1px dashed #444;border-radius:10px;display:flex;align-items:center;justify-content:center;opacity:.7">Sem imagem</div>`}
        <div class="banner-fields">
          <label>Tickets (150): <input type="number" class="planner-input" data-id="${b.id}" data-k="t150" min="0" step="1" value="${b.t150||0}"></label>
          <label>Memórias (100): <input type="number" class="planner-input" data-id="${b.id}" data-k="m100" min="0" step="1" value="${b.m100||0}"></label>
        </div>
        ${mkLinesHTML(b)}
      `;
      el.querySelectorAll('input[data-id]').forEach(inp=>{
        inp.addEventListener('input', e=>{
          const it=planner.banners.find(x=>x.id===e.target.getAttribute('data-id'));
          if(!it) return; it[e.target.getAttribute('data-k')]=+e.target.value||0;
          const old=el.querySelector('.banner-lines');
          if(old){
            const tmp=document.createElement('div');
            tmp.innerHTML=mkLinesHTML(it);
            old.replaceWith(tmp.firstElementChild);
          }
          recalc();
        });
      });
      return el;
    };

    // Coluna esquerda: Banner 1
    const left=document.createElement('div');
    if(b1) left.appendChild(mkCard(b1,'Banner 1'));
    row.appendChild(left);

    // Coluna do meio: TODOS os rebanners LADO A LADO
    const mid=document.createElement('div'); mid.className='rebanners-row';
    rebs.forEach((rb,i)=>{
      const card=mkCard(rb, `Rebanner ${rebs.length>1?i+1:''}`.trim());
      card.classList.add('rebanner-card');
      mid.appendChild(card);
    });
    if(rebs.length) row.appendChild(mid); else row.appendChild(document.createElement('div')); // mantém 3 colunas

    // Coluna direita: Banner 2
    const right=document.createElement('div');
    if(b2) right.appendChild(mkCard(b2,'Banner 2'));
    row.appendChild(right);

    group.appendChild(row);
    wrap.appendChild(group);
  });
}






  // ===== Cálculos =====
  function ganhosFreePorDia(){
    let total = 0;
    planner.free.forEach(f=>{
      if(!f.usar) return;
      const q = +f.qtd || 0;
      switch(f.freq){
        case 'Diário': total += q; break;
        case 'Semanal': total += q/7; break;
        case 'Quinzenal': total += q/14; break;
        case 'Mensal': total += q/30; break;
      }
    });
    return total;
  }

  function recalc(){ simular(); persistTemp(); }
// ===== Alternador de servidor: Japão / China =====
const SERVER_KEYS = { JP: 'banners_JP', CN: 'banners_CN' };

// Inicializa os datasets por servidor.
// - Se ainda não existir, semeia JP com a lista atual e CN como cópia vazia (ou a atual, se preferir).
function initServerBanners(){
  // garante que planner existe
  window.planner = window.planner || {};
  if (!planner.server) planner.server = 'JP';

  // semear JP se vazio
  if (!localStorage.getItem(SERVER_KEYS.JP)) {
    localStorage.setItem(SERVER_KEYS.JP, JSON.stringify(planner.banners || []));
  }
  // semear CN se vazio (aqui começo igual ao JP; depois você edita a ordem manualmente)
  if (!localStorage.getItem(SERVER_KEYS.CN)) {
    localStorage.setItem(SERVER_KEYS.CN, JSON.stringify(planner.banners || []));
  }

  // carrega o dataset do servidor ativo para planner.banners
  const activeKey = SERVER_KEYS[planner.server] || SERVER_KEYS.JP;
  try {
    const saved = JSON.parse(localStorage.getItem(activeKey) || '[]');
    planner.banners = Array.isArray(saved) ? saved : [];
  } catch {
    planner.banners = planner.banners || [];
  }

  // estado visual dos botões
  document.getElementById('serverJPBtn')?.classList.toggle('active', planner.server === 'JP');
  document.getElementById('serverCNBtn')?.classList.toggle('active', planner.server === 'CN');
}

// Troca o servidor, salvando o dataset atual e carregando o outro.
function switchServer(s){
  if (!SERVER_KEYS[s]) return;
  if (!window.planner) return;

  // salva banners atuais no slot do servidor corrente
  const curKey = SERVER_KEYS[planner.server || 'JP'];
  try { localStorage.setItem(curKey, JSON.stringify(planner.banners || [])); } catch{}

  // carrega banners do novo servidor
  const nextKey = SERVER_KEYS[s];
  let next = [];
  try { next = JSON.parse(localStorage.getItem(nextKey) || '[]'); } catch{}
  planner.banners = Array.isArray(next) ? next : [];
  planner.server = s;

  // atualiza UI
  document.getElementById('serverJPBtn')?.classList.toggle('active', s === 'JP');
  document.getElementById('serverCNBtn')?.classList.toggle('active', s === 'CN');

  // re-render e recalcula
  if (typeof renderBanners === 'function') renderBanners();
  if (typeof recalc === 'function') recalc();
  if (typeof savePlanner === 'function') savePlanner(); // opcional
}
  // DEV: resetar dataset do servidor e reseed a partir da planilha atual
window.resetServer = function(s='JP'){
  const key = SERVER_KEYS[s] || SERVER_KEYS.JP;
  localStorage.removeItem(key);
  // re-semeia conforme init
  initServerBanners();
  renderBanners && renderBanners();
  recalc && recalc();
};
// Liga os botões (chame após montar o Planner)
function bindServerButtons(){
  document.getElementById('serverJPBtn')?.addEventListener('click', ()=>switchServer('JP'));
  document.getElementById('serverCNBtn')?.addEventListener('click', ()=>switchServer('CN'));
}

// >>> Em algum ponto da inicialização do Planner:

// (se já carrega banners antes, chame initServerBanners() logo depois)

  // meses pt-BR -> 1..12
const PT_MONTH_INDEX = {
  "janeiro":1,"fevereiro":2,"março":3,"marco":3,"abril":4,"maio":5,"junho":6,
  "julho":7,"agosto":8,"setembro":9,"outubro":10,"novembro":11,"dezembro":12
};
const norm = s => String(s||'').trim().toLowerCase();

// dias reais do mês (considera ano bissexto)
function daysInMonth(year, month1to12){
  return new Date(year, month1to12, 0).getDate();
}

// lê a data do input; se vazio, usa hoje
function getPlanStartDate(){
  const el = document.getElementById('planStartDate');
  const v = el && el.value ? new Date(el.value+'T00:00:00') : new Date();
  // zera hora
  return new Date(v.getFullYear(), v.getMonth(), v.getDate());
}

// atalho p/ “Hoje”
(function bindStartToday(){
  const b = document.getElementById('startTodayBtn');
  const i = document.getElementById('planStartDate');
  if (b && i){
    b.addEventListener('click', ()=>{
      const now = new Date();
      i.value = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')}`;
      if (typeof recalc === 'function') recalc();
    });
  }
  if (i){
    i.addEventListener('change', ()=>{ if (typeof recalc === 'function') recalc(); });
  }
})();

  function simular(){
  const tbody = $('#simTable tbody'); if(!tbody) return;
  tbody.innerHTML = '';

  // --- 0) saldos iniciais (cristais + tickets*150)
  // --- 0) saldos iniciais (cristais + tickets*150) — com casting seguro
const num = (id)=> Math.max(0, +(document.getElementById(id)?.value || 0));
const saldoCristais = num('saldoInicial');
const saldoTickets  = num('ticketsInic') * 150;
let saldo = saldoCristais + saldoTickets;


  // --- 1) ordem cronológica de meses a partir dos banners
  const order = [];
  const seen = new Set();
  (planner.banners||[]).forEach(b=>{
    const m = norm(b.mes);
    if(m && !seen.has(m)){ seen.add(m); order.push(m); }
  });

  // --- 2) agrega GASTOS/CASHBACK/EXTRAS por mês (somando banners daquele mês)
  const byMonth = new Map();
  const extrasTot = { ssrBox:0, milk:0, copy:0 };

  (planner.banners||[]).forEach(b=>{
    const m = norm(b.mes); if(!m) return;
    if(!byMonth.has(m)){
      byMonth.set(m, { mes:m, gastoBruto:0, cashback:0, custoLiquido:0, extras:{ssrBox:0,milk:0,copy:0} });
    }
    const t150 = +b.t150 || 0;
    const m100 = +b.m100 || 0;

    // custo total continua somando tudo
  const gastoBruto  = 150*t150 + 100*m100;

// ⚠️ EXTRAS agora contam SÓ tickets (150), sem memórias (100)
  const cbMilExtras = cashbackMilestones(t150);

    // cashback só com tickets
    const cbMilTickets = cashbackMilestones(t150);
    const cashbackPerc = Math.round((150*t150) * ((+b.cashback || 0)/100));
    const cashback     = (cbMilTickets.cashbackDiamonds || 0) + cashbackPerc;

    const custoLiquido = gastoBruto - cashback;

    const mm = byMonth.get(m);
    mm.gastoBruto   += gastoBruto;
    mm.cashback     += cashback;
    mm.custoLiquido += custoLiquido;

    // extras somam pelos pulls totais
    mm.extras.ssrBox += (cbMilExtras.extras?.ssrBox || 0);
    mm.extras.milk   += (cbMilExtras.extras?.milk   || 0);
    mm.extras.copy   += (cbMilExtras.extras?.copy   || 0);

    extrasTot.ssrBox += (cbMilExtras.extras?.ssrBox || 0);
    extrasTot.milk   += (cbMilExtras.extras?.milk   || 0);
    extrasTot.copy   += (cbMilExtras.extras?.copy   || 0);
  });

  // --- 3) ganhos por mês (FREE + distribuir CASH a partir da data de início)
  const ganhoDiaFREE = ganhosFreePorDia();
  const start = getPlanStartDate();
  const startMonthIdx = start.getMonth()+1; // 1..12
  const startYear = start.getFullYear();

  // encontra o índice do 1º mês que coincide com a data de início;
  // se não encontrar, usa o primeiro da lista (mês cheio).
  let idxStart = order.findIndex(m => PT_MONTH_INDEX[m] === startMonthIdx);
  if (idxStart === -1) idxStart = 0;

  // consumo de CASH: começa na data de início
  // NÃO queremos mais consumo estadoful:



  // ano/mês correntes para cada entrada da order (contabiliza virada de ano)
  let runningYear = startYear;
  let prevIdx = startMonthIdx;

  // totais
  let totalGanhos=0, totalGastoBruto=0, totalCashback=0, totalLiquido=0;

  for (let i=0;i<order.length;i++){
    const label = order[i];
    const mIdx = PT_MONTH_INDEX[label] || 1;

    // avança o ano quando cruza dezembro->janeiro
    if (i === 0){
      // se a lista começa antes do mês de início, ajuste o ano para trás
      // (opcional: pode deixar como está; não afeta pró-rata)
    } else if (prevIdx > mIdx){
      runningYear += 1;
    }
    prevIdx = mIdx;

    // dias do mês real
    const dim = daysInMonth(runningYear, mIdx);

    // se o mês é anterior à data de início → pula (sem ganhos, sem custos)
    // Obs: se NÃO quiser pular custos de meses anteriores, troque o 'continue' por 'activeDays=0'.
    if (i < idxStart){
      continue;
    }

    // dias ativos: pró-rata no primeiro mês útil, cheios nos demais
    const activeDays = (i === idxStart)
      ? (mIdx === startMonthIdx ? Math.max(0, dim - (start.getDate() - 1)) : dim) // se o label for o mesmo mês da data
      : dim;

    // ganhos FREE + CASH desse mês (CASH consome 'activeDays' sequencialmente)
    // FREE do mês (mantém)
const gFree = Math.round(ganhoDiaFREE * activeDays);

// CASH do mês: Quantidade (por dia) × min(Frequência, dias ativos no mês)
let gCash = 0;
(planner.cash || []).forEach(c=>{
  if(!c || !c.usar) return;

  // Compat: alguns planos antigos usam c.porDia; no UI atual, a coluna é "Quantidade" => c.qtd
  const perDay = (+c.qtd || +c.porDia || 0);

  // "Frequência" agora significa "dias ativos no mês" (ex.: 30 = mês inteiro)
  const diasAtivosNoMes = Math.min(activeDays, +c.dias || 0);

  gCash += perDay * diasAtivosNoMes;
});

const ganhos = gFree + Math.round(gCash);


    // custos agregados daquele mês (se não houver, zero)
    const mm = byMonth.get(label) || { gastoBruto:0, cashback:0, custoLiquido:0 };

    // saldo
    const saldoIni = saldo;
    saldo = saldo + ganhos - mm.custoLiquido;

    // render linha
    const pretty = label.charAt(0).toUpperCase() + label.slice(1);
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${pretty}</td>
      <td class="right">${ganhos.toLocaleString('pt-BR')}</td>
      <td class="right">${(mm.gastoBruto||0).toLocaleString('pt-BR')}</td>
      <td class="right">${(mm.cashback||0).toLocaleString('pt-BR')}</td>
      <td class="right">${(mm.custoLiquido||0).toLocaleString('pt-BR')}</td>
      <td class="right">${saldoIni.toLocaleString('pt-BR')}</td>
      <td class="right">${saldo.toLocaleString('pt-BR')}</td>
    `;
    // pinta saldo final negativo
    const saldoCell = tr.querySelector('td:last-child');
    if (saldoCell) saldoCell.classList.toggle('neg', saldo < 0);

    tbody.appendChild(tr);

    // totais (se mantiver rodapé)
    totalGanhos     += ganhos;
    totalGastoBruto += (mm.gastoBruto||0);
    totalCashback   += (mm.cashback||0);
    totalLiquido    += (mm.custoLiquido||0);
  }

  // atualiza rodapé se você ainda estiver usando <tfoot> (se não, pode remover)
  const el = (id)=>document.getElementById(id);
  if (el('tGanhos'))      el('tGanhos').textContent      = totalGanhos.toLocaleString('pt-BR');
  if (el('tGastoBruto'))  el('tGastoBruto').textContent  = totalGastoBruto.toLocaleString('pt-BR');
  if (el('tCashback'))    el('tCashback').textContent    = totalCashback.toLocaleString('pt-BR');
  if (el('tLiquido'))     el('tLiquido').textContent     = totalLiquido.toLocaleString('pt-BR');
  if (el('tSaldoFinal')){ el('tSaldoFinal').textContent  = saldo.toLocaleString('pt-BR');
                          el('tSaldoFinal').classList.toggle('neg', saldo < 0); }

  // extras (se estiver usando a caixa abaixo da tabela)
  const simEl = document.getElementById('simExtras');
  if (simEl) {
    simEl.innerHTML = `
      <div><b>Extras Totais</b> —
        SSR Box: <b>${extrasTot.ssrBox}</b> •
        Milk: <b>${extrasTot.milk}</b> •
        Copy: <b>${extrasTot.copy}</b>
      </div>`;
  }
}


   

  // ===== Persistência =====
  function savePlan(name){
    const store = JSON.parse(localStorage.getItem(PLANS_KEY)||'{}');
    store[name] = JSON.parse(JSON.stringify(planner));
    localStorage.setItem(PLANS_KEY, JSON.stringify(store));
    fillSlots(name);
  }
  function loadPlan(name){
    const store = JSON.parse(localStorage.getItem(PLANS_KEY)||'{}');
    if(!store[name]) return;
    planner = JSON.parse(JSON.stringify(store[name]));
    $('#saldoInicial').value = planner.saldoInicial || 0;
    $('#nomePlano').value = name;
    renderFree(); renderCash(); renderBanners(); recalc();
  }
  function delPlan(name){
    const store = JSON.parse(localStorage.getItem(PLANS_KEY)||'{}');
    delete store[name];
    localStorage.setItem(PLANS_KEY, JSON.stringify(store));
  }
  function fillSlots(sel=''){
    const store = JSON.parse(localStorage.getItem(PLANS_KEY)||'{}');
    const sl = $('#slotsPlanos'); if(!sl) return;
    sl.innerHTML = '<option value="">(selecione um plano salvo)</option>';
    Object.keys(store).sort().forEach(k=>{
      const opt = document.createElement('option');
      opt.value = k; opt.textContent = k; if(k===sel) opt.selected = true; sl.appendChild(opt);
    });
  }
  function persistTemp(){
    const draft = JSON.parse(JSON.stringify(planner));
    try{ localStorage.setItem(DRAFT_KEY, JSON.stringify(draft)); }catch(e){}
  }
  function loadDraft(){
    try{
      const draft = JSON.parse(localStorage.getItem(DRAFT_KEY)||'null');
      if(draft){
        planner = draft;
        return true;
      }
    }catch(e){}
    return false;
  }

  // ===== Navegação =====
  function showPlanner(){ document.body.classList.add('show-planner'); document.getElementById('pagePlanner').style.display='block';document.body.classList.add('planner-open');}
  function showBuilder(){ document.body.classList.remove('show-planner'); document.getElementById('pagePlanner').style.display='none';document.body.classList.remove('planner-open'); }

  window.hqShowPlanner = showPlanner;
  window.hqShowBuilder = showBuilder;

  
  // ===== Boot =====
  function boot(){
    const btnOpen = document.getElementById('openPlannerBtn'); if(btnOpen) btnOpen.addEventListener('click', showPlanner);
    const btnBack = document.getElementById('btnVoltarBuilder'); if(btnBack) btnBack.addEventListener('click', showBuilder);
    
    
    const btnToggle = document.getElementById('toggleSources');
    if(btnToggle){ btnToggle.addEventListener('click', ()=> setCollapsed(!document.body.classList.contains('planner-collapsed'))); }
    const btnReopen = document.getElementById('reopenSources');
    if(btnReopen){ btnReopen.addEventListener('click', ()=> setCollapsed(false)); }
    const prev = localStorage.getItem(COLLAPSE_KEY);
// 1ª visita: mantém colapsado; visitas seguintes: respeita o salvo
if (prev === null) {
  setCollapsed(true);
} else {
  setCollapsed(prev === '1');
}


    const saldoEl = document.getElementById('saldoInicial'); if(saldoEl) saldoEl.addEventListener('input', ()=>{ planner.saldoInicial = +(saldoEl.value||0); recalc(); });
    const nomeEl  = document.getElementById('nomePlano');    if(nomeEl)  nomeEl.addEventListener('input', ()=>{ planner.nomePlano = nomeEl.value||''; persistTemp(); });
    
    const bSave = document.getElementById('btnSalvarPlano'); if(bSave) bSave.addEventListener('click', ()=>{
      const name = (document.getElementById('nomePlano').value||'').trim() || 'Plano';
      savePlan(name);
    });
    const bNovo = document.getElementById('btnNovoPlano'); if(bNovo) bNovo.addEventListener('click', ()=>{
      planner = { saldoInicial:0, nomePlano:'', free:JSON.parse(JSON.stringify(DEFAULT_FREE)), cash:JSON.parse(JSON.stringify(DEFAULT_CASH)), banners:[] };
      document.getElementById('saldoInicial').value = 0; document.getElementById('nomePlano').value='';
      seedBannersFromSheet();
      // 1) garante dados base (JP) em memória
if (!planner.banners || !planner.banners.length) seedBannersFromSheet();


      renderFree(); renderCash(); renderBanners(); recalc(); fillSlots(''); persistTemp();
    });
    const bDel = document.getElementById('btnExcluirPlano'); if(bDel) bDel.addEventListener('click', ()=>{
      const sel = document.getElementById('slotsPlanos').value; if(sel){ delPlan(sel); fillSlots(''); }
    });
    const slots = document.getElementById('slotsPlanos'); if(slots) slots.addEventListener('change', (e)=>{ const name = e.target.value; if(name) loadPlan(name); });

    const hadDraft = loadDraft();
    if(!hadDraft || !planner.banners || planner.banners.length===0 ||
       (planner.banners.length===1 && /^Novo Banner$/i.test(planner.banners[0]?.nome||'')) ){
      seedBannersFromSheet();
    }

    fillSlots(planner?.nomePlano || '');
    initServerBanners();     // <— COLE AQUI
    bindServerButtons();
    renderFree(); renderCash(); renderBanners(); recalc();
  }
  // === BIND: + Fonte FREE / + Fonte CASH ===
const $addFree = document.getElementById('addFree');
if ($addFree) {
  $addFree.addEventListener('click', () => {
    // linha nova FREE (usar/nome/qtd/freq)
    planner.free = planner.free || [];
    planner.free.push({ usar: true, nome: 'Nova fonte FREE', qtd: 0, freq: 'Mensal' });
    renderFree && renderFree();
    recalc && recalc();
    savePlanner && savePlanner();
  });
}

const $addCash = document.getElementById('addCash');
if ($addCash) {
  $addCash.addEventListener('click', () => {
    // linha nova CASH (usar/nome/diamantes por dia/dias)
    planner.cash = planner.cash || [];
    planner.cash.push({ usar: true, nome: 'Nova fonte CASH', qtd: 0, dias: 30 });
    renderCash && renderCash();
    recalc && recalc();
    savePlanner && savePlanner();
  });
}

  if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', boot);
  else boot();

})();
/* ==================== STATS BONDS – infra (revamp) ==================== */

/** 3.1) Nomes dos titulares do grid principal */
/** titulares + banco: quem pode aparecer listado no modal */
function getPresentTeamNames(){
  const main  = [...document.querySelectorAll('.hex')].map(s => s.dataset?.nome).filter(Boolean);
  const bench = [...document.querySelectorAll('.bench-slot')].map(s => s.dataset?.nome).filter(Boolean);
  return new Set([...main, ...bench]);
}

/** personagens salvos na conta (localStorage) */
const OWNED_KEY = 'hqOwnedCharsV2';
function loadOwned(){ try{ return new Set(JSON.parse(localStorage.getItem(OWNED_KEY)||'[]')); }catch(e){ return new Set(); } }
function saveOwned(set){ localStorage.setItem(OWNED_KEY, JSON.stringify([...set])); }
function clearOwned(){ localStorage.removeItem(OWNED_KEY); }

/** conjunto para ATIVAÇÃO: time (quadra+banco) + conta */
function getActivationSet(){
  const present = getPresentTeamNames();
  const owned   = loadOwned();
  return new Set([...present, ...owned]);
}

/** 3.2) Fonte de dados (segue igual: window.STATS_BONDS = {...}) */
const STATS_BONDS = (typeof window !== 'undefined' && window.STATS_BONDS) ? window.STATS_BONDS : {};

/** 3.3) (fallback opcional — mantém se quiser) */
if (!Object.keys(STATS_BONDS).length){
  window.STATS_BONDS = {
    "Team's Guardians": { "Nishinoya SSR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%", "Yaku SSR": "Receive +5/7/9/12/15, Receive +1/2/3/4/5%" },
    "Karasuno's Setters": { "Sugawara SP": "Toss +5/7/9/12/15, Toss +1/2/3/4/5%", "Kageyama UR": "" }
  };
}

/** 3.4) Extrai vínculos de stats “ativos” considerando titulares + conta */
function getActiveStatBonds(){
  const presentForList = getPresentTeamNames();   // quadra + banco (para mostrar)
  const activationSet  = getActivationSet();      // time + conta (para ativar)

  const out = [];

  for (const [bondName, mapping] of Object.entries(window.STATS_BONDS || {})){
    const allMembers = Object.keys(mapping);

    // Quem ativa (time + conta)
    const activators = allMembers.filter(k => activationSet.has(k));
    if (activators.length < 2) continue;

    // Quem aparece (somente time)
    const listed   = allMembers.filter(k => presentForList.has(k));
    if (listed.length === 0) continue;

    // Quem não está aparecendo (fora do time)
    const missing  = allMembers.filter(k => !presentForList.has(k));

    const toEntry = (name)=>({
      name,
      buff: mapping[name] || '',
      img: (characters.find(p => p.nome === name) || {}).img || ''
    });

    out.push({
      bondName,
      entries: listed.map(toEntry),
      missing: missing.map(toEntry)
    });
  }

  out.sort((a,b)=> a.bondName.localeCompare(b.bondName));
  return out;
}

  
/** 3.5) Picker “Personagens da conta” (multi-seleção com busca) */
function openOwnedPicker(){
  const owned = loadOwned();
  const allChars = (Array.isArray(characters) ? characters.slice() : []).sort((a,b)=>a.nome.localeCompare(b.nome));

  const backdrop = document.createElement('div'); backdrop.className = 'item-modal-backdrop';
  const box = document.createElement('div'); box.className = 'item-modal';
  backdrop.appendChild(box);

  box.innerHTML = `
    <h3>Adicionar Personagens da conta</h3>
    <div style="display:flex;gap:8px;align-items:center;margin:6px 0;">
      <input id="ownedSearch" placeholder="Pesquisar..." style="flex:1;padding:6px;">
      <button id="ownedAll"   class="item-btn" type="button">All</button>
      <button id="ownedClear" class="item-btn" type="button">Clear</button>
    </div>
    <div id="ownedGrid" class="owned-picker"></div>
    <div class="item-actions">
      <button id="ownedCancel" class="item-btn">Cancelar</button>
      <button id="ownedSave"   class="item-btn">Salvar</button>
    </div>
  `;

  const render = (term='')=>{
    const t = term.trim().toLowerCase();
    const grid = box.querySelector('#ownedGrid');
    grid.innerHTML = allChars
      .filter(c => !t || c.nome.toLowerCase().includes(t))
      .map(c => `
        <label class="owned-card">
          <img class="stats-char-thumb" src="${c.img}" alt="">
          <span>${c.nome}</span>
          <input type="checkbox" data-name="${c.nome}" ${owned.has(c.nome)?'checked':''}>
        </label>
      `).join('');
  };
  render();

  const markAll = (state)=>{
    box.querySelectorAll('input[type="checkbox"][data-name]').forEach(cb => cb.checked = state);
  };

  box.querySelector('#ownedSearch').addEventListener('input', e=>render(e.target.value));
  box.querySelector('#ownedAll').addEventListener('click',   ()=> markAll(true));
  box.querySelector('#ownedClear').addEventListener('click', ()=> markAll(false));

  box.querySelector('#ownedCancel').addEventListener('click', ()=>backdrop.remove());
  box.querySelector('#ownedSave').addEventListener('click', ()=>{
    const picked = new Set(
      [...box.querySelectorAll('input[type="checkbox"][data-name]')]
        .filter(i=>i.checked).map(i=>i.dataset.name)
    );
    saveOwned(picked);
    backdrop.remove();
    // Reabre o modal de Stat Bonds já com o cálculo novo (time + conta)
    openStatsBondsModal();
  });

  document.body.appendChild(backdrop);
}

/** 3.6) Modal de listagem (com imagens + ações) */
function openStatsBondsModal(){
  const list = getActiveStatBonds();

  const backdrop = document.createElement('div');
  backdrop.className = 'item-modal-backdrop';

  const modal = document.createElement('div');
  modal.className  = 'item-modal';

  let html = `<h3>Stats bonds ativos (${list.length})</h3>`;

  if (list.length === 0){
    html += `<p style="opacity:.85">Nenhum vínculo de stats está sendo adicionado pela composição atual (titulares + conta).</p>`;
  } else {
    html += `<div class="stats-bond-list">`;
    list.forEach((b, i) => {
      html += `
        <div class="stats-bond-item">
          <div class="stats-bond-head">
            <h4>${b.bondName}</h4>
            ${b.missing.length ? `<button class="see-details-btn" data-bond-id="${i}">See details</button>` : ``}
          </div>
          <ul>
            ${b.entries.map(e => `
              <li>
                ${e.img ? `<img class="stats-char-thumb" src="${e.img}" alt="${e.name}">` : ''}
                <b>${e.name}</b> — ${e.buff && e.buff.trim() ? e.buff : '<em>sem buff</em>'}
              </li>
            `).join('')}
          </ul>

          ${b.missing.length ? `
            <ul class="missing-list" data-bond-id="${i}" style="display:none;">
              ${b.missing.map(e => `
                <li class="missing-char">
                  ${e.img ? `<img class="stats-char-thumb" src="${e.img}" alt="${e.name}">` : ''}
                  <b>${e.name}</b> — ${e.buff && e.buff.trim() ? e.buff : '<em>sem buff</em>'}
                </li>
              `).join('')}
            </ul>
          ` : ``}
        </div>
      `;
    });
    html += `</div>`;
  }

  html += `
    <div class="item-actions">
      <button id="addOwnedBtn" class="item-btn">Adicionar personagens da conta</button>
      <button id="clearOwnedBtn" class="item-btn">Limpar tudo</button>
      <button id="closeStatsModal" class="item-btn">Fechar</button>
    </div>`;
  modal.innerHTML = html;

  backdrop.appendChild(modal);
  document.body.appendChild(backdrop);
  document.body.classList.add('modal-open');

  const close = ()=>{ document.body.classList.remove('modal-open'); backdrop.remove(); };
  backdrop.addEventListener('click', (e)=>{ if (e.target === backdrop) close(); });
  modal.querySelector('#closeStatsModal').addEventListener('click', close);

  // “Conta”
  modal.querySelector('#addOwnedBtn').addEventListener('click', ()=>{
    close(); openOwnedPicker();
  });
  modal.querySelector('#clearOwnedBtn').addEventListener('click', ()=>{
    if (confirm('Limpar todos os personagens da conta?')){ clearOwned(); close(); openStatsBondsModal(); }
  });

  // Toggle See details / Hide details
  modal.querySelectorAll('.see-details-btn').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const id = btn.dataset.bondId;
      const block = modal.querySelector(`.missing-list[data-bond-id="${id}"]`);
      const isHidden = !block || block.style.display === 'none';
      if (block){
        block.style.display = isHidden ? 'block' : 'none';
        btn.textContent = isHidden ? 'Hide details' : 'See details';
      }
    });
  });
}

/** 3.7) Liga o botão do painel (id="statsBondBtn") */
(function bindStatsBondButton(){
  const btn = document.getElementById('statsBondBtn');
  if (btn && !btn.__sbBound){
    btn.__sbBound = true;
    btn.addEventListener('click', ()=>{
      if (!window.STATS_BONDS || !Object.keys(window.STATS_BONDS).length){
        alert('Nenhum mapeamento de "stats bonds" foi carregado. Defina window.STATS_BONDS = {...} antes.');
        return;
      }
      openStatsBondsModal();
    });
  }
})();
(() => {
  const btn = document.getElementById('openPlannerBtn');
  if (btn) btn.classList.add('bond-btn','menu-link');
})();

(function bindInitials(){
  const t   = document.getElementById('ticketsInic');
  const out = document.getElementById('ticketsInicCrystals');
  if (t && out){
    const upd = ()=>{
      const v = Math.max(0, +t.value || 0);
      out.textContent = (v * 150).toLocaleString('pt-BR');
    };
    const fire = ()=>{ upd(); recalc && recalc(); };
    t.addEventListener('input',  fire);
    t.addEventListener('change', fire);   // <— garante recálculo em todos os casos
    fire();                               // <— recalc já na carga
  }
  const totalOut = document.getElementById('saldoInicialTotal');
if (totalOut && t){
  const s = document.getElementById('saldoInicial');
  const updTotal = ()=>{
    const saldo = (Math.max(0, +s?.value||0)) + (Math.max(0, +t.value||0) * 150);
    totalOut.textContent = saldo.toLocaleString('pt-BR');
  };
  t.addEventListener('input',  updTotal);
  t.addEventListener('change', updTotal);
  s?.addEventListener('input',  updTotal);
  s?.addEventListener('change', updTotal);
  updTotal();
}


  const s = document.getElementById('saldoInicial');
  if (s){
    const fire = ()=>{ recalc && recalc(); };
    s.addEventListener('input',  fire);
    s.addEventListener('change', fire);
  }
})();

// ===== Modal de Recursos (FREE/CASH) =====
(function(){
  const openBtn   = document.getElementById('openSourcesBtn');
  const modal     = document.getElementById('sourcesModal');
  const closeBtn  = document.getElementById('closeSourcesBtn');
  const bodySlot  = document.getElementById('sourcesModalBody');

  if(!openBtn || !modal || !bodySlot) return;

  let prevParent = null, prevNext = null; // onde devolver o painel ao fechar

  function openSourcesModal(){
  document.body.classList.remove('planner-collapsed');

  const panel = document.querySelector('.panel.sources');
  if(panel){
    prevParent = panel.parentNode;
    prevNext   = panel.nextSibling;
    bodySlot.appendChild(panel);
    panel.style.removeProperty('display');

    // ESCONDE o botão antigo de fechar/minimizar quando o painel está na modal
    const oldToggle = panel.querySelector('#toggleSources');
    if (oldToggle) oldToggle.style.display = 'none';
  }
  modal.classList.add('open');
  document.body.classList.add('modal-open');
  closeBtn?.focus();
}



  function closeSourcesModal(){
  const panel = document.querySelector('.modal-body .panel.sources');
  if (panel && prevParent){
    if (prevNext) prevParent.insertBefore(panel, prevNext);
    else          prevParent.appendChild(panel);
    panel.style.display = 'none';          // mantém oculto no layout base
    const oldToggle = panel.querySelector('#toggleSources');
    if (oldToggle) oldToggle.style.display = 'none'; // evita UI antiga
  }
  modal.classList.remove('open');
  document.body.classList.remove('modal-open');
}


  openBtn.addEventListener('click', openSourcesModal);
  closeBtn?.addEventListener('click', closeSourcesModal);

  // clicar fora fecha
  modal.addEventListener('click', (e)=>{
    if(e.target && e.target.getAttribute('data-close')) closeSourcesModal();
  });

  // ESC fecha
  document.addEventListener('keydown', (e)=>{
    if(e.key === 'Escape' && modal.classList.contains('open')) closeSourcesModal();
  });
})();

// forma esperada dos itens (exemplo mínimo):
// { id, mes: 'Setembro', tipo: 'Banner 1'|'Banner 2'|'Rebanner', nome: 'Oikawa UR', t150:0, m100:0, cashback:0 }

// forma esperada dos itens (exemplo mínimo):
// { id, mes: 'Setembro', tipo: 'Banner 1'|'Banner 2'|'Rebanner', nome: 'Oikawa UR', t150:0, m100:0, cashback:0 }

(function setCNOrder(){
  const cnList = [
  { id:'cn-agosto-banner-1-ushijima-ur', mes:'Agosto',   tipo:'Banner 1', nome:'Ushijima UR',    t150:0, m100:0, cashback:0 },
  { id:'cn-agosto-banner-2-kuro-ur',     mes:'Agosto',   tipo:'Banner 2', nome:'Kuro UR',        t150:0, m100:0, cashback:0 },

  { id:'cn-setembro-banner-1-oikawa-ur', mes:'Setembro', tipo:'Banner 1', nome:'Oikawa UR',      t150:0, m100:0, cashback:0 },
  { id:'cn-setembro-banner-2-bokuto-ur', mes:'Setembro', tipo:'Banner 2', nome:'Bokuto UR',      t150:0, m100:0, cashback:0 },

  { id:'cn-outubro-banner-1-miya-atsumu-ur', mes:'Outubro', tipo:'Banner 1', nome:'Miya Atsumu UR', t150:0, m100:0, cashback:0 },
  { id:'cn-outubro-rebanner-1-kuroo-ur',     mes:'Outubro', tipo:'Rebanner', nome:'Kuro UR',       t150:0, m100:0, cashback:0 },
  { id:'cn-outubro-banner-2-miya-osamu-ur',  mes:'Outubro', tipo:'Banner 2', nome:'Miya Osamu UR',  t150:0, m100:0, cashback:0 },

  { id:'cn-novembro-banner-1-Hoshiumi-ur',   mes:'Novembro', tipo:'Banner 1', nome:'Hoshiumi UR',       t150:0, m100:0, cashback:0 },
  { id:'cn-novembro-banner-2-hirugami-ur',mes:'Novembro', tipo:'Banner 2', nome:'Hirugami UR',    t150:0, m100:0, cashback:0 },

  { id:'cn-dezembro-banner-1-kageyama-ur', mes:'Dezembro', tipo:'Banner 1', nome:'Kageyama UR',   t150:0, m100:0, cashback:0 },
  { id:'cn-dezembro-rebanner-1-oikawa-ur', mes:'Dezembro', tipo:'Rebanner', nome:'Oikawa UR',     t150:0, m100:0, cashback:0 },
  { id:'cn-dezembro-banner-2-hinata-sp',   mes:'Dezembro', tipo:'Banner 2', nome:'Hinata SP',     t150:0, m100:0, cashback:0 },

  { id:'cn-janeiro-banner-1-kenma-sp',     mes:'Janeiro', tipo:'Banner 1', nome:'Kenma SP',       t150:0, m100:0, cashback:0 },
  { id:'cn-janeiro-banner-2-nishinoya-sp', mes:'Janeiro', tipo:'Banner 2', nome:'Nishinoya SP',   t150:0, m100:0, cashback:0 },

  { id:'cn-fevereiro-banner-1-sugawara-sp', mes:'Fevereiro', tipo:'Banner 1', nome:'Sugawara SP', t150:0, m100:0, cashback:0 },
  { id:'cn-fevereiro-banner-2-bokuto-sp',   mes:'Fevereiro', tipo:'Banner 2', nome:'Bokuto SP',   t150:0, m100:0, cashback:0 },

  { id:'cn-marco-banner-1-akaashi-sp',  mes:'Março', tipo:'Banner 1', nome:'Akaashi SP',         t150:0, m100:0, cashback:0 },
  { id:'cn-marco-banner-2-aone-sp',     mes:'Março', tipo:'Banner 2', nome:'Aone SP',            t150:0, m100:0, cashback:0 },

  { id:'cn-abril-banner-1-Sakusa-ur', mes:'Abril', tipo:'Banner 1', nome:'Sakusa UR',    t150:0, m100:0, cashback:0 },
  { id:'cn-abril-banner-2-komori-ur',     mes:'Abril', tipo:'Banner 2', nome:'Komori UR',        t150:0, m100:0, cashback:0 },

  { id:'cn-maio-banner-1-tsuki-sp',  mes:'Maio', tipo:'Banner 1', nome:'Tsuki SP',               t150:0, m100:0, cashback:0 },
  { id:'cn-maio-banner-2-kuro-sp',   mes:'Maio', tipo:'Banner 2', nome:'Kuro SP',                t150:0, m100:0, cashback:0 },

  { id:'cn-junho-banner-1-kunimi-sp',      mes:'Junho', tipo:'Banner 1', nome:'Kunimi SP',       t150:0, m100:0, cashback:0 },
  { id:'cn-junho-banner-2-koganegawa-sp',  mes:'Junho', tipo:'Banner 2', nome:'Koganegawa SP',   t150:0, m100:0, cashback:0 },
];

// salvar & aplicar na UI (CN)
localStorage.setItem('banners_CN', JSON.stringify(cnList));
if (window.planner){
  planner.server = 'CN';
  planner.banners = cnList.slice();
  renderBanners && renderBanners();
  recalc && recalc();
  savePlanner && savePlanner();
}
})();



</script>
<script>
(function () {
  // === configure ===
  const ENDPOINT = 'https://script.google.com/macros/s/AKfycbyN60xk81yZ6aeMoFsx0QSQtHTuQUNqpnuByVvs4Jw_IwNGsYQoKAHfS8Uteal18kJy/exec'; // ex.: https://script.google.com/macros/s/XXX/exec
  // =================

  async function updateCounters() {
    try {
      // Conta visitas repetidas: sempre incrementa a cada carregamento
      const res = await fetch(ENDPOINT + '?inc=1', { cache: 'no-store' });
      const data = await res.json();

      // Atualiza a UI se existir (não quebra se você mover/ocultar o bloco)
      const t = document.getElementById('visits-today');
      const g = document.getElementById('visits-total');
      if (data && !data.error) {
        if (t) t.textContent = data.todayCount ?? '0';
        if (g) g.textContent = data.total ?? '0';
      } else {
        console.warn('Counter API error:', data && data.error);
      }
    } catch (err) {
      console.error('View counter fetch failed:', err);
    }
  }

  // Dispara quando o DOM estiver pronto (não interfere no seu JS atual)
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', updateCounters);
  } else {
    updateCounters();
  }
})();
</script>
</body>
</html>
